<body>
<font size=7><b><i>
Enstore Data Storage System
</i></b></font>
<p>
<font size=+3><b>Table of Contents</b></font>
<ul>
<li><a href="#overview">1 Overview of Enstore Architecture</a>
<li><a href="#pnfs">1.1 pnfs Namespace</a>
<li><a href="#encp">1.2 ENCP</a>
<li><a href="#encp_throttle">1.2.1 Throttling in <em>encp</em></a>
<li><a href="#servers">1.3 Enstore servers</a>
<li><a href="#volume_clerk">1.3.1 Volume Clerk</a>
<li><a href="#file_clerk">1.3.2 File Clerk</a>
<li><a href="#library_manager">1.3.3 Library Manager</a>
<li><a href="#user_request">1.3.3.1 Users' Requests</a>
<li><a href="#mover_request">1.3.3.2 Movers' Requests</a>
<li><a href="#pub_request">1.3.3.3 Publisher Requests</a>
<li><a href="#mover">1.3.4 Mover</a>
<li><a href="#config_server">1.3.5 Configuration Server</a>
<li><a href="#log_server">1.3.6 Log Server</a>
<li><a href="#media_changer">1.3.7 Media Changer</a>
<li><a href="#db">2 Databases in Enstore</a>
<li><a href="#backup_recovery">2.1 Backup and Recovery Procedures</a>
<li><a href="#backup">2.1.1 Backup </a>
<li><a href="#recovery">2.2.2 Recovery</a>
<li><a href="#current_db">2.2 Current Underlying Database Implemented in Enstore</a>
<li><a href="#admin_tools">2.3 Administrative Tools</a>
<li><a href="#protocol">3 Communication Protocols</a>
<li><a href="#read_protocol">3.1 Read Protocol</a>
<li><a href="#write_protocol">3.2 Write Protocol</a>
<li><a href="#error">4 Error Control</a>
</ul>

<p>
<h2><a name="overview">
1 Overview of Enstore Architecture
</h2>

Enstore uses a client-server architecture to provide a generic interface for users
to efficiently use mass storage systems.
Enstore supports multiple distributed media robots,
each of which may handle multiple media types or individual directly attached
drives, and multiple distributed mover nodes.
The system architecture does not dictate an exact hardware architecture.
Rather, it specifies a set of general and generic networked hardware
and software components.
These components are loosely coupled in the sense that each one can be
replaced easily without affecting the rest of the system and
each class of components can be easily expanded to accommodate
the increased demand in performance or capacity.
<p>
The system is written in <em>python</em>, a scripting
language that has advanced object-oriented features.
Python provides a sound environment for quick turn-around
and a seamless integration/migration path to
fully compiled languages, such as C and C++, if there is a demand
for even better performance.
<p>
Enstore has four major kinds of software components:
<ul>
<li><em>namespace</em>, implemented by the <em>pnfs</em> package from
	<em>DESY</em>
<li><em>encp</em>, a program used to copy files to and from tape libraries
<li><em>servers</em>
	<ul>
	<li>Configuration server
	<li>Volume clerk
	<li>File clerk
	<li>Multiple, distributed library managers
	<li>Multiple, distributed movers
        <li>Media changer
	<li>Log server
	</ul>
<li><em>administration tools</em>
</ul>
These software components, as well as hardware components,
are shown schematically in the following system context diagram.
Hardware components are connected via IP.
Great care has been taken to ensure that the system will function well
under extreme load conditions.
By design, there is no preset limit on the number of concurrent user
computers nor on the number of physical tape libraries or tape drives.
The system is only limited by the availability of physical resources.
We control all of the source code for the system except for that of
<em>pnfs</em> (which is a well supported product from DESY).
<p>
<img src="enstore.gif">
<p>
<a href="enstore.ps">(also available in Postscript)</a>
<p>
Enstore does not yet support a disk cache or buffer in front of tape.
However, one is conceivable and planned for a future release.
<p>
Like <em>tcp</em>, the system is architected with distributed and
peer-to-peer reliability.
Each request originating from the <em>encp</em> program is branded
with a unique ID.
<em>Encp</em> retries under well-defined circumstances, issuing
an equivalent request with a new unique ID.
The system can instruct <em>encp</em> to re-try if it needs to back out
of an operation.

<h2><a name="pnfs">
1.1 pnfs Namespace
</h2>
The DESY <a href=http://mufasa.desy.de/pnfs/Welcome.html><em>pnfs</em>
(http://mufasa.desy.de/pnfs/Welcome.html) </a>package implements an <em>nfs</em> daemon and
mount daemon.
These daemons do not actually serve a file system, but, instead make a
collection of database entries looks like a file system,
and provide control information for the system.
<p>
To inspect files, users mount their portion of the <em>pnfs</em> file
system on their own computers,
and interact with it using the native operating system utilities.
For example, users can <em>ls</em>, <em>stat</em>,
<em>mv</em>, <em>rm</em> or <em>touch</em> existing "files",
but are given errors on attempts to read
or write the content of the files.
Users can also <em>mkdir</em> and <em>rmdir</em>, and <em>ln</em> files. [Some
special files can also contain data that administrators can write to and users
can read from, so in that sense pnfs also provides normal files as well.]
<p>
Normal UNIX permissions and administered export points
are used to prevent unauthorized access to the name space.
<p>
Enstore uses pnfs for three different kinds of access and information:
<ol>
<li>Administration Interactions
    <br>
    An administrator can create special files in <em>pnfs</em> name space.
    For example, one type of file signifies that the system needs to be
    drained. Existence of the file causes <em>encp</em> to stall,
    preventing users from submitting additional jobs.
    <p>
<li>Configuration Information
    <br>
    When files are created on some media some creation details 
    need to be provided. Enstore uses pnfs tag files for these purposes.
    These files are created in a specific part of the name space and are
     associated with a directory and not any specific file.
    Examples of configuration information include file family name, file
     family width, library manager and so forth.
     <p>

<li>User File information
    <br>
    The rest of the system identifies a file by a 64-bit numeric
    identifier, dubbed a "bit file ID".
    After a file is written to tape, the file clerk generates a bfid and
     <em>encp</em>     stores this information 
     in one of the pnfs file layers.
    <em>Encp</em> can access this bit file id, giving it to the servers
    when fetching data from tape.
     Other file transfer details, such as time of last access or location of
     where the file was copied to or transfer rates, are stored in a different
     layer of the same pnfs file.
</ol>
<h2><a name="encp">
1.2 ENCP
</h2>
Reading and writing files means interacting with media.
This is done with an enstore-provided utility, <em>encp</em>.
<em>encp</em> is very similar to the <em>cp</em> command in UNIX.
The syntax is:
<pre>
% encp [options] src_file dst_file
</pre>

<h3><a name="encp_throttle">
1.2.1 Throttling in <em>encp</em>
</h3>

It is important not to swamp any system.
In <em>Enstore</em>, a first level of throttling is implemented in
<em>encp</em>.
Control communications in <em>Enstore</em> uses a simple reliable
request-response protocol using <em>UDP</em>, but data transfers
are implemented using two TCP ports.
A fixed number, currently 30, of pre-allocated TCP ports are
arbitrated among all instances of <em>encp</em> on a given machine.
Consequently, the system will survive the worst sort of abuse,
for example, someone forking off 200 copy requests,
since at most 15 will be active in the system at any time.

<h2><a name="servers">
1.3 Enstore servers
</h2>

Enstore servers are software entities which handle tape, and in a
future release, disk caches.
The high level  concepts are as follows:
<dl>
<dt><em>Physical library</em>
<dd>Physical Library represents a real, tangible collection of media
along with software drivers/utilities to manipulate, read and write
and organize them.

A physical library can be thought of as consisting of
<ul>
	<li>one or more virtual libraries
	<li>a media changer
	<li>one of more media export/import slots
	<li>one of more drives (tape, cdrom, disk, etc.)
	<li>volumes (tape cartridges, cdroms, etc.)
</ul>
<p>
<em>Virtual Library</em> -- A virtual library contains one and only one
kind of media.
For example, Enstore divides an STK powderhorn
library holding 50, 20 and 10 GB redwood media into at least three
virtual libraries.  In common usage, the term "library" in Enstore
refers to a virtual library. Writes are directed to a specific (virtual)
library, thus selecting the media.
<p>
<em>Drives</em> -- Drives are bound to special processes called mover
clients.
The drives can be dynamically assigned allowing the number of drives
to be less than the number of virtual libraries.
<p>
<em>Volumes</em> -- Are uniquely identified by an external label,
which is known to the media changer.
<p>
<dt><em>Quota Family</em>
<dd>A quota family is a set of pairs of media names and maximum number of volumes.
All files are created with respect to a quota family.
Creation of a file is not allowed if the maximum number of volumes
in that family would be exceeded.
<p>
<dt><em>File family</em>:
<dd>A file family is specified by a name and an integer "width".
A file family is associated with every file creation.
Within a given library, the <em>Enstore</em> system keeps no more
than <em>"width"</em> volumes, loaded on no more than <em>"width"</em>
number of drives for writing at any given moment.
This is not striping, but rather, the number of different volumes,
and hence different files, which can be active at one time.
Once a volume is associated with a file family, only files in that
family will be placed on the volume.
By design, there is no pre-set limit on the number of file families.
Clever use of file families will allow volumes to be faulted out to
"shelf", and also to decrease access times for subsequent reads.
</dl>
Media ejected to shelf are put into a shelf virtual library and
are controlled by a shelf library manager.
Users are informed that this data is currently unavailable, and if
they really want the data, arrangements should be made to have the
tapes placed in a library which is accessible,
or get it manually later.
<p>
<h3><a name="volume_clerk">
1.3.1 Volume Clerk
</h3>
The volume clerk has a single table database.
There is one record for each volume known to the system.
The record is looked up by a key.
The key is the volume's external label.
The information tracked for each volume is described in the table below:
The default values are shown in parentheses ().
<table>
<td valign=top><b>Column Name</b>
<td valign=top><b>Type</b>
<td valign=top><b>Comments</b>
<tr>
<td valign=top>external_label
<td valign=top>string [primary_key]
<td valign=top>Volume name specified by user on volume creation; is used to 
display volume meta-data.
<tr>
<td valign=top>file_family
<td valign=top>string ("none")
<td valign=top>File family name, specified by user on volume creation; only
files that belong to this family will be stored on this volume.
<tr>
<td valign=top>media_type
<td valign=top>string
<td valign=top>Specified at volume creation; defines the block-size; used for
writing.
<tr>
<td valign=top>library
<td valign=top>string 
<td valign=top>Specified by user on volume creation; defines which (virtual)
library currently holds the volume
<tr>
<td valign=top>first_access
<td valign=top>int (-1)
<td valign=top>Set by volume clerk when user issues the first <em>encp</em>
command to copy to the media.
<tr>
<td valign=top>last_access 
<td valign=top>int (-1)
<td valign=top>Set by volume clerk when user issues the first <em>encp</em>
command to copy to the media.
<tr>
<td valign=top>declared
<td valign=top>int
<td valign=top>Set by volume clerk at time of volume creation.
<tr>
<td valign=top>capacity_bytes
<td valign=top>64-bit int
<td valign=top>Specified by user on volume creation; estimate of the number of
bytes that would fit on the media.
<tr>
<td valign=top>blocksize
<td valign=top>int
<td valign=top>Set by the volume clerk; defined by the media type.
<tr>
<td valign=top>remaining_bytes
<td valign=top>64-bit int
<td valign=top>Specified by the user on volume creation; estimate of the number
of bytes that would fit on the media; updated by the volume clerk every time
data are written to the media.
<tr>
<td valign=top>eod_cookie
<td valign=top>string ("none")
<td valign=top>Tells the driver how to space to the end of the volume; it is
driver specific; updated by the volume clerk when data are written on the
media.
<tr>
<td valign=top>wrapper
<td valign=top>string ("cpio")
<td valign=top>Wrapper method; currently specifies the format of the files on
the media.
<tr>
<td valign=top>sum_rd_err
<td valign=top>int (0)
<td valign=top>Read error count; volume clerk updates this field when the mover
receives an error while reading from the media.
<tr>
<td valign=top>sum_rd_access
<td valign=top>int (0)
<td valign=top>Access error count; volume clerk updates this field when the
mover receives an error while accessing the media for read.
<tr>
<td valign=top>sum_wr_err
<td valign=top>int (0)
<td valign=top>Write error count; volume clerk updates this field when the
mover receives an error while writing to the media.
<tr>
<td valign=top>sum_wr_access
<td valign=top>int (0)
<td valign=top>Access error count; volume clerk updates this field when the
mover receives an error while accessing the media for write.
<tr>
<td valign=top>user_inhibit
<td valign=top>string (d:"none" or "readonly", "all")
<td valign=top>Specified by user at volume creation; access level for this
volume, updated by volume clerk.
<tr>
<td valign=top>system_inhibit
<td valign=top>string (d:"none" or "writing", "readonly", "full") 
<td valign=top>Enstore generated limitation on the kind of access permitted to
this volume; update by volume clerk when data are written on the media, an
error occurred while data were being written or the file size exceeded the
remaining number of bytes on the media.
</table>
<p>
The volume clerk does the following short, atomic operations:
<ul>
<li>show the name of all the volumes
<li>show volume information
<li>add a volume
<li>delete a volume
<li>find the appropriate volume on which to write the file
<li>change the number of remaining bytes on the volume
<li>set the number of read/write errors
<li>set the current status of the volume
<li>set the volume as readonly
<li>start/stop backup of volume journals
</ul>

<h3><a name="file_clerk">
1.3.2 File Clerk
</h3>
The file clerk tracks files in the system. There is one record for each file
in the system.
The records are keyed.
The key is the string version of the bit file ID
The default values are shown in parentheses ().
The fields tracked are as follows:
<table>
<td valign=top><b>Column Name</b>
<td valign=top><b>Type</b>
<td valign=top><b>Comments</b>
<tr>
<td valign=top>bfid
<td valign=top>primary key
<td valign=top>bit file id; uniquely identifies every file in the system.
<tr>
<td valign=top>external_label
<td valign=top>string 
<td valign=top>Volume name on which the file has been written; same as the
external_label in the volume table.
<tr>
<td valign=top>bof_space_cookie
<td valign=top>string
<td valign=top>Driver specific string telling how to space to the file on the
media.
<tr>
<td valign=top>complete_crc
<td valign=top>int
<td valign=top>crc of all the bits sent by the user.
<tr>
<td valign=top>sanity_cookie
<td valign=top>string ("(0,0)")
<td valign=top>Number of bytes used for a sanity crc and the sanity crc itself.
</table>
<p>
The file clerk supports the following requests:
<ul>
<li>show bfid of all the files
<li>show file information
<li>start/stop backup of file journals
</ul>

<h3><a name="library_manager">
1.3.3 Library Manager
</h3>
The library manager is a server which queues up and dispatches work for
a virtual library. There is one library manager for each virtual library
It has three types of clients
<ol>
<li><em>Users</em> -- seeking to have their files read or written files.
<li><em>Movers</em> -- seeking to actually read or write files.
<li><em>Publishers</em> -- seeking HTML describing the library's current work.
</ol>
<h3><a name="user_request">
1.3.3.1 Users' Requests
</h3>
<dl>
<dt>Writes into the system
<dd><em>pnfs</em> is used to identify
    the library for a write request, so the <em>encp</em> program composes
    a write request and contacts the appropriate library manager
    directly.
    The library manager queues the work, and acknowledges the request.

<dt>Read from the system
<dd><em>pnfs</em> holds only the bit
    file i.d., so <em>encp</em> contacts the bit file clerk, and that
    software ultimately contacts the appropriate volume manager, which
    queues up the work.
</dl>
The work is conceptually prioritized.
Larger priority numbers means higher priority.
Currently, write is of priority 10, read priority 1.
The priority is conceptually more flexible than that.
However, the system will exhaust all work for a volume,
given that it has been mounted, regardless of priority.
<p>
<h3><a name="mover_request">
1.3.3.2 Movers' Requests
</h3>
Movers seek to transport data between tape and users over a socket.
Movers contact library managers seeking work. If the library manager
has work, the mover is requested to mount a volume, and report
back. When reporting back, the mover may be told to contact a waiting
encp program and read or write a file.
The mover may be told to unmount a volume as there is no more work for
the volume.
A mover may have dismounted a volume unilaterally because it ran into
trouble.  This is summarized in the tables below
<table>
<td><b>Mover sends</b>
<td><b>Library manager may respond</b>
<tr>
<td>idle_mover
<td>bind a volume, or just acknowledge
<tr>
<td>have_bound_volume
<td>read, write or unbind
<tr>
<td>unilateral_unbind
<td>just acknowledge
</table>

<table>
<td valign=top><b>Library has just responded</b>
<td valign=top><b>Mover sends</b>
<td valign=top><b>Library manager presumes</b>
<tr>
<td valign=top>bind or...<br>read or...<br>write
<td valign=top>idle_mover
<td valign=top>mover crashed and was re-started
<tr>
<td valign=top>
<td valign=top>have_bnd_vol
<td valign=top>look for work on that volume<br>
    if work, give it<br>
    if none, give unbind
<tr>
<td valign=top>
<td valign=top>unilat_unbnd
<td valign=top>take any work reserved for that mover and put it back
   in the unassigned work queue
<tr>
<td valign=top>acknowledged a...<br>unilateral unbind or..<br>idle mover
<td valign=top>idle_mover
<td valign=top>mover is available for work, If I have work I may ask it to bind a
    volume
<tr>
<td valign=top>
<td valign=top>have_bnd_vol
<td valign=top>I have been restarted, the mover had a volume from a previous
    instance of me, tell it to unbind
<tr>
<td valign=top>
<td valign=top>Unilat_unbnd
<td valign=top>Just ack.
</table>

Note that if a mover should crash holding a volume, the worst that can
happen is that the library manager will be unable to schedule work for
that volume. If the physical library has more than one drive, the system
should be able to continue servicing requests.
<p>
<h3><a name="pub_request">
1.3.3.3 Publisher Requests
</h3>
Publishers are not yet implemented.

<h3><a name="mover">
1.3.4 Mover
</h3>
A mover task is bound to a drive, and seeks to use that drive to service
read and write requests.  It executes a protocol with a library manager,
as described in the tables in the library manager section (above).
<p>
A mover is bound to a drive, and a drive may serve more than one
virtual library, i.e.-a mover, gets a list of library managers
to service.  This has two benefits.
First, since a library manager handles only one type of media, a drive which
handles multiple types of media (i.e. different capacity media) can be shared
without a static partitioning of the system.
Second, if we are partitioning resources in a library, we can assign a library
manager to each type of use.  For example, suppose D0 and CDF want to share
the capacity of a library.
Suppose half the tapes belong to CDF and half to D0. We want to guarantee that
CDF have one third of the tape drives, D0 have one third, and the last third
be shared.  We can configure the movers to do this.  And with some slight
changes, this is how we can guarantee resources to data acquisition.
<p>
The mover hunts for work when it is idle by
consulting a configuration server.
The configuration server administers a configuration set.
A mover's configuration gives a list of library managers to hunt among
for work.
If there is no work at any library manager,
the mover sleeps for a while and begins the hunt again.
While sleeping the mover is sensitive to datagrams at a
specific UDP address. A library manager uses this mechanism to try to
hasten a mover when the library manager has work queued up.
<p>
When a mover has found a library manager that has work, it attempts
to mount the salient volume, by contacting the physical library's media
changer.  If there is some error, it issues a unilateral unbind to the
library manager. If all is well, it issues a have_bound_volume to the
library manager.
<p>
Reads -- Once a volume is bound the mover may read a tape and send data
to a waiting encp program. Two tcp ports are involved.
	The steps are:
<ol>
<li>Arbitrate for a TCP port for the data transfer.
<li>Open the tcp port (control port) specified in the request,
    send the encp program the data transfer port address,
    hold the control port open. If it is dropped, abort.
<li>Read the data from tape, (stripping any wrapper like tar headers)
    verify the sanity crc. send the data to the user.
<li>Close the data port.
<li>Tell the user done and all is well.
</ol>

If any errors occur while reading the tape, an attempt is made to
characterize them as either media or drive.  This is discussed more completely
in the section on Error control.
<p>
Writes -- Once a volume is bound the mover may receive data and write it to
tape. Two tcp ports are involved.
	The steps are:
<ol>
<li>Arbitrate for a TCP port for the data transfer.
<li>Open the tcp port (control port) specified in the request,
    send the encp program the data transfer port address,
    hold the control port open. If it is dropped, abort.
<li>Mark the volume as "writing". That will cause the volume to
    not be selected for subsequent writes, should we crash.
<li>Using the eod_space_cookie, space to end of volume. Try
    to verify that we are actually at the end of volume.
<li>Receive data from encp. (wrapper it) Write it to tape
<li>Close the data port.
<li>Compute new eod_cookie and tell volume clerk that the
    volume is writable. Update remaining bytes as well.
<li>Compute the file location cookie, and tell the bit
    file clerk about the new file. Get a bit file i.d. in return.
<li>Give the bit file i.d. to encp. We are done.
</ol>

If any errors occur while writing the tape, an attempt is made to characterize
them as either media or drive.  This is discussed more completely in the
section on Error control.  If the user drops the control tcp
channel unilaterally, assume he has aborted.
<p>
<h3><a name="config_server">
1.3.5 Configuration Server
</h3>
The Configuration server maintains the crucial information about
system configuration, such as the location and status of each server.
The first thing that each server does when it starts up is to
ask the configuration server for information (e.g. the location
of any other server with which to communicate).  New configurations can be
loaded into the Configuration server without disturbing the current running
system.
<h3><a name="log_server">
1.3.6 Log Server
</h3>
The Log server receives messages from other processes and logs them into
formatted log files.
Basically, these messages are transactional records.
Log files are labeled by dates.
At midnight each day, the currently opened log file gets closed and another
one is opened.
<p>
Additionally it is expected that a trace server will be developed.
<h3><a name="media_changer">
1.3.7 Media Changer
</h3>
The Media Changer mounts and dismounts the media into and from the drive
according to a request from the mover.  One media changer can serve multiple
drives and libraries.  When the drives are in the robot, the media changer
is the interface to the robotic software.
<h2><a name="db">
2 Databases in Enstore
</h2>
The database used in <em>Enstore</em> must provide the following:
<ul>
<li>
Support "python dictionary" interface.
<li>
Support journaling of the database to record all changes.
<li>
Support database check-pointing in order to enable full database recovery.
<li>
Support performing daily backups of the database, log, and journal files.
<li>
Support recovery of corrupted databases using the journal or log files.
</ul>

<h2><a name="backup_recovery">
2.1 Backup and Recovery Procedures
</h2>
<h3><a name="backup">
2.1.1 Backup 
</h3>
The backup procedure is a cron job that is performed daily. It copies 
the database files, log files and journal files to a designated 
directory on a remote host. Two environment variables should be set 
up for this purpose: ENSTORE_BCKP_HST (default="localhost") and 
ENSTORE_DB_BACKUP (default="tmp/backup"). The backup procedure will 
perform the following actions:
<p>
<table>
<tr>
<td valign=top>Libtp database
<td valign=top><ul>
<li>defines what log files are involved in active transactions<br>
<li>creates the tar file of database files and all log files <br>
<li>deletes all log files that are not involved in active transactions
</ul>
<tr>
<td valign=top>Volume journal files
<td valign=top><ul>
<li>does journal file checkpointing (hold database access, 
move current file to volume.jou.time_stamp, open empty 
journal file, release database access)
<li>creates tar file of volume database file and journal files
<li>deletes old journal files
</ul>
<tr>
<td valign=top>File journal file
<td valign=top><ul>
<li>does journal file checkpointing
<li>creates tar file of file database file and journal files
<li>deletes old journal files
</ul>
<tr>
<td valign=top>Archives creation
<td valign=top><ul>
<li>creates new directory on remote host under designated 
"root archival" director (name dbase.time_stamp)
<li>moves all the tar files to this area
</ul>
<tr>
<td valign=top>Archives cleanup
<td valign=top><ul><li>deletes all the archival directories created more then 
N days ago (default is 10 days)</ul>
</table>
<h3><a name="recovery">
2.2.2 Recovery
</h3>
Recovery should be a job initiated manually in case of database corruption. 
There are two ways to recover from a crash:
<p>
<table>
<tr>
<td valign=top>libtp utility
<td valign=top><ul>
<li>copy database tar file in designated directory, untar the file
<li>copy the latest log file from $ENSTORE_DB,
<li>run db_recover utility
<li>delete all related files from $ENSTORE_DB
<li>move the resulting database files and the latest log file to $ENSTORE_DB
</ul>
<tr>
<td valign=top>recovery from the journal files (not implemented yet)
<td valign=top><ul>
<li>copy database (database files and journal files) tar file 
<li>in designated directory, untar the file
<li>copy the latest jouurnal file from the $ENSTORE_DB,
<li>run jou_recover utility
<li>delete all related files from $ENSTORE_DB
<li>move the resulting database files to $ENSTORE_DB
</ul>
</table>

<h2><a name="current_db">
2.2 Current Underlying Database Implemented in Enstore
</h3>

The current Enstore implementation uses LIBTP (BSD DB v2.3) as the underlying
database product.
LIBTP is free for non-profit organizations like Fermilab, and has the
following features:

<ul>
<li>
one key dictionary-like database. It is designed to
store/retrieve binary large objects (BLOBs) of arbitrary length, by text key.
<li>
ability to store data items of unlimited size
<li>
support for various data storage structures: hash table, binary tree,
numbered records
<li>
allows duplicate keys
<li>
data scanning with cursors, multiple cursors may be opened at the same time
<li>
different levels of cursor stability
<li>
transactions
<li>
transaction logging
<li>
check-pointing
<li>
backup and recovery tools
<li>
custom locks
<li>
deadlock detection
</ul>


A LIBTP-Python shelve-like interface was developed. It provides access to:
<ul>
<li>All three data structures: hash table, binary tree, numbered records
<li>Cursors
<li>Transactions
<li>Locks
</ul>

LIBTP was chosen based on the following considerations:

<ul>
<li>
It is similar to dbm-like databases used for the initial Enstore design.
This made it easy to develop a Python interface for it and any necessary
changes to the Enstore code were localized and relatively easy to make.
<li>
Database maintenance is relatively inexpensive. It requires only two
processes to run. One for check-pointing and the other for deadlock detection.
<li>
It is simple and fast enough.
<li>
It provides tools for database transaction logging, database backup and
recovery.
<li>
It is readily obtainable and free.
</ul>

<h2><a name="admin_tools">
2.3 Administrative Tools
</h2>

Administrative tools will provide the following operations:
<ul>
<li>Display the volume for a specified media
<li>List all the files and their location on a single or set of media
<li>List file/files on the media by creation date
<li>List all the media that belongs to a specified file family
<li>List files that belongs to a specified file family
<li>Display the date of the last mount for a specified volume
<li>List all media belonging to a file family sorted by the most recent media
mount date
<li>List all media belonging to a file family where the last access date is
before a specified date
<li>Export meta-data of ejected media into a flat file
<li>Import meta-data from a flat file when importing the media from outside the
Enstore system
<li>List all files/volumes that belong to user/group
<li>Mark the volume as readonly if all of the files on the media are older
than a specified date
</ul>

<h2><a name="protocol">
3 Communication Protocols
</h2>
The base protocol for Enstore is UDP for "brief" messages and TCP for data
transfers.

Transfers that use UDP are all less than size of max UDP packet so there
will be no problems with potential packet re-ordering (receiving packets out
of order).
<p>
The base server protocol is the same for all servers.  State-fullness is
minimized, not eliminated.
<p>
Each transmission has a unique ID, timeout and maximum number of retries
associated with it.  The timeout allows for debugging.
For each reception, the "message" is checked against messages received to see
if the reception is a repeat. If the reception is a *repeat request*, send a
saved copy of the response; if the reception is *repeat response*, just
ignored it. This will take care of the case when a timeout/retry happens just
before a response is received.

<h2><a name="read_protocol">
3.1 Read Protocol
</h2>
The communications performed during a read operation are illustrated in the
diagram below and described more fully in the following text.
<p>
NOTE: The communications between the Mover and the Configuration server happens
approximately every two minutes.  It has been added to the following drawing 
to show that this communication is important, but it can occur anywhere in the
communications flow before the Mover contacts the Library manager.
<p>
<img src=read.gif>
<p>
<a href="read.ps">(also available in Postscript)</a>
<p>
<ul>
<li>
The User (through <em>encp</em>) contacts PNFS asking for a bit file id (bfid)
for the named file.
<li>
PNFS returns the bfid to <em>encp</em>.
<li>
<em>encp</em> asks the Configuration server with which File clerk should it be
communicating.
<li>
The Configuration server returns the location of the appropriate File clerk.
<li>
<em>encp</em> sends the read request to the File clerk.
<li>
The file clerk asks the Volume clerk with which Library manger should it be
communicating.
<li>
The Volume clerk returns the location of the appropriate Library manager.
<li>
The File clerk asks the Library Manager to read the file.
<li>
The Library manager tells the File clerk that the request has been placed in 
it's queue.
<li>
The File clerk informs <em>encp</em> that the read request has been queued.
<li>
The Mover asks the Configuration server with which Library manager should it
be communicating.
<li>
The Configuration server returns the location of the appropriate Library
manager.
<li>
The Mover asks the Library manager if there is any work for it to do.
<li>
The Library manager tells the Mover which volume to mount.
<li>
The Mover asks the Media changer to mount a particular volume.
<li>
The Media changer responds once the volume is mounted.
<li>
The Mover tells the Library manager that the volume is mounted.
<li>
The Library Manager tells the Mover which file to read.
<li>
The Mover tells <em>encp</em> from which host and port to read the data.
<li>
The Mover send the data to <em>encp</em>.
<li>
The Mover tells <em>encp</em> when all the data has been transferred and sends
the crc information.
<li>
The read has completed.
<li>
The Mover tells the Library manager that he still has the volume mounted.
</ul>

<h2><a name="write_protocol">
3.2 Write Protocol
</h2>
The communications performed during a write operation are illustrated in the
diagram below and described more fully in the following text.
<p>
NOTE: The communications between the Mover and the Configuration server happens
approximately every two minutes.  It has been added to the following drawing 
to show that this communication is important, but it can occur anywhere in the
communications flow before the Mover contacts the Library manager.
<p>
<img src=write.gif>
<p>
<a href="write.ps">(also available in Postscript)</a>
<p>
<ul>
<li>
The User (through <em>encp</em>) contacts PNFS with a request to create a file.
<li>
PNFS returns the file family information to <em>encp</em>.
<li>
<em>encp</em> asks the Configuration server with which Library manager should 
it be communicating.
<li>
The Configuration server returns the location of the appropriate Library
manager.
<li>
<em>encp</em> sends the write request to the Library manager, including file 
family and number of bytes.
<li>
The Library manager tells the <em>encp</em> that the request has been placed in
it's queue.
<li>
The Mover asks the Configuration server with which Library manager should it
be communicating.
<li>
The Configuration server returns the location of the appropriate Library
manager.
<li>
The Mover asks the Library manager if there is any work for it to do.
<li>
The Library manager asks the Volume clerk for a volume for the file with the
specified size and file family.
<li>
The Volume clerk returns the volume to the Library manager.
<li>
The Library manager moves the file internally from one queue to another.
<li>
The Library manager tells the Mover which volume to mount.
<li>
The Mover asks the Media changer to mount a particular volume.
<li>
The Media changer responds once the volume is mounted.
<li>
The Mover tells the Library manager that the volume is mounted.
<li>
The Mover tells <em>encp</em> to which host and port to write the data.
<li>
The Mover tells the Volume clerk that he is appending to this tape.
<li>
The Volume clerk acknowledges this.
<li>
<em>encp</em> sends the data to the Mover.
<li>
The Mover tells the Volume clerk that the append operation is done and how much
space is left on the tape.
<li>
The Volume clerk acknowledges this.
<li>
The Mover tells the File clerk which file has been created.
<li>
The file Clerk responds with the bit file id.
<li>
The Mover tells <em>encp</em> that the file has been written and sends the bit
file id and the crc.
<li>
<em>encp</em> tells PNFS that the file has been created, and the bfid should
be stored.
<li>
The write has completed.
<li>
The Mover tells the Library manager that he still has the volume mounted.
<li>
The Library manager tells the mover that there is no work to be done.
<li>
The mover tells the Media changer to dismount the volume.
</ul>

<h2><a name="error">
4 Error Control
</h2>

Error control in Enstore is simple, because much of the system state
is stored in the <em>encp</em> client. The <em>encp</em> client can be given a
"retry-able error" and will resend data for a write into the system, or the
system can re-start a read from the system from scratch. This re-try
is given a very high priority when it is received by the library
manager -- put on the head of the unassigned work queue.

The Enstore system keeps unassigned read and write requests in a queue of
unallocated work in the library manager. Once a read or write requests'
turn comes, the library manager puts the request in a "work awaiting
mount" or "work at mover" queue. The reason for this is to track the
volumes for scheduling : the library manager must not command a different mover
to mount a tape for another mover. It is the mover, and not the library
manager which completes requests.

The three library manager queues are: 
<ul>
<li>Unscheduled work
<li>work awaiting a volume mount
<li>work at a mover.
</ul>
<p>
It is important to keep these queues consistent. Tape and reading
errors are handled in the mover, and can be handled by detailed design in 
the mover.
<p>
Many interesting errors are related to when the tape cannot be written
or read, or when it is suspected that tape is jammed, etc.
<p>
We need experience with the actual hardware. In the interim we make the 
following assumptions:
<ul>
<li>
If we have trouble during a load or unload operation, we assume that
the tape is physically jammed. Until a human looks at the problem, we
will permit no future operations on the drive or the volume.
<li>
If we have errors on writing a volume, we will not write on that
volume anymore.
<li>
If a tape drive has errors on "consecutive" tapes, we should "stop
using the tape drive". The number of errors allowed should be picked
up through the mover configuration, since we may have "more
temperamental" and "less temperamental" drives, we may want to
configure this parameter for each mover individually. 
<li>
If tape reads or spaces give error, we should track the errors. If
the recent history of the tape shows many errors, we should mark the
tape "no access" and bring it to the attention of an administrator.
Therefore, the Volume Clerk needs to track the "recent history" of
errors, and have a per-volume figure of merit which will mark the tape
for no access, given many recent errors.
<li>
Library manager:
<br>
Two Features should be added to the tickets to support re-tries. 
<ul>
<li>Tickets should be marked as retries or not by <em>encp</em>. Retries go 
to the head of the queue.
<li>Tickets should be marked with an "avoid this mover" field for read
retries, so the same tape drive can be avoided.
</ul>
<em>encp</em> should generate these fields appropriately, and the queuing logic
in the library manager ought to implement the logic associated with these
fields.
<p>
The Enstore system should check the read/write state of a tape read very
early when the request is queued, to give an error if the access
is not allowed. However, an error may change the state of a tape while
its corresponding work is in the library manager queue. Therefore, a
late check is required. The system already performs a "late check"
for writes, since a volume must be selected for every file. The system
needs a "late check" for reads. Failing a late check means contacting
<em>encp</em> to give it the bad news. The contact should be done in the mover,
not in the library manager, just before the mover goes off to mount the volume
for read, since the mover is better able to tolerate a very slow or
non-existent <em>encp</em>. It is good to contact 
<em>encp</em> before a mount, too, since people <em><b>will</b></em> ^C <em>encp</em>'s and
it is best to discover this <em><b>before</b></em> incurring the expense of a mount.
<li>
"Freeze the tape in the drive" means:
<ul>
<li>Not unloading the tape from the drive
<li>Freezing the tape
<li>Off-lining the Drive
</ul>
<li>
"Freezing the tape" means:
<ul>
<li>mark the tape as "system noaccess"
<li>log that this happened and let an administrator look at the
problem in the morning.
<li><em>encp</em> shall not re-try.
</ul>
<li>
"Off-lining the drive" means:
<ul>
<li>Preserving as much state as possible.
<li>Writing a complete description in an error log.
<li>Leaving the problem until business hours unless the capacity of
the system falls below a threshold.
</ul>
</ul>

<table>
<th><font size=+1><b>Tape Write Errors</b></font>
<tr>
<td valign=top><b>WRITE_NOTAPE</b>
<td valign=top>"no such tape" error in library mount failure on write.
    If this happens, the volume data base is inconsistent with reality.
    Mover shall freeze the tape.
    <em>encp</em> shall retry.
<tr>
<td valign=top><b>WRITE_TAPEBUSY</b>
<td valign=top>"The media changer says that the tape is in another drive"
    Enstore has a bug, or some other system has mounted the tape or
    library micro put the tape somewhere else.
    Mover shall freeze the tape.
    <em>encp</em> shall retry.
<tr>
<td valign=top><b>WRITE_BADMOUNT</b>
<td valign=top>Other mount failure on write, or load operation failed.
    Must assume jammed tape.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall re-try
<tr>
<td valign=top><b>WRITE_BADSPACE</b>
<td valign=top>"EOD cookie does not produce EOD"
    Wrong tape, software bug or drive space error.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall retry.
<tr>
<td valign=top><b>WRITE_ERROR</b>
<td valign=top>"Error when writing data block or file mark"
    Run of the mill write error.
    If the drive has had many recent errors, mover shall
    "offline the drive"
    The volume shall be marked read-only.
    <em>encp</em> shall re-try.
<tr>
<td valign=top><b>WRITE_EOT</b>
<td valign=top>"Hit EOT while writing data block or file mark"
    Hit EOT. Mover shall mark volume full.
    <em>encp</em> shall retry. 
<tr>
<td valign=top><b>WRITE_UNLOAD</b>
<td valign=top>"error when unloading tape from drive"
    Must assume that the tape is physically jammed.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall retry.
    No <em>encp</em> is associated with the tape at this time.
<tr>
<td valign=top><b>WRITE_UNMOUNT</b>
<td valign=top>"Media changer gives error when unmounting tape"
    Should not happen. Maybe the tape is hanging in the drive. Does no harm.
    Mover shall freeze the tape in the drive.
    No <em>encp</em> is associated with the tape at this time.
<tr>
<td valign=top><b>WRITE_NOBLANKS</b>
<td valign=top>The volume clerk has no blank volumes to give.
    The requests shall return an error. 
    (do not "wait forever" -- DAQ should switch to an alternate library)
    An administrator shall be paged.
<tr>
<th><font size=+1><b>Tape Read Errors</b></font>
<tr>
<td valign=top><b>READ_NOTAPE</b>
<td valign=top>"No such tape in library" mount failure on read.
    If this happens, the volume data base is inconsistent with reality.
    Mover shall freeze the tape.
<tr>
<td valign=top><b>READ_TAPE_BUSY</b>
<td valign=top>"The media changer says that the tape is in another drive"
    Enstore has a bug, or some other system has mounted the tape or
    the robotic software put the tape somewhere else.
    Mover shall freeze the tape.
<tr>
<td valign=top><b>READ_BADMOUNT</b>
<td valign=top>Other Mount failure on read, or load operation failed.
    We have to assume that the tape is jammed in the drive.
    Mover shall freeze the tape in the drive.
<tr>
<td valign=top><b>READ_BADLOCATE</b>
<td valign=top>Failed space or initial CRC's don't match on initial read.
    We have attempted to space to a file on the tape. Either the file location
    cookie is somehow corrupted, we have the wrong tape in the drive or
    the tape drive cannot space properly. 
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry
<tr>
<td valign=top><b>READ_ERROR</b>
<td valign=top>Error when reading data block.
    Run of the mill read error.
    Mover shall consider the recent error history of the drive and the volume.
    If the drive has had many recent errors, mover shall offline the drive.
    <em>encp</em> shall re-try.
    If the volume has had many recent errors, mover shall freeze the tape.
    <em>encp</em> shall not retry.
    If the volume has had few recent errors,
    mover shall fail the transfer,
    <em>encp</em> shall re-try, and annotate that this mover shall be avoided.
<tr>
<td valign=top><b>READ_COMP_CRC</b>
<td valign=top>Failure of complete CRC.
    This needs investigating, as it should not happen. The drive and the tape
    are suspicious. Corrupt file location cookie, drive space error, wrong tape
    in the drive, etc.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry.
<tr>
<td valign=top><b>READ_EOT</b>
<td valign=top>Hit EOT when reading.
    Should not happen. Corrupt file location cookie, drive space error, or
    wrong tape in the drive. Should have hit an EOF.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry.
<tr>
<td valign=top><b>READ_EOD</b>
<td valign=top>Hit EOD when reading.
    Should not happen. Corrupt file location cookie, drive space error, or
    wrong tape in the drive. Should have hit an EOF.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry.
<tr>
<td valign=top><b>READ_UNLOAD</b>
<td valign=top>Error when unloading tape.
    Must assume that the tape is physically jammed.
    Mover shall freeze the tape in the drive.
    No <em>encp</em> is associated with the tape at this time.
<tr>
<td valign=top><b>READ_UNMOUNT</b>
<td valign=top>Error from media changer when unloading tape.
    Should not happen. Maybe the tape is hanging in the drive. Does no harm.
    Mover shall freeze the tape in the drive.
    No <em>encp</em> is associated with the tape at this time
<tr>
<th><font size=+1><b>Other Errors</b></font>
<tr>
<td valign=top><b>ENCP_GONE</b>
<td valign=top><em>encp</em> has gone away while request is queued.
    The mover contacts <em>encp</em> to ping it before a mount, and if 
    <em>encp</em> is not there, the mover does not go on to contact the media 
    changer, but instead returns a UNILATERAL_UNBIND to the library manager.
<tr>
<td valign=top><b>TCP_HUNG</b>
<td valign=top>DESY reports that 
<ul>
<li>sometimes machines can crash....
<li><em>encp</em> processes can be killed in a way that...
<li><em>encp</em> client's disks many fill up ...
<li>etc...
</ul>
which are all seen as the data TCP link is seen to
just hang. 
<p>
DESY's treatment is "harsh" -- They compute an anticipated transfer
time for every socket operation and abort the transfer if the
actual transfer takes more than several times the expected value.
Right now, Enstore does not consider this to be an error and just
waits. However, we are vulnerable to disaster. It is possible to see
circumstances where we might tie all the movers up if, say, one clients
system's disk fills up.
<tr>
<td valign=top><b>LM_CRASH</b>
<td valign=top>If a library manager crashes, and loses its queue of pending work,
    the <em>encp</em>'s will never be called back, and will wait
    forever.
    This is a problem. A basis for the solution is for a waiting 
    <em>encp</em> to ping its library manager,
    every 30 mins to see if its request has gotten lost.
    It would also be good if a --timeout switch was available to
    <em>encp</em>,
    since the users may wish to get an error rather than suffer a long
    delay.
<tr>
<td valign=top><b>MOVER_CRASH</b>
<td valign=top>
Case 1) If a mover is connected to an <em>encp</em>, then <em>encp</em> will
notice its sockets being torn down prematurely. <em>encp</em> shall retry. This
is not good enough.
<p>
For reads, the volume is tied up because the library manager has the volume as
being "at a mover". The retry will be hung in the library manager queue
because the library manager is unaware of the mover crash.
<p>
For writes, 1 is effectively deducted from the file family width,
since the library manager is unaware of the mover crash.
<p>
This is all a bug, the minimal effect of a mover crash should be:
<ul>
<li>
Since the status of the volume is unknown, the status should be akin
to "freeze drive and volume". However, subsequent reads will not produce an
error, but will be queued until the mover is restarted.
<li>
Allow writes to continue on a different volume of the same file 
family, without affecting the "width".
</ul>
<p>
Case 2) Mover has a volume, but is not associated with an <em>encp</em> and 
crashes.
Same problems as case 1) but <em>encp</em> will notice.
The total amount of time spent in this possibility is small compared to
the time corresponding to case 1 and case 3.
<p>
Case 3) Mover is idle.
This is O.K. The system degrades as specified.
</table>
</body>
