<html>
<head>
<title>
The Design of Enstore
</title>
<body>
<font size=7><b><i>
Enstore Data Storage System
</i></b></font>
<p>
<img src="undercon.gif"> the author is still working very hard on this
page.
<p>
<h1>
1 Introduction
</h1>
The Enstore system provides a generic interface for end users to efficiently
use mass storage systems as easily as if they were native file systems.
Enstore is architected as a <em>simple</em>, <em>efficient</em>,
<em>reliable</em> and <em>very flexible</em><font color=#ff0000>(anything else?)</font>
system.
It is <em>simple</em> because most of the operations are transparent to users.
It is <em>efficient</em> because the system performance is monitored
and is fine tunable.
It is <em>reliable</em> because a great deal of care has been taken to
ensure it is able to prevent or to recover from the worst case scenario.
It is <em>flexible</em> because it is based on a true client-server
model that allows hot swapping components and dynamic configuration, and,
it is platform independent and runs on heterogeneous environments.
This document will address the architecture behind it.

<h2>
2 Objectives
</h2>

<em>Enstore</em> is designed to accomplish the followings:
<br>
<font color=#ff8800><blink>Blah! Blah! Blah! ...</blink></font>
<br>
<font color=#0000ff>
(Say something about the presumed requirements as the goal of design)
</font>

<h2>
3 Overview of Enstore Architecture
</h2>

The Enstore system supports multiple distributed tape robots,
each of which may handle multiple media types,
and multiple distributed mover nodes.
Currently, the system is written in <em>python</em>, a scripting
language that has advanced object-oriented features.
It provides a sound environment for quick turn-around prototyping and
a seamless integration/migration path for portion or whole system to
fully compiled languages, such as C and C++, shall there is a demand
for even better performance.
<p>
The Enstore system has four major kinds of software components:
<ul>
<li><em>Namespace</em>, implemented by the <em>pnfs</em> package from
	<em>DESY</em>
<li><em>servers</em>
	<ul>
	<li>Configuration server
	<li>Volume clerk
	<li>File clerk
	<li>Multiple, distributed library managers
	<li>Multiple, distributed movers
        <li>Media changer
	<li>Log server
	</ul>
<li><em>encp</em>, a program used to copy files to and from tape libraries
<li><em>administration tools</em>.
</ul>
These software components, as well as hardware components, can be
described in the following system context diagram.
Hardware components are connected via IP.
Great care has been taken to ensure that the system will function well
under extreme load conditions.
By design, there is no preset limit on the number of concurrent user
computers nor on the number of physical tape libraries or tape drives.
The system is only limited by the availability of physical resources.
We control all of the source code for the system except for that of
<em>pnfs</em>.
<p>
<font color=#ff0000><blink>Will be replaced by real picture</blink></font>
<pre>
			+-----------------------------+
			|   USERS COMPUTER            |
			|  mkdir,ls           encp    |
			|  find                       |
			|  ....                       |
			+-----------------------------+
                          /                       \\
                      info                        data
                      /                             \\
+-----------------------------+	               +-----------------------------+
|  pnfs                       |	               |   Enstore Servers           |
|  surrogate files            |	               |                             |
|  administrative files       |	               |                             |
|  configuration files        |	               |                             |
|                             |	               |                             |
+-----------------------------+	               +-----------------------------+
                                                    |           ^
                                                 write        read
                                                    v           |
             +---------------------------------------------------------------+
             >           T A P E            T A P E          T A P E         >
             <                                                               <
             +---------------------------------------------------------------+
</pre>
<font color=#ff0000><blink>the figure is not quite right. need to say more about "info" and "data"</blink></font>
<p>
Version 1.0 does not yet support a disk cache in front of tape.
However, one is conceivable once the basic design principles are proved.
<p>
Like <em>tcp</em>, the system is architected with distributed and
peer-to-peer reliability.
Each request originating from the <em>encp</em> program is branded
with a unique i.d..
<em>encp</em> retries under well-defined circumstances, issuing
an equivalent request with a new unique i.d..
The system can instruct <em>encp</em> to re-try if it needs to back out
of an operation.
<p>
The details of each software component are described in the following
sections.
<h2>
3.1 Namespace
</h2>
The <em>pnfs</em> package implements an <em>nfs</em> daemon and mount
daemon.
These daemons do not actually serve a file system, but, instead make a
collection of database entries <em>look like</em> a file system,
and provide control information for the system.
<p>
<p>
To inspect files, users mount the <em>pnfs</em> file system on their own
computers, and interact with it using the native operating system
utilities.  For example, users can <em>ls</em>, <em>stat</em>,
<em>mv</em>, <em>rm</em> or <em>touch</em> existing "files",
but are given errors on attempts to read
or write the content of the files.
Users can <em>mkdir</em> and <em>rmdir</em>, and <em>ln</em> files.
<p>
Normal UNIX permissions and carefully administered export points
are used to prevent unauthorized access to the name space.
<p>
<h2>
3.2 ENCP
</h2>
Reading and writing files means interacting with tapes.
This is done with an enstore-provided utility, <em>encp</em>.

<em>encp</em> interacts with <em>pnfs</em>.
There are three kinds of accesses:
<ol>
<li>Interact with Administration
    <br>
    An administrator can create special files in <em>pnfs</em> name space.
    For example, one type of file signifies that the system needs to be
    drained. Existence of the file causes <em>encp</em> to stall.
    <p>
<li>Configuration Information
    <br>
    When files are created on tape media quite a bit of information
    needs to be provided.
    These files are created in a specific part of the name space.
    <em>Enstore</em> looks up towards the root of the name space,
    looking for special files with configuration information.
    Examples of configuration information are:
<pre>
	pnfs_library = "activelibrary"
	pnfs_quota_family = "family_raw"
	pnfs_file_family = "family_raw"
	pnfs_file_family_width = 2
	pnfs_uid = 01000
	pnfs_uname = "petravic"
	pnfs_gid = 0100
	pnfs_file_mode = 0644
</pre>
    More  about some of this information later.
    <p>
<li>File information
    <br>
    The rest of the system identifies a file by a 64-bit numeric
    identifier, dubbed a "bit file id".
    <em>pnfs</em> binds a bit file i.d. to names of regular files in
    the <em>pnfs</em> name space.
    <em>encp</em> can access this bit file id, giving it to the servers
    when fetching data from tape.
    After a file is written to tape, <em>encp</em> parks the bfid into
    the <em>pnfs</em> name space.
</ol>

<h3>
3.2.1 Throttling in <em>encp</em>
</h3>

It is important not to swamp any system.
In <em>Enstore</em>, a first level of throttling is implemented in
<em>encp</em>.
Control communications in <em>Enstore</em> uses a simple reliable
request-response protocol using <em>UDP</em>, but data transfers
are implemented using two TCP ports.
A fixed number, currently 30, of pre-allocated TCP ports are
arbitrated among all instances of <em>encp</em> on a given machine.
Consequently, the system will survive the worst sort of abuse,
for example, a student forking off 200 copy requests,
since at most 15 will be active in the system at any time.

<h2>
3.3 Enstore servers
</h2>

Enstore servers are software entities which handle tape, and in a
future release, disk caches.
The high level  concepts are as follows:
<dl>
<dt><em>Physical library</em>
<dd>Physical Library represents a real, tangible collection of tapes
along with software drivers/utilities to manipulate, read and write
and organize them.

A physical library can be thought of as consisting of
<ul>
	<li>one or more virtual libraries
	<li>a media changer
	<li>one of more media export/import slots
	<li>one of more drives (tape, cdrom, disk, etc.)
	<li>volumes (tape cartridges, cdroms, etc.)
</ul>
<p>
<em>Virtual Library</em> -- A virtual library contains one and only one
kind of media.
For example, we are constrained to divide an STK powderhorn
library holding 50, 20 and 10 GB redwood media into at least three
virtual libraries.  In common usage, the term "library" in Enstore
refers to virtual library. Writes are directed to a specific (virtual)
library, thus selecting the media.
<p>
<em>Drives</em> -- Drives are bound to special processes called mover
clients.
In the near future, we might be supporting 50 AIT drives in a grau robot;
today, we might have to support one redwood drive in a library with 3
virtual libraries. Rest assured the system handles this, and the number
of drives may be less than the number of virtual libraries.
<p>
<em>Volumes</em> -- Are uniquely identified by an external label,
which is known to the media changer.
<p>
<dt><em>Quota Family</em>
<dd>A quota family is a set of pairs of media names and maximum number of volumes.
All files are created with respect to a quota family.
Creation of a file is not allowed if the maximum number of volumes
in that family would be exceeded.
<p>
<dt><em>File family</em>:
<dd>A file family is specified by a name and an integer "width".
A file family is associated with every file creation.
Within a given library, the <em>Enstore</em> system keeps no more
than <em>"width"</em> volumes, loaded on no more than <em>"width"</em>
number of drives for writing at any given moment.
This is not striping, but rather, the number of different volumes,
and hence different files, which can be active at one time.
Once a volume is associated with a file family, only files in that
family will be placed on the volume.
By design, there is no pre-set limit on the number of file families.
Clever use of file families will allow volumes to be faulted out to
"shelf", and also to decrease access times for subsequent reads.
This can also effect transfer rates into the library by groups of users
(that are writing files associated with a specific file family).
</dl>
Twists to all of this are the special libraries -- shelf and
manually mounted libraries.
Shelf libraries bounce requests for tapes. The net effect is that
users are informed that this data is currently unavailable, and if
they really want the data, arrangements should be made to have the
tapes placed in a library which is accessible. (n.b. Enstore keeps a
log file, which would allow an administrator to identify the tapes)
Manually Mounted library are tapes in a drawer (or whatever) and an
operator.
<p>
<h3>
3.3.1 Volume Clerk
</h3>
The volume clerk has a single table database.
There is one record for each volume known to the system.
The record is looked up by a key.
The key is the volume's external label.
The details of volume clerk are discussed in the following
<em>"Databases in Enstore"</em> section.

<h3>
3.3.2 File Clerk
</h3>
The file clerk tracks files in the system. There is one record for each file
in the system.
The records are keyed.
The key is the string version of the bitfile i.d.
The details of file clerk are discussed in the following
<em>"Databases in Enstore"</em> section.

<h3>
3.3.3 Library Manager
</h3>
The library manager is a server which queues up and dispatches work for
a virtual library. There is one library manager for each virtual library
It has three types of clients
<ol>
<li><em>Users</em> -- seeking to have their files read or written files.
<li><em>Movers</em> -- seeking to actually read or write files.
<li><em>Publishers</em> -- seeking HTML describing the library's current work.
</ol>
<h3>
3.3.3.1 Users' Requests:
</h3>
<dl>
<dt>Writes into the system
<dd><em>pnfs</em> is used to identify
    the library for a write request, so the <em>encp</em> program composes
    a write request and contacts the appropriate library manager
    directly.
    The library manager queues the work, and acknowledges the request.

<dt>Read from the system
<dd><em>pnfs</em> holds only the bit
    file i.d., so <em>encp</em> contacts the bit file clerk, and that
    software ultimately contacts the appropriate volume manager, which
    queues up the work.
</dl>
The work is conceptually prioritized.
Larger priority numbers means higher priority.
Currently, write is of priority 10, read priority 1.
The priority is conceptually more flexible than that.
However, the system will exhaust all work for a volume,
given that it has been mounted, regardless of priority.
<p>
<h3>
3.3.3.2 Movers' Requests:
</h3>
Movers seek to transport data between tape and users over a socket.
Movers contact library managers seeking work. If the library manager
has work, the mover is requested to mount a volume, and report
back. When reporting back, the mover may be told to contact a waiting
encp program and read or write a file.
The mover may be told to unmount a volume as there is no more work for
the volume.
A mover may have dismounted a volume unilaterally because it ran into
trouble.  This is summarized in the tables below
<table>
<td><b>Mover sends</b>
<td><b>Library manager may respond</b>
<tr>
<td>idle_mover
<td>bind a volume, or just acknowledge
<tr>
<td>have_bound_volume
<td>read, write or unbind
<tr>
<td>unilateral_unbind
<td>just acknowledge
</table>

<table>
<td valign=top><b>Library has just responded</b>
<td valign=top><b>Mover sends</b>
<td valign=top><b>Library manager presumes</b>
<tr>
<td valign=top>bind or...<br>read or...<br>write
<td valign=top>idle_mover
<td valign=top>mover crashed and was re-started
<tr>
<td valign=top>
<td valign=top>have_bnd_vol
<td valign=top>look for work on that volume<br>
    if work, give it<br>
    if none, give unbind
<tr>
<td valign=top>
<td valign=top>unilat_unbnd
<td valign=top>take any work reserved for that mover and put it back
   in the unassigned work queue
<tr>
<td valign=top>acknowledged a...<br>unilateral unbind or..<br>idle mover
<td valign=top>idle_mover
<td valign=top>mover is available for work, If I have work I may ask it to bind a
    volume
<tr>
<td valign=top>
<td valign=top>have_bnd_vol
<td valign=top>I have been restarted, the mover had a volume from a previous
    instance of me, tell it to unbind
<tr>
<td valign=top>
<td valign=top>Unilat_unbnd
<td valign=top>Just ack.
</table>

Note that if a mover should crash holding a volume, the worst that can
happen is that the library manager will be unable to schedule work for
that volume. If the physical library has more than one drive, the system
should be able to continue servicing requests.
<p>
<h3>
3.3.3.3 Publisher Requests
</h3>
Publishers are not yet implemented.

<h3>
3.3.4 Mover
</h3>
A mover task is bound to a drive, and seeks to use that drive to service
read and write requests.  It executes a protocol with a library manager,
as described in the tables in the library manager section (above).
<p>
A mover is bound to a drive, and a drive may serve more than one
virtual library.
The mover hunts for work when it is idle by
consulting a configuration server.
The configuration server holds a
configuration set by an administration.
A mover's configuration gives a list of library managers to hunt among
for work.
If there is no work at any library manager,
the mover sleeps for a while and begins the hunt again.
While sleeping the mover is sensitive to datagrams at a
specific UDP address. A library manager uses this mechanism to try to
hasten a mover when the library manager has work queued up.
<p>
When a mover has found a library manager that has work, it attempts
to mount the salient volume, by contacting the physical library's media
changer.  If there is some error, it issues a unilateral unbind to the
library manager. If all is well, it issues a have_bound_volume to the
library manager.
<p>
Reads -- Once a volume is bound the mover may read a tape and send data
to a waiting encp program. Two tcp ports are involved.
	The steps are:
<ol>
<li>Arbitrate for a TCP port for the data transfer
<li>Open the tcp port (control port) specified in the request,
    send the encp program the data transfer port address
    hold the control port open. If it is dropped, abort.
<li>Read the data from tape, (stripping any wrapper like tar headers)
    verify the sanity crc. send the data to the user.
<li>Close the data port
<li>Tell the user done and all is well
</ol>

If any errors occur while reading the tape, an attempt is made to
characterize them as either media or drive.
If drive, mark the tape as hung, and kill ourselves.
If media, mark the media as no access.
<p>
Writes -- Once a volume is bound the mover may receive data and write it to
tape. Two tcp ports are involved.
	The steps are:
<ol>
<li>Arbitrate for a TCP port for the data transfer
<li>Open the tcp port (control port) specified in the request,
    send the encp program the data transfer port address
    hold the control port open. If it is dropped, abort.
<li>Mark the volume as "writing". That will cause the volume to
    not be selected for subsequent writes, should we crash.
<li>Using the eod_space_cookie, space to end of volume. Try
    to verify that we are actually at the end of volume.
<li>Receive data from encp. (wrapper it) Write it to tape
<li>Close the data port
<li>Compute new eod_cookie and tell volume clerk that the
    volume is writable. Update remaining bytes as well
<li>Compute the file location cookie, and tell the bit
    file clerk about the new file. Get a bit file i.d. in return
<li>Give the bit file i.d. to encp. We are done.
</ol>

If any errors occur while writing the tape, an attempt is made to characterize them as
either media or drive.  If drive, mark the tape as hung, and kill ourselves.
If media, mark the media as no access.  If the user drops the control tcp
channel unilaterally, assume he has aborted.
<p>
<font color=#ff0000><blink>Missing configuration server, log servers, and media changer</blink></font>
<h2>
4 More Detailed Block Diagram
</h2>
<p>
<font color=#ff0000><blink>Will be replaced by real picture</blink></font>
<pre>
                  3 user processes transferring
                       # = data
                       ! = control

                            ! #         !         ! #         !         ! #
____________________________!_#_________!____ ____!_#_________!_________!_#___
Enstore                     ! #         !         ! #         !         ! #
        ^                   ! #         !         ! #         !         ! #
        ! various           ! #         !         ! #         !         ! #
        ! connections       ! #         !         ! #         !         ! #
        v                  +-----+      !        +-----+      !        +-----+
 +--------+                |mover|      !        |mover|      !        |mover|
 |cnfg.srv|                +-----+      !        +-----+      !        +-----+
 +--------+\                  # ! \     !       / ! #   .*    !       / ! #
 +--------+ \                 # !  \+---------+/  ! #    .+---------+/  ! #
 |vol.clrk|  \                # !   |lib.mngrA|   ! #     |lib.mngrB|   ! #
 +--------+   \               # !   +---------+   ! #     +---------+   ; #
               } <--->        # !                 ; #                  /  #
 +--------+   / various       #  \               /  #                 /   #
 |fil.clrk|  / connections    #   \+-----------+/   #                /    #
 +--------+ /                 #    |media chngr|----#---------------'     #
 +--------+/                  #    +-----------+    #                     #
 |log.srvr|                   #         !           #                     #
 +--------+                   #         !           #                     #
                              #         !           #                     #
______________________________#_________!___________#_____________________#___
Library                       v         v           v                     v
                              #     +---------+     #                     #
                              #     |lib.ctlr |-----#--------------.      #
                              #     +---------+     #               \     #
                           +-----+ /           \ +-----+             \ +-----+
                           |drive|'             `|drive|              `|drive|
                           +-----+               +-----+               +-----+

</pre>
<ul>
<li>A mover, which is associated with one drive, gets a list of library managers
to service.  This has two benefits.
<p>
First, since a library manager handles only one type of media, a drive which
handles multiple types of media (i.e. different capacity media) can be shared
without a static partitioning of the system.
<p>
Second, if we are partitioning resources in a library, we can assign a library
manager to each type of use.  For example, suppose D0 and CDF want to share
the capacity of a library.  (lib.mngrA and B may then control same media type.)

<p>
Suppose half the tapes belong to CDF and half to D0. We want to guarantee that
CDF have one third of the tape drives, D0 have one third, and the last third
be shared.  We can configure the movers to do this.  And with some slight
changes, this is how we can guarantee resources to data acquisition.
<p>
The configuration is dynamic in the sense that each mover reads a new
configuration when it dismounts a tape.
</ul>
<h2>
5 Databases in Enstore
</h2>

Enstore requires databases that it will use to provide the following
functionality
<ul>
<li>
Support "python dictionary" interface.
<li>
Support journaling of the database to record all changes.
<li>
Support database check-pointing in order to enable full database recovery.
<li>
Support performing daily backups of the database, log, and journal files.
<li>
Support recovery of corrupted databases using the journal or log files.
</ul>

<h3>
5.1 Database Layout
</h3>

Currently, the database consists of two tables: "Volume" and "File".
These tables are accessed/modified via the volume and file clerks.
Any column which does not have a named default,
must be specified at volume creation time.
The default values are shown in parentheses ().
<p>
<table>
<td valign=top><b>Volume Table</b>
<tr>
<td valign=top><b>Column Name</b>
<td valign=top><b>Type</b>
<td valign=top><b>Comments</b>
<tr>
<td valign=top>external_label
<td valign=top>string (primary_key)
<td valign=top>Volume name specified by user on volume creation; is used to 
display volume meta-data.
<tr>
<td valign=top>file_family
<td valign=top>string ("none")
<td valign=top>File family name, specified by user on volume creation; only
files that belong to this family will be stored on this volume.
<tr>
<td valign=top>media_type
<td valign=top>string
<td valign=top>Specified at volume creation; defines the block-size; used for
writing.
<tr>
<td valign=top>library
<td valign=top>string 
<td valign=top>Specified by user on volume creation; defines which (virtual)
library currently holds the volume
<tr>
<td valign=top>first_access
<td valign=top>int (-1)
<td valign=top>Set by volume clerk when user issues the first <em>encp</em>
command to copy to the media.
<tr>
<td valign=top>last_access 
<td valign=top>int (-1)
<td valign=top>Set by volume clerk when user issues the first <em>encp</em>
command to copy to the media.
<tr>
<td valign=top>declared
<td valign=top>int
<td valign=top>Set by volume clerk at time of volume creation.
<tr>
<td valign=top>capacity_bytes
<td valign=top>64-bit int
<td valign=top>Specified by user on volume creation; estimate of the number of
bytes that would fit on the media.
<tr>
<td valign=top>blocksize
<td valign=top>int
<td valign=top>Set by the volume clerk; defined by the media type.
<tr>
<td valign=top>remaining_bytes
<td valign=top>64-bit int
<td valign=top>Specified by the user on volume creation; estimate of the number
of bytes that would fit on the media; updated by the volume clerk every time
data are written to the media.
<tr>
<td valign=top>eod_cookie
<td valign=top>string ("none")
<td valign=top>Tells the driver how to space to the end of the volume; it is
driver specific; updated by the volume clerk when data are written on the
media.
<tr>
<td valign=top>wrapper
<td valign=top>string ("cpio")
<td valign=top>Wrapper method; currently specifies the format of the files on
the media.
<tr>
<td valign=top>sum_rd_err
<td valign=top>int (0)
<td valign=top>Read error count; volume clerk updates this field when the mover
receives an error while reading from the media.
<tr>
<td valign=top>sum_rd_access
<td valign=top>int (0)
<td valign=top>Access error count; volume clerk updates this field when the
mover receives an error while accessing the media for read.
<tr>
<td valign=top>sum_wr_err
<td valign=top>int (0)
<td valign=top>Write error count; volume clerk updates this field when the
mover receives an error while writing to the media.
<tr>
<td valign=top>sum_wr_access
<td valign=top>int (0)
<td valign=top>Access error count; volume clerk updates this field when the
mover receives an error while accessing the media for write.
<tr>
<td valign=top>user_inhibit
<td valign=top>string ("none" or "readonly", "all")
<td valign=top>Specified by user at volume creation; access level for this
volume, updated by volume clerk.
<tr>
<td valign=top>system_inhibit
<td valign=top>string ("none" or "writing", "readonly", "full") 
<td valign=top>Enstore generated limitation on the kind of access permitted to
this volume; update by volume clerk when data are written on the media, an
error occurred while data were being written or the file size exceeded the
remaining number of bytes on the media.
<tr>
<td valign=top><b>File Table</b>
<tr>
<td valign=top><b>Column Name</b>
<td valign=top><b>Type</b>
<td valign=top><b>Comments</b>
<tr>
<td valign=top>bfid
<td valign=top>primary key
<td valign=top>bit file id; uniquely identifies every file in the system.
<tr>
<td valign=top>external_label
<td valign=top>string 
<td valign=top>Volume name on which the file has been written; same as the
external_label in the volume table.
<tr>
<td valign=top>bof_space_cookie
<td valign=top>string
<td valign=top>Driver specific string telling how to space to the file on the
media.
<tr>
<td valign=top>complete_crc
<td valign=top>int
<td valign=top>crc of all the bits sent by the user.
<tr>
<td valign=top>sanity_cookie
<td valign=top>string ("(0,0)")
<td valign=top>Number of bytes used for a sanity crc and the sanity crc itself.
</table>

<h3>
5.2 Volume clerk operations
</h3>
The volume clerk supports the following requests:
<ul>
<li>show the name of all the volumes
<li>show volume information
<li>add a volume
<li>delete a volume
<li>find the appropriate volume on which to write the file
<li>change the number of remaining bytes on the volume
<li>set the number of read/write errors
<li>set the current status of the volume
<li>set the volume as readonly
<li>start/stop backup of volume journals
</ul>

<h3>
5.3 File clerk operations
</h3>
The file clerk supports the following requests:
<ul>
<li>show bfid of all the files
<li>show file information
<li>start/stop backup of file journals
</ul>

<h3>
5.4 Summary of MSS RUN II Requirements Impact on the Database
</h3>

<h4>
5.4.1 Table Changes
</h4>

Based on MSS RUN II Requirements the following additional information should
be stored in the database Volume table:

<ul>
<li>location indicator (internal/external/mark for ejection)
<li>access indicator after tape ejection
<li>user/group authorized to access this volume and change the access
permissions
</ul>

And the following additional information should be stored in the File table:

<ul>
<li>name of the file
<li>data of creation/change
<li>location indicator (internal/external)
</ul>

<h4>
5.4.2 Addition to Functionality
</h4>

The volume clerk should provide the following new operations:

<ul>
<li>user should be able to mark the volume as readonly
<li>set the media as external/internal/mark for ejection to the library
<li>set the access indicator for the media marked for ejection
</ul>

The file clerk should provide the following new operations:
<ul>
<li>change the access for files on the media that has been ejected from the
library
</ul>

<h4>
5.4.3 Administrative Tools
</h4>

Administrative tools should provide the following operations:
<ul>
<li>Display the volume for a specified media
<li>List all the files and their location on a single or set of media
<li>List file/files on the media by creation date
<li>List all the media that belongs to a specified file family
<li>List files that belongs to a specified file family
<li>Display the date of the last mount for a specified volume
<li>List all media belonging to a file family sorted by the most recent media
mount date
<li>List all media belonging to a file family where the last access date is
before a specified date
<li>Export meta-data of ejected media into a flat file
<li>Import meta-data from a flat file when importing the media from outside the
Enstore system
<li>List all files/volumes that belong to user/group
<li>Mark the volume as readonly if all of the files on the media are older
than a specified date
</ul>


<h3>
5.5 Current Underlying Database Implemented in Enstore
</h3>

The current Enstore implementation uses LIBTP (BSD DB v2.3) as the underlying
database product.
LIBTP is free for non-profit organizations like Fermilab, and has the
following features:

<ul>
<li>
one key dictionary-like database. It is designed to
store/retrieve binary large objects (BLOBs) of arbitrary length, by text key.
<li>
ability to store data items of unlimited size
<li>
support for various data storage structures: hash table, binary tree,
numbered records
<li>
allows duplicate keys
<li>
data scanning with cursors, multiple cursors may be opened at the same time
<li>
different levels of cursor stability
<li>
transactions
<li>
transaction logging
<li>
check-pointing
<li>
backup and recovery tools
<li>
custom locks
<li>
deadlock detection
</ul>


A LIBTP-Python shelve-like interface was developed. It provides access to:
<ul>
<li>All three data structures: hash table, binary tree, numbered records
<li>Cursors
<li>Transactions
<li>Locks
</ul>

LIBTP was chosen based on the following considerations:

<ul>
<li>
It is similar to dbm-like databases used for the initial Enstore design.
This made it easy to develop a Python interface for it and any necessary
changes to the Enstore code were localized and relatively easy to make.
<li>
It is free
<li>
Database maintenance is relatively inexpensive. It requires only two
processes to run. One for checkpointing and the other for deadlock detection.
<li>
It is simple and fast enough.
<li>
It provides tools for database transaction logging, database backup and
recovery.
</ul>

<h4>
5.5.1 Disadvantages and Options for the Future
</h4>

LIBTP interprets stored data items as unstructured BLOBs, which does not
allow any other way to select data items other then by primary key. Probably, 
this is the most critical limitation for the Enstore
project. Although, it may not be necessary for Enstore's internal needs,
implementation of maintenance functionality is not realistically possible
without having some way to select data by
data attributes instead of the primary database key. There are two possible
ways to solve this problem.
<dl>
<dt>
<b>Implementation of additional indices</b>
<dd>
A database "table" may be accompanied by one or more "index" tables, each of
which would store binary trees of values of particular attributes and refer 
to keys of data stored in the main table.
Implementation of this idea does not seem to be difficult, but it may require
some re-design of the database clients to make them use this feature.
<dt>
<b>Using a relational database product</b>
<dd>
Conceptually, a relational database provides the same level of data access
with respect to any combination  of columns (data attributes) used as the
search key. Data lookup may be further optimized
by creation of additional indices. Such additional optimization can be done
at any time and does not require any modification of the clients provided
the client is designed to use the relational database.
</dl>
<p>
For the Enstore project, switching to a relational database product will
require substantial redesign or even re-engineering from scratch of 
database servers, clients, client-server communication protocol and server 
journal file module because all of these components are designed
based on the assumption that the database interface is compatible with a
Python dictionary interface.
<br><font color=#ff0000>
(The above paraghaph is not quite right. A RDBMS may be hidden behind a
python API nicely. IMHO, the decision is on whether we need the extra
benefit [and complexity] from using a RDBMS, such as writing queries in
relational algebra {multiple select, joints, ... etc.}, and at what
cost we want to pay for it.
If what we want is just a big table with multiple indices,
a RDBMS can be used as such and it would not be difficult to encopreate
that to enstore.
Then, the question is, why do we have to pay for the [much] extra cost?<br>
-- Chih-Hao)
</font>

<h2>
6 Communication Protocols
</h2>
<font color=#ff8800>Protocol and the figures go here</font>
<h2>
7 Error Control
</h2>

Error control in Enstore is simple, because much of the system state
is stored in the <em>encp</em> client. The <em>encp</em> client can be given a
"retry-able error" and will resend data for a write into the system, or the
system can re-start a read from the system from scratch. This re-try
is given a very high priority when it is received by the library
manager -- put on the head of the unassigned work queue.

The Enstore system keeps unassigned read and write requests in a queue of
unallocated work in the library manager. Once a read or write requests'
turn comes, the library manager puts the request in a "work awaiting
mount" or "work at mover" queue. The reason for this is to track the
volumes for scheduling : the library manager must not command a different mover
to mount a tape for another mover. It is the mover, and not the library
manager which completes requests.

The three library manager queues are: 
<ul>
<li>Unscheduled work
<li>work awaiting a volume mount
<li>work at a mover.
</ul>
<p>
It is important to keep these queues consistent. Tape and reading
errors are handled in the mover, and can be handled by detailed design in 
the mover.
<p>
Many interesting errors are related to when the tape cannot be written
or read, or when it is suspected that tape is jammed, etc.
<p>
We need experience with the actual hardware. In the interim we make the 
following assumptions:
<ul>
<li>
If we have trouble during a load or unload operation, we assume that
the tape is physically jammed. Until a human looks at the problem, we
will permit no future operations on the drive or the volume.
<li>
If we have errors on writing a volume, we will not write on that
volume anymore.
<li>
If a tape drive has errors on "consecutive" tapes, we should "stop
using the tape drive". The number of errors allowed should be picked
up through the mover configuration, since we may have "more
temperamental" and "less temperamental" drives, we may want to
configure this parameter for each mover individually. 
<li>
If tape reads or spaces give error, we should track the errors. If
the recent history of the tape shows many errors, we should mark the
tape "no access" and bring it to the attention of an administrator.
Therefore, the Volume Clerk needs to track the "recent history" of
errors, and have a per-volume figure of merit which will mark the tape
for no access, given many recent errors.
<li>
Library manager:
<br>
Two Features should be added to the tickets to support re-tries. 
<ul>
<li>Tickets should be marked as retries or not by <em>encp</em>. Retries go 
to the head of the queue.
<li>Tickets should be marked with an "avoid this mover" field for read
retries, so the same tape drive can be avoided.
</ul>
<em>encp</em> should generate these fields appropriately, and the queuing logic
in the library manager ought to implement the logic associated with these
fields.
<p>
The Enstore system should check the read/write state of a tape read very
early when the request is queued, to give an error if the access
is not allowed. However, an error may change the state of a tape while
its corresponding work is in the library manager queue. Therefore, a
late check is required. The system already performs a "late check"
for writes, since a volume must be selected for every file. The system
needs a "late check" for reads. Failing a late check means contacting
<em>encp</em> to give it the bad news. The contact should be done in the mover,
not in the library manager, just before the mover goes off to mount the volume
for read, since the mover is better able to tolerate a very slow or
non-existent <em>encp</em>. It is good to contact 
<em>encp</em> before a mount, too, since people <em><b>will</b></em> ^C <em>encp</em>'s and
it is best to discover this <em><b>before</b></em> incurring the expense of a mount.
<li>
"Freeze the tape in the drive" means:
<ul>
<li>Not unloading the tape from the drive
<li>Freezing the tape
<li>Off-lining the Drive
</ul>
<li>
"Freezing the tape" means:
<ul>
<li>mark the tape as "system noaccess"
<li>log that this happened and let an administrator look at the
problem in the morning.
<li><em>encp</em> shall not re-try.
</ul>
<li>
"Off-lining the drive" means:
<ul>
<li>Preserving as much state as possible.
<li>Writing a complete description in an error log.
<li>Leaving the problem until business hours unless the capacity of
the system falls below a threshold.
</ul>
</ul>

<table>
<th>Tape Write Errors
<tr>
<td valign=top><b>WRITE_NOTAPE</b>
<td valign=top>"no such tape" error in library mount failure on write.
    If this happens, the volume data base is inconsistent with reality.
    Mover shall freeze the tape.
    <em>encp</em> shall retry.
<tr>
<td valign=top><b>WRITE_TAPEBUSY</b>
<td valign=top>"The media changer says that the tape is in another drive"
    Enstore has a bug, or some other system has mounted the tape or
    library micro put the tape somewhere else.
    Mover shall freeze the tape.
    <em>encp</em> shall retry.
<tr>
<td valign=top><b>WRITE_BADMOUNT</b>
<td valign=top>Other mount failure on write, or load operation failed.
    Must assume jammed tape.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall re-try
<tr>
<td valign=top><b>WRITE_BADSPACE</b>
<td valign=top>"EOD cookie does not produce EOD"
    Wrong tape, software bug or drive space error.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall retry.
<tr>
<td valign=top><b>WRITE_ERROR</b>
<td valign=top>"Error when writing data block or file mark"
    Run of the mill write error.
    If the drive has had many recent errors, mover shall
    "offline the drive"
    The volume shall be marked read-only.
    <em>encp</em> shall re-try.
<tr>
<td valign=top><b>WRITE_EOT</b>
<td valign=top>"Hit EOT while writing data block or file mark"
    Hit EOT. Mover shall mark volume full.
    <em>encp</em> shall retry. 
<tr>
<td valign=top><b>WRITE_UNLOAD</b>
<td valign=top>"error when unloading tape from drive"
    Must assume that the tape is physically jammed.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall retry.
    No <em>encp</em> is associated with the tape at this time.
<tr>
<td valign=top><b>WRITE_UNMOUNT</b>
<td valign=top>"Media changer gives error when unmounting tape"
    Should not happen. Maybe the tape is hanging in the drive. Does no harm.
    Mover shall freeze the tape in the drive.
    No <em>encp</em> is associated with the tape at this time.
<tr>
<td valign=top><b>WRITE_NOBLANKS</b>
<td valign=top>The volume clerk has no blank volumes to give.
    The requests shall return an error. 
    (do not "wait forever" -- DAQ should switch to an alternate library)
    An administrator shall be paged.
<tr>
<th>Tape Read Errors
<tr>
<td valign=top><b>READ_NOTAPE</b>
<td valign=top>"No such tape in library" mount failure on read.
    If this happens, the volume data base is inconsistent with reality.
    Mover shall freeze the tape.
<tr>
<td valign=top><b>READ_TAPE_BUSY</b>
<td valign=top>"The media changer says that the tape is in another drive"
    Enstore has a bug, or some other system has mounted the tape or
    the library micro put the tape somewhere else.
    Mover shall freeze the tape.
    <font color=#ff0000><blink>What is a "library micro"?</blink></font>
<tr>
<td valign=top><b>READ_BADMOUNT</b>
<td valign=top>Other Mount failure on read, or load operation failed.
    We have to assume that the tape is jammed in the drive.
    Mover shall freeze the tape in the drive.
<tr>
<td valign=top><b>READ_BADLOCATE</b>
<td valign=top>Failed space or initial CRC's don't match on initial read.
    We have attempted to space to a file on the tape. Either the file location
    cookie is somehow corrupted, we have the wrong tape in the drive or
    the tape drive cannot space properly. 
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry
<tr>
<td valign=top><b>READ_ERROR</b>
<td valign=top>Error when reading data block.
    Run of the mill read error.
    Mover shall consider the recent error history of the drive and the volume.
    If the drive has had many recent errors, mover shall offline the drive.
    <em>encp</em> shall re-try.
    If the volume has had many recent errors, mover shall freeze the tape.
    <em>encp</em> shall not retry.
    If the volume has had few recent errors,
    mover shall fail the transfer,
    <em>encp</em> shall re-try, and annotate that this mover shall be avoided.
<tr>
<td valign=top><b>READ_COMP_CRC</b>
<td valign=top>Failure of complete CRC.
    This needs investigating, as it should not happen. The drive and the tape
    are suspicious. Corrupt file location cookie, drive space error, wrong tape
    in the drive, etc.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry.
<tr>
<td valign=top><b>READ_EOT</b>
<td valign=top>Hit EOT when reading.
    Should not happen. Corrupt file location cookie, drive space error, or
    wrong tape in the drive. Should have hit an EOF.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry.
<tr>
<td valign=top><b>READ_EOD</b>
<td valign=top>Hit EOD when reading.
    Should not happen. Corrupt file location cookie, drive space error, or
    wrong tape in the drive. Should have hit an EOF.
    Mover shall freeze the tape in the drive.
    <em>encp</em> shall not retry.
<tr>
<td valign=top><b>READ_UNLOAD</b>
<td valign=top>Error when unloading tape.
    Must assume that the tape is physically jammed.
    Mover shall freeze the tape in the drive.
    No <em>encp</em> is associated with the tape at this time.
<tr>
<td valign=top><b>READ_UNMOUNT</b>
<td valign=top>Error from media changer when unloading tape.
    Should not happen. Maybe the tape is hanging in the drive. Does no harm.
    Mover shall freeze the tape in the drive.
    No <em>encp</em> is associated with the tape at this time
<tr>
<th>Other Errors
<tr>
<td valign=top><b>ENCP_GONE</b>
<td valign=top><em>encp</em> has gone away while request is queued.
    The mover contacts <em>encp</em> to ping it before a mount, and if 
    <em>encp</em> is not there, the mover does not go on to contact the media 
    changer, but instead returns a UNILATERAL_UNBIND to the library manager.
<tr>
<td valign=top><b>TCP_HUNG</b>
<td valign=top>DESY reports that 
<ul>
<li>sometimes machines can crash....
<li><em>encp</em> processes can be killed in a way that...
<li><em>encp</em> client's disks many fill up ...
<li>etc...
</ul>
which are all seen as the data TCP link is seen to
just hang. 
<p>
DESY's treatment is "harsh" -- They compute an anticipated transfer
time for every socket operation and abort the transfer if the
actual transfer takes more than several times the expected value.
Right now, Enstore does not consider this to be an error and just
waits. However, we are vulnerable to disaster. It is possible to see
circumstances where we might tie all the movers up if, say, one clients
system's disk fills up.
<tr>
<td valign=top><b>LM_CRASH</b>
<td valign=top>If a library manager crashes, and loses its queue of pending work,
    the <em>encp</em>'s will never be called back, and will wait
    forever.
    This is a problem. A basis for the solution is for a waiting 
    <em>encp</em> to ping its library manager,
    every 30 mins to see if its request has gotten lost.
    It would also be good if a --timeout switch was available to
    <em>encp</em>,
    since the users may wish to get an error rather than suffer a long
    delay.
<tr>
<td valign=top><b>MOVER_CRASH</b>
<td valign=top>
Case 1) If a mover is connected to an <em>encp</em>, then <em>encp</em> will
notice its sockets being torn down prematurely. <em>encp</em> shall retry. This
is not good enough.
<p>
For reads, the volume is tied up because the library manager has the volume as
being "at a mover". The retry will be hung in the library manager queue
because the library manager is unaware of the mover crash.
<p>
For writes, 1 is effectively deducted from the file family width,
since the library manager is unaware of the mover crash.
<p>
This is all a bug, the minimal effect of a mover crash should be:
<ul>
<li>
Since the status of the volume is unknown, the status should be akin
to "freeze drive and volume". However, subsequent reads will not produce an
error, but will be queued until the mover is restarted.
<li>
Allow writes to continue on a different volume of the same file 
family, without affecting the "width".
</ul>
<p>
Case 2) Mover has a volume, but is not associated with an <em>encp</em> and 
crashes.
Same problems as case 1) but <em>encp</em> will notice.
The total amount of time spent in this possibility is small compared to
the time corresponding to case 1 and case 3.
<p>
Case 3) Mover is idle.
This is O.K. The system degrades as specified.
</table>
<h2>
8 Concluding Remarks
</h2>
<p>
<font color=#ff0000><blink>Not done yet below this line</blink></font>
<hr>
</body>
