<body BGCOLOR=#FFFFFF>
<font size=7><b><i>
<center>Enstore Technical Design Document</center>
</i></b></font>
<br><p>
<center>Joint Projects Document JP0026</center>
<br><p>
<center>$Revision$</center>
<center>$Date$GMT</center>
<br><p>
<br><p>

<center>Jon Bakken</center>
<center>Eileen Berman</center>
<center>Chih-Hao Huang</center>
<center>Alexander Moibenko</center>
<center>Don Petravick</center>
<center>Ron Rechenmacher</center>
<center>Kurt Ruthmansdorfer</center>
<br><p>
<br><p>
<br><p>
<font size=+1><b>Table of Contents</b></font>
<ul>
<li><a href="#overview">1 Enstore Architecture</a>
<li><a href="#scope">1.0.1 Scope and Overview</a>
<li><a href="#assum">1.0.2 Assumptions and Constraints</a>
<li><a href="#aintro">1.0.3 Components</a>
<li><a href="#pnfs">1.1 The DESY <em>pnfs</em> Namespace</a>
<li><a href="#ptests">1.1.1 <em>Pnfs</em> Tests</a>
<li><a href="#pserver">1.1.2 <em>Pnfs</em> Server Installation</a>
<li><a href="#pclient">1.1.3 <em>Pnfs</em> Client Installation</a>
<li><a href="#pcmd">1.1.4 pcmd: Enstore related <em>pnfs</em> commands</a>
<li><a href="#volmaps">1.1.5 <em>Pnfs</em> Volume Maps</a>
<li><a href="#encp">1.2 <em>Encp</em></a></li>
<li><a href="#encp_options">1.2.1 <em>Encp</em> command line options</a></li>
<li><a href="#encp_throttle">1.2.2 Throttling in <em>encp</em></a></li>
<li><a href="#encp_ist_from hsm">1.2.3 Specifying lists of files when reading from or writing to the HSM</a>
<li><a href="#encp_queue">1.2.4 <em>Encp</em> Transfer Lists</a>
<li><a href="#encp_errors">1.2.5 <em>Encp</em> Return Status</a>
<li><a href="#encp_client">1.2.6 <em>Encp</em> Client Installation</a>
<li><a href="#servers">1.3.0 Enstore Servers</a>
<li><a href="#servers_cmds">1.3.0.1 General Command Line Control of Servers</a>
<li><a href="#volume_clerk">1.3.1 Volume Clerk</a>
<li><a href="#volume_clerk_cmds">1.3.1.1 Command Line Control of the Volume Clerk</a>
<li><a href="#file_clerk">1.3.2 File Clerk</a>
<li><a href="#file_clerk_cmds">1.3.2.1 Command Line Control of the File Clerk</a>
<li><a href="#library_manager">1.3.3 Library Manager</a>
<li><a href="#user_request">1.3.3.1 Users' Requests</a>
<li><a href="#mover_request">1.3.3.2 Movers' Requests</a>
<li><a href="#lm_commands">1.3.3.3 Library Manager Commands</a>
<li><a href="#mover">1.3.4 Mover</a>
<li><a href="#mover_cmds">1.3.4.1 Command Line Control of the Mover</a>
<li><a href="#mover_config">1.3.4.2 Mover Config File Values</a>
<li><a href="#config_server">1.3.5 Configuration Server</a>
<li><a href="#config_server_cmds">1.3.5.1 Command Line Control of the Configuration Server</a>
<li><a href="#log_server">1.3.6 Log Server</a>
<li><a href="#media_changer">1.3.7 Media Changer</a>
<li><a href="#inquisitor">1.3.8 Inquisitor</a>
<li><a href="#inquisitor_cmds">1.3.8.1 Command Line Control of the Inquisitor</a>
<li><a href="#inquisitor_config">1.3.8.2 Inquisitor Config File Values</a>
<li><a href="#inquisitor_outputs">1.3.8.3 Example Inquisitor Reports</a>
<li><a href="#inquisitor_ascii_status">1.3.8.3.1 Example Ascii Status File</a>
<li><a href="#inquisitor_html_status">1.3.8.3.2 Example Html Status Snapshot File</a>
<li><a href="#inquisitor_encp_status">1.3.8.3.3 Example <em>Encp</em> History Snapshot File</a>
<li><a href="#inquisitor_plot_ita">1.3.8.3.4 Example Individual Transfer Activity Plot</a>
<li><a href="#inquisitor_plot_btd">1.3.8.3.5 Example Bytes Transferred/Day Plot</a>
<li><a href="#alarm_server">1.3.9 Alarm Server</a>
<li><a href="#alarm_server_cmds">1.3.9.1 Command Line Control of the Alarm Server</a>
<li><a href="#alarm_server">1.3.9.2 Alarm Server Config File Values</a>
<li><a href="#alarm_server">1.3.9.3 Ascii Alarm File</a>
<li><a href="#alarm_server">1.3.9.4 Patrol Alarm File</a>
<li><a href="#server_protocols">1.4 Server Protocols</a>
<li><a href="#trace">1.5 Trace</a>
<li><a href="#db">2 Databases in Enstore</a>
<li><a href="#current_db">2.1 Current Underlying Database Implemented in Enstore</a>
<li><a href="#backup_recovery">2.2 Backup and Recovery Procedures</a>
<li><a href="#backup">2.2.1 Backup </a>
<li><a href="#recovery">2.2.2 Recovery</a>
<li><a href="#admin_tools">2.3 Administrative Tools</a>
<li><a href="#protocol">3 Communication Protocols</a>
<li><a href="#read_protocol">3.1 Read Protocol</a>
<li><a href="#write_protocol">3.2 Write Protocol</a>
<li><a href="#error">4 Error Control</a>
<li><a href="#eass">4.1 Assumptions about Errors</a>
<li><a href="#eover">4.2 Error Overview</a>
<li><a href="#edet">4.3 Detailed Error Discussion</a>
<li><a href="#impexp">5 Volume Import and Export</a>
<li><a href="#volexp">5.1 Volume Export</a>
<li><a href="#volimp">5.2 Volume Import</a>
<li><a href="#test_system">6 Test System</a>
<li><a href="#ts_results">6.1 Test System Results</a>
<li><a href="#interface">7 Interfaces and Integration</a>
<li><a href="#d0req">8 D0 Requirements</a>
<li><a href="#d0reqa">8.1 Summary of D0 Functional Specifications</a>
<li><a href="#d0reqb">8.2 Sam/Enstore Interface Notes</a>
<li><a href="#d0req3">8.3 Other D0, non-SAM Requeststo Enstore</a>
<li><a href="#manp">9 WBS and Effort Estimates</a>
<li><a href="#manp">10 Year 2000 Issues</a>

</ul>

<p>
<hr>
<h2><a name="overview">
1 Enstore Architecture
</h2>
Enstore provides a generic interface for experimenters to
efficiently use mass storage systems as easily as if they were native file
systems.
<p>
<center><img src="enstore_at_fnal2.gif"></center>
<p>
<div align=right><a href="enstore_at_fnal2.ps">(also available in Postscript)</a><div align=left>
<p>

<h3><a name="scope">
1.0.1 Scope and Overview
</h3>


Enstore provides distributed access to, and management of, petabytes of data
stored on tape. The data can be made of up to billions of files of varying
sizes - typically of between 1 and 2 Gigabytes in size. At any time, many of
the tapes are accessible through automated tape libraries. The system supports
migration of tapes to and from shelves - export and import - where operator
intervention is required to move the tapes between the shelves and roboticly
accessible tape drives. The system treats robot's shelves as a scarce
commodity.
Enstore is a system to provide mass storage for large Run II data sets.  As
such it is not a general purpose mass storage system, but optimized to
allow access to large datasets made of many files.  The system supports
random access of files, but also streaming, the sequential access of
successive files on tape. 
<p>

The Enstore system provides for access to the data by user/client applications
which are distributed across an IP network. It supports tape
drives attached locally to the users' computer, as well as those
remotely accessible over the network.
<p>

The Enstore system provides resource management of the available tape drives
such that, for example, logging of data from the data acquisition systems can
be given guaranteed access to the tape bandwidth whatever other user accesses
are being requested.
Enstore is designed to be used by Fermilab experiments' data acquisition, data
processing and analysis systems. Well defined interfaces will be provided to
these data handling systems to allow them to easily use the services provided.
The writing and reading of tapes
must therefore be reliable and efficient, and the system must be robust
enough to support this critical application without compromising data
taking.  Enstore's goal is to provide a system that can be extended as
needed for the experiments actual data taking needs, as well as be easily
maintainable for the duration of several data taking runs.
<p>

Enstore is based on a client-server model that allows hot swapping of
hardware components and dynamic software configuration, is platform
independent, runs on heterogeneous environments and is easily extendable.
Most of the operations are transparent to the user.  System performance is
monitored and fine tunable.  A great deal of care has been taken to ensure
that it is able to prevent or to recover from a worst case scenario.  The
system has layers around it to customize and address problems as they
occur.  When possible, these layers are expected to use already existing
components (e.g. FTT, <em>pnfs</em>).
<p>

The Enstore system is designed to provide for the needed Run II data access
throughput requirements within the budget assigned.
The system software is layered and accessible to
the Run II developers such that needed modifications can be made in a timely
manner to meet the needs of commissioning and running of the Run II detectors.
<p>

Enstore is designed to support "lights out" operation of the Run II
automated tape library systems. To this end, the design is targeted
towards requiring operator intervention at no more than 8 hour
intervals - for example, import/export requests are queued and need only be
handled within the daytime operator shifts. Careful attention
is paid to error reporting, handling and recovery in order to
require the minimal possible load on the operations and support staff.
<p>


To summarize, Enstore provides the following features:

<menu>

  <li>Support for several types of serial media accessed through Automated
       Tape Libraries or locally mounted on the client or host computers.

  <li>Support for distributed access to data on these tapes.

  <li>Reliable, efficient and prioritized write access from the experiment
       data acquisition systems for the logging of raw data.

  <li>Optimized access to large (petabyte) datasets made up of many (100s of
       millions of) files of 1-2 GB in size.

  <li>Efficient and flexible support for "write streaming" of data to tape,
       where data is physically clustered on tapes according to a simple
       classification scheme - typically the trigger number associated with
       the event data written.

  <li>Management of hardware and software resources, e.g., a limited number
       of available tape drives to allow prioritized access to the data.

  <li>Swapping of hardware components - tapes, tape drives, and computers -
       without bringing down the complete system.

  <li>Complete error reporting and configurable response to error
       conditions.

  <li>The use of already tested components as far as possible.

  <li>Easy mechanisms for testing of the system.

  <li>Import and export of tapes between the Automated Tape Library(ies)
       and shelf storage without bringing down the complete system.

  <li>Support for distributed clients to access data through standard
       network protocols, and to a great extent transparently.

  <li>Sequential access of data in files, for event reconstruction and
       other large data processing requirements.

  <li>Random access to files on tapes, to support general event analysis.

</menu>

D0, and most specifically, SAM, has been very helpful in setting the
direction for what is needed from Enstore.  We believe a close and working
collaboration has been developed in which both SAM and Enstore have
profited. We appreciate the early, and sometimes tedious and painful,
testing the SAM group has done on Enstore.
<p>

We have been working with D0 to try provide a storage system that fulfills
their needs. We have chosen to first present what Enstore provides and then
what <a href="#d0req"> D0 requires</a> and describe how Enstore fulfills
it. This ordering could have been reversed - there has been great synergy
between the two efforts.


<h3><a name="assum">
1.0.2 Assumptions and Constraints
</h3>

A constraint is a factor that limits our implementations.
Assumptions are factors that, for planning purposes, will be considered to be
true, real, or certain.

<menu>

<LI> A usable system must be available in time for vertical slice tests
     in June, 1999.

<LI> The system must be apropos for Run II use, and have a place in the
     overall storage strategy for the laboratory.

<LI> Binaries should be distributed to the users. We should not expect users
     to have to deploy a large infrastructure on their computers to use Enstore.

<LI> The DESY name space is usable for Enstore, available to FNAL, and usable
     for Run II sized applications.

<LI> Fermilab FTT, a platform-independent SCSI tape package is suitable for
     the selected hardware, and useful over Run II projects.

<li> OCS will be available and usable for operator mounts.

<li> OCS will be available and usable as the repository of the tape and
     drive statistics.  Enstore, itself will not store long term statistics.
    

<LI> Tape drives may be attached to user's computers via IP, and an adequate
     IP based network is constructed for Run II.

<LI> A non-transparent FMSS-like interface is
     appropriate for the users.

<li> Python is an appropriate choice for implementing the project.  Loadable C
     modules will be used where appropriate, for example, to increase
     performance.

<li> Enstore does not yet support a disk cache or buffer in front of the media.
     However, one is conceivable and planned for a future release.
<p>
</menu>



<h3><a name="aintro">
1.0.3 Components
</h3>


Enstore uses a client-server architecture to provide a generic interface for users
to efficiently use mass storage systems.
Enstore supports multiple distributed media robots,
each of which may handle multiple media types or individual directly attached
drives, and multiple distributed mover nodes.
The system architecture does not dictate an exact hardware architecture.
Rather, it specifies a set of general and generic networked hardware
and software components.
These components are loosely coupled in the sense that each one can be
replaced easily without affecting the rest of the system and
each class of components can be easily expanded to accommodate
the increased demand in performance or capacity.
<p>
The system is written in <em>python</em>, a scripting
language that has advanced object-oriented features.
Python provides a sound environment for quick turn-around
and a seamless integration/migration path to
fully compiled languages, such as C and C++, if there is a demand
for even better performance.
<p>
Enstore has four major kinds of software components:
<ul>
<li><em>namespace</em>, implemented by the <em>pnfs</em> package from
        <em>DESY</em>
<li><em>encp</em>, a program used to copy files to and from media libraries
<li><em>servers</em>
        <ul>
        <li>Configuration Server
        <li>Volume Clerk
        <li>File Clerk
        <li>Multiple, distributed Library Managers
        <li>Multiple, distributed Movers
        <li>Media Changer (1 per Library Manager)
        <li>Log Server
        <li>Inquisitor
        <li>Alarm Server
        </ul>
<li><em>administration tools</em>
</ul>
The planned implementation is to have one Media changer serving a physical
library.  The Media Changer would accept commands, fork and send the request to
the physical library.  Single Media Changers allow a central place to:
<ul>
<li>balance the requests between each robot arm
<li>limit the number of requests (EMASS has a queue limit)
<li>pause arm activity to allow import/eject functions to occur
</ul>
<p>
These software components, as well as hardware components,
are shown schematically in the following system context diagram.
Hardware components are connected via IP.
Great care has been taken to ensure that the system will function well
under extreme load conditions.
By design, there is no preset limit on the number of concurrent user
computers nor on the number of physical media libraries or drives.
The system is only limited by the availability of physical resources.
We control all of the source code for the system except for that of
<em>pnfs</em> (which is a well supported product from DESY).
<p>
<center><img src="enstoreSimple.gif"></center>
<p>
<div align=right><a href="enstoreSimple.ps">(also available in Postscript)</a><div align=left>
<p>
Like <em>tcp</em>, the system is architected with distributed and
peer-to-peer reliability.
Each request originating from the <em>encp</em> program is branded
with a unique ID.
<em>Encp</em> retries under well-defined circumstances, issuing
an equivalent request with a new unique ID.
The system can instruct <em>encp</em> to retry if it needs to back out
of an operation.

<hr>
<h2><a name="pnfs">
1.1 The DESY <em>pnfs</em> Namespace
</h2>

<em>Pnfs</em> is a DESY written and supported package.  Detailed
information about <em>pnfs</em> can be found on the DESY
<a href=http://mufasa.desy.de/pnfs/Welcome.html>http://mufasa.desy.de/pnfs/Welcome.html</a>
and
<a href=http://watphrakeo.desy.de/pnfs/>http://watphrakeo.desy.de/pnfs/</a>
web pages. The <em>pnfs</em> servers can not be installed without the permission of DESY.
However, DESY has provided permission to Fermilab to use <em>pnfs</em> for 
Enstore work and support of the product has been superb.
<p>
The DESY <em>pnfs</em> package  implements an <em>nfs-v2</em> daemon and mount daemon.
These daemons do not actually serve a file system, but, instead make a
collection of database entries looks like a file system, and provide
control information for the system. Each file that is created in <em>pnfs</em> has 8
layers that Enstore uses to store metadata information about the file transfers.
Normal UNIX permissions and administered export points
are used to prevent unauthorized access to the name space.
<p>
To inspect files, users mount their portion of the <em>pnfs</em> file
system on their own computers,
and interact with it using the native operating system utilities.
For example, users can <em>ls</em>, <em>stat</em>,
<em>mv</em>, <em>rm</em> or <em>touch</em> existing "files",
but are given errors on attempts to read
or write the content of the files.
Users can also <em>mkdir</em> and <em>rmdir</em>, and <em>ln</em> files. Hard links should be used to ensure all
the metadata information is linked; symbolic links will not give the user what he naively expects.
<p>
There are also some special <em>pnfs</em> files which act as normal UNIX
files. Administrators can write data to these files and the users can read
from them.  These files are the exception rather than the rule.  Enstore
plans on using them to distribute service information that everyone, who
has <em>pnfs</em> mounted, can read.  <p>
Enstore uses <em>pnfs</em> for three different kinds of access and information:
<ol>
<li>Administration Interactions
    <br>
    An administrator can create special files, called wormholes, in the <em>pnfs</em> name space.
    For example, one special file signifies that the system needs to be
    drained (maybe due to an impending shutdown). Existence of this file
    causes <em>encp</em> to stall,
    preventing users from submitting additional jobs and thus draining the Enstore system of transfers.
    The name of the Enstore-draining wormhole file is "local-pnfs-mountpoint/.(config)(flags)/disabled".
    Additional wormholes can be created as needed.
    <p>
<li>Configuration Information
    <br>
    Some creation details
    need to be provided before the user can write files to media. Enstore uses <em>pnfs</em> tag files
    (usually just called tags)for these purposes.
    Tags are
    associated with a directory and not any specific file.
    Examples of configuration information that is specified with tags include the file family name, file
    family width, and Library Manager. There is also optional file family wrapper tag, specifying a type of file wrappers for given file family. If this tag is not set the default wrapper type 'cpio_custom' will be used. This is a wrapper initially used in the Enstore project.
     <p>
<li>User File information
    <br>
    The rest of the system identifies a file by a 64-bit numeric
    identifier, dubbed a "bit file ID".
    After a file is written, the File Clerk generates a bfid and
    <em>encp</em> stores this information
    in one of the <em>pnfs</em> file layers.
    <em>Encp</em> then reads this bit file ID and gives it to the Enstore servers
    when fetching data.
    Other <em>encp</em> file transfer details, such as time of last access or location of
    where the file was copied to or transfer rates, are stored in a different
    metadata layers of the same <em>pnfs</em> file.
</ol>

<h3><a name="ptests">
1.1.2 <em>Pnfs</em> Tests
</h3>
<em>Pnfs</em> was tested in the prototype with very good results. The code was run
on a 200 MHz Pentium Pro Linux machine with SCSI disks.  The <em>pnfs</em> code had
not been run extensively on Linux machines before and there were a few minor
glitches found during initial running. Support from DESY was outstanding
and all problems were solved quickly.  The Fermilab installation was the first on
Linux platforms.  DESY supports <em>pnfs</em> on all major platforms.

As a test of <em>pnfs'</em> capabilities, the February 1998 set of 250K HPSS filenames
were put into <em>pnfs</em>. Approximately 20 <em>pnfs</em> databases were used for this
test, with each database corresponding to existing HPSS "experimental"
separation. [That is, D0 had its own database, SDSS had its own, and so
forth.] Name lookup was done on each database simultaneously from 3
machines (IRIX, Linux, and AIX) for several days.  <em>Pnfs</em> performed
flawlessly and was able to provide names at a rate of 3-15 names/sec. The
database can be further optimized, but this performance is already adequate
for Enstore.
<p>
*** These tests will have to be repeated *** under the final hardware configuration,
but there is no indication of any problems.

<h3><a name="pserver">
1.1.2 <em>Pnfs</em> Server Installation
</h3>

<em>Pnfs</em> Server installation should be done by an experienced administrator. It
is not something that a user should ever have to do.
Further, permission to install <em>pnfs</em> must be granted by 
DESY.

DESY has granted Enstore permission to fully use, but not change, its
<em>pnfs</em> package at Fermilab.  DESY has also granted Enstore the right
to distribute a binary + necessary scripts version of <em>pnfs</em>
(<it>i.e.</it>, no source code) via the normal Fermilab UPD product
distribution mechanism. For example, the current (Jan 99) version in UPD is
<pre>$ upd list pnfs

DATABASE=/ftp/upsdb
        Product=pnfs    Version=v3_1_3a-f4      Flavor=Linux+2
                Qualifiers=""   Chain=current

</pre>

The UPD version can be decoded as follows: "v3_1_3a" is the DESY version of
<em>pnfs</em>, and the "-f4" signifies the 4th Fermi "release". None of the
DESY code is modified - Fermilab only adds its UPS packaging framework and
some local installation instructions. All fixes, changes, or updates to
<em>pnfs</em>, will always come from DESY.  DESY has allowed Fermilab full access
to the <em>pnfs</em> source code, and as such, we could, in principle, solve
problems if DESY were unable to continue their support.

It is expected that there will be only a few <em>pnfs</em> servers at
Fermilab. To date, <em>pnfs</em> servers have been installed on 3 Linux
nodes without any difficulty. Each time, a set of installation instructions
has been improved; however the <em>pnfs</em> server installation is still
not completely automatic.  The Fermilab installation instructions are
distributed along with the UPD product.

On the node that is serving <em>pnfs</em>, <em>pnfs</em> takes over the normal
function of exporting nfs.  Otherwise the machine is general
purpose.  To be explicit, the only 2 processes <em>pnfs</em> server machine can not
run are rpc.mountd and rpc.nfsd. It runs the <em>pnfs</em> versions of these
instead. These processes are only concerned with exporting <em>pnfs</em>.
For example, Rip6 is the current (Jan 99) Enstore <em>pnfs</em> server. Here is its /etc/fstab
<pre>
rip6$ cat /etc/fstab
/dev/sda6               /                       ext2    defaults        1 1
/dev/sda5               swap                    swap    defaults        0 0
/dev/sdc1               /rip6a                  ext2    defaults,grpid  2 1
/dev/fd0                /mnt/floppy             ext2    noauto          0 0
none                    /proc                   proc    defaults        0 0
rip8:/fnal              /fnal                   nfs     soft,rsize=8192,wsize=8192      0 0
rip8:/home              /home                   nfs     soft,rsize=8192,wsize=8192      0 0
rip8:/usr/local         /usr/local              nfs     soft,rsize=8192,wsize=8192      0 0
localhost:/fs           /pnfs/fs                nfs     noauto,intr,bg,hard,rw,noac       0 0
rip6:/grau-ait          /pnfs/grau/ait          nfs     noauto,user,intr,bg,hard,rw,noac 0 0
rip6:/grau-dlt          /pnfs/grau/dlt          nfs     noauto,user,intr,bg,hard,rw,noac 0 0
rip6:/grau-mammoth      /pnfs/grau/mammoth      nfs     noauto,user,intr,bg,hard,rw,noac 0 0
rip6:/stk-red20         /pnfs/stk/red20         nfs     noauto,user,intr,bg,hard,rw,noac 0 0
rip6:/stk-red50         /pnfs/stk/red50         nfs     noauto,user,intr,bg,hard,rw,noac 0 0
rip6:/rip6disk1         /pnfs/rip6              nfs     noauto,user,intr,bg,hard,rw,noac 0 0
</pre>
<p>
As you can see, rip6 is nfs mounting 3 disks from rip8 and mounting the
<em>pnfs</em> disks it is exporting as well as the local disks.
There are also numerous Enstore processes running on rip6, for example:
<pre>
USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND
bakken    3280  0.0  7.3 20240  9448  ?  S    00:17   0:14 python /home/bakken/enstore/src/configuration_server.py
bakken    3334  0.0  4.9 20112  6356  ?  S    00:17   0:01 python /home/bakken/enstore/src/log_server.py
bakken    3366  0.0  5.7 37980  7352  ?  S    00:17   0:02 python /home/bakken/enstore/src/volume_clerk.py
bakken    3398  0.0  5.3 37760  6832  ?  S    00:17   0:01 python /home/bakken/enstore/src/file_clerk.py
bakken    3433  0.0  5.1 36472  6560  ?  S    00:17   0:00 python /home/bakken/enstore/src/media_changer.py
bakken    3465  0.0  8.8 33456 11300  ?  S    00:17   0:01 python /home/bakken/enstore/src/mover.new.py
bakken    3515  0.0  0.3  1140   492  ?  S    00:18   0:00 db_checkpoint -h
bakken    3520  0.0  0.3  1612   420  ?  S    00:18   0:00 db_deadlock -h
bakken    3523  0.0  5.3 30508  6808  ?  S    00:18   0:01 python /home/bakken/enstore/src/alarm_server.py
bakken    3673  0.0  8.1 36760 10432  ?  S    00:20   0:34 python /home/bakken/enstore/src/inquisitor.py
bakken   12178  0.0  0.8  1552  1048  p2 S    19:38   0:00 /bin/login -h willow fnal.gov -p bakken
</pre>
<p>
The main point, often confused, is that the <em>pnfs</em> server node
remains a general purpose and usable machine.
<p>
Permission to mount the <em>pnfs</em> namespace is granted using a
mechanism similar to the normal Unix nfs export permission scheme.  There
are DESY commands (the pmount command) that make this entire process very
simple.
<p>
<em>Pnfs</em> can be started automatically on boot-up. This allows other nodes to
easily mount the namespaces after reboots.
<p>
Finally, it should be noted that a Run II <em>pnfs</em> server will need 
a SCSI RAID level 5 disk system for its databases.  RAID level 5 is needed for
redundancy and reliability.  This is the system that DESY uses for their 
<em>pnfs</em> system.
<p>
*** Live Backups of database and recovery procedures *** - to be discussed during March trip to
DESY. This has not been a priority yet.

<h3><a name="pclient">
1.1.3 <em>Pnfs</em> Client Installation
</h3>

No <em>pnfs</em> client software is needed -- the <em>pnfs</em> file system
(really namespace) just has to be mounted!  Enstore has been written such
that it recognizes all of <em>pnfs</em> namespace if it has a local mounting
point beginning with /pnfs/... . Enstore uses /pnfs as convenient key.

Typical steps for mounting a new <em>pnfs</em> namespace (in this example
the <em>pnfs</em> namespace is called "grau-ait" and it is served from the
rip6 node) are:

<ol>
  <li> As root, mkdir -p /pnfs/grau/ait
  <li> As root, append to /etc/fstab:
       <pre>rip6:/grau-ait /pnfs/grau/ait nfs user,intr,bg,hard,rw,noac 0 0</pre>
       The "intr,bg,hard,rw,noac" mount options should not be changed as they are needed for proper operation.
  <li> mount /pnfs/grau/ait This can be done as a normal user if the "user" mount option
       is specified in the /etc/fstab file.
</ol>
Of course, the actual steps depend on the <em>pnfs</em> installation.
<p>

<em>Pnfs</em> filesystems in any way that other NFS filesystems can be mounted:
<ul>
  <li> Explicit mount commands via root
  <li> User mount commands if <em>pnfs</em> entries in in fstab have the option "user"
  <li> Automounting of needed filesystems
</ul>
<p>

<em>Pnfs</em> supports automounting as one would expect.  There is a
general problem with automounting that the <em>pnfs</em> mountpoints
exacerbate: automouting works fine if the mountpoint is only 1 level deep -
but if one tries to mount deeper in a mounted tree, the automounter will
not work properly.  To circumvent this difficulty, one needs to employ a
link gambit, provided by Ramon Pasetes of the OSS Department.  The solution
uses an intermediate link where the filesystem are mounted in the 1st
level, a series of links that make it make the file system appear to be
mounted as deep as it need be, and an export map to get the mountpoints to
the client machines.
<p>
Here, as an example of this solution.  The example is the current
automounting maps that the OSS department are using for the Run II
farm nodes, but applied to a test node called airedale.
<p>

Here is the auto.master entry for pnfs:
<pre>
/pnfs   /etc/auto.pnfs    -hard,intr,noac
</pre>
<p>
And here is the auto.pnfs map:
<pre>
d0sam           pcfarm9:/d0sam
#
enstore         pcfarm9:/enstore
#
grau            airedale:/Pnfs/grau        ro  [OSS uses node fnpca]
grau-ait        rip6:/grau-ait
grau-dlt        rip6:/grau-dlt
grau-mammoth    rip6:/grau-mammoth
#
rip6            rip6:/rip6disk1
#
sam             airedale:/Pnfs/sam         ro  [OSS uses node fnpca]
sam-ait         samson:/sam-ait
sam-dlt         samson:/sam-dlt
sam-mammoth     samson:/sam-mammoth
sam-red20       samson:/sam-red20
sam-red50       samson:/sam-red50
samson          samson:/samson
#
stk             airedale:/Pnfs/stk         ro  [OSS uses node fnpca]
stk-red20       rip6:/stk-red20
stk-red50       rip6:/stk-red50
</pre>
<p>
Here is the /etc/export file:                  [OSS exports to the required nodes]
<pre>
/Pnfs/grau	airedale.fnal.gov
/Pnfs/sam	airedale.fnal.gov
/Pnfs/stk	airedale.fnal.gov
</pre>
<p>
And finally, here are the intermediate links:
<pre>
airedale# ls -alsFgR /Pnfs 
/Pnfs:
total 5
   1 drwxrwxr-x   5 root     root         1024 Feb  8 11:05 ./
   1 drwxr-xr-x  30 root     root         1024 Feb  8 10:38 ../
   1 drwxrwxr-x   2 root     root         1024 Feb  8 10:39 grau/
   1 drwxrwxr-x   2 root     root         1024 Feb  8 11:05 sam/
   1 drwxrwxr-x   2 root     root         1024 Feb  8 11:27 stk/

/Pnfs/grau:
total 2
   1 drwxrwxr-x   2 root     root         1024 Feb  8 10:39 ./
   1 drwxrwxr-x   5 root     root         1024 Feb  8 11:05 ../
   0 lrwxrwxrwx   1 root     root           14 Feb  8 10:39 ait -> /pnfs/grau-ait/
   0 lrwxrwxrwx   1 root     root           14 Feb  8 10:39 dlt -> /pnfs/grau-dlt/
   0 lrwxrwxrwx   1 root     root           18 Feb  8 10:39 mammoth -> /pnfs/grau-mammoth/

/Pnfs/sam:
total 2
   1 drwxrwxr-x   2 root     root         1024 Feb  8 11:05 ./
   1 drwxrwxr-x   5 root     root         1024 Feb  8 11:05 ../
   0 lrwxrwxrwx   1 root     root           13 Feb  8 11:04 ait -> /pnfs/sam-ait/
   0 lrwxrwxrwx   1 root     root           13 Feb  8 11:04 dlt -> /pnfs/sam-dlt/
   0 lrwxrwxrwx   1 root     root           17 Feb  8 11:04 mammoth -> /pnfs/sam-mammoth/
   0 lrwxrwxrwx   1 root     root           15 Feb  8 11:05 red20 -> /pnfs/sam-red20/
   0 lrwxrwxrwx   1 root     root           15 Feb  8 11:05 red50 -> /pnfs/sam-red50/

/Pnfs/stk:
total 2
   1 drwxrwxr-x   2 root     root         1024 Feb  8 11:27 ./
   1 drwxrwxr-x   5 root     root         1024 Feb  8 11:05 ../
   0 lrwxrwxrwx   1 root     root           15 Feb  8 11:26 red20 -> /pnfs/stk-red20/
   0 lrwxrwxrwx   1 root     root           15 Feb  8 11:27 red50 -> /pnfs/stk-red50/
</pre>

<p>

Finally, it should be noted that mounting <em>the </em>pnfs namespace does
not restrict the node in any other way - it can import and mount any other
file systems and run any tasks as it normally would.

<h3><a name="pcmd">
1.1.4 pcmd: Enstore related <em>pnfs</em> commands
</h3>

All non-I/O Unix commands that operate on normal file systems can also
(typically) be used on the <em>pnfs</em> namespace. DESY has provided
several examples on their web pages and tools in their <em>pnfs</em>
package that allow users to view and control the special features of
<em>pnfs</em>.  Enstore has tailored these tools into a single script,
called pcmd, that allows users to control, manipulate and query <em>pnfs</em> files
that Enstore creates. The pcmd tool is distributed along with the <em>encp</em>
client. It is almost entirely written in shell, and therefore, it is
stand alone and doesn't require any other products, including python.  Pcmd is
based on DESY scripts and tailored for Enstore, as such it is not a general
<em>pnfs</em> tool.
<p>
Commonly used commands are:
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>FUNCTION</B></TD>
<TD NOSAVE><B>COMMAND</B></TD>
<TD NOSAVE><B>OUTPUT</B></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the online help</TD>
<TD NOSAVE>pcmd help</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists "important" info about the file<br>*** Needs work to be fully functional ***</TD>
<TD NOSAVE>pcmd info file</TD>
<TD NOSAVE><pre>
$ pcmd info M1
bfid="91184924000000L";
volume="flop309";
location_cookie="68608";
size="1252";
file_family="jon4";
filename="/pnfs/enstore/airedale/jon4/M1";
orig_name="/pnfs/enstore/airedale/jon4/M1";
map_file="/pnfs/enstore/volmap/jon4/flop309/000000068608";
pnfsid_file="00020000000000000050AE88";
pnfsid_map="00020000000000000050AEA0"</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the tags in the directory</TD>
<TD NOSAVE>pcmd tags directory</TD>
<TD NOSAVE><pre>
$ pcmd tags .
.(tag)(library)  =  rip6
.(tag)(file_family)  =  jon-rip6
.(tag)(file_family_width)  =  1
.(tag)(file_family_wrapper)  =  cpio_custom
-rw-rw-r--   1 bakken   g023            4 Nov 16 21:24 /pnfs/rip6/.(tag)(library)
-rw-rw-r--   1 bakken   g023            8 Nov 16 21:24 /pnfs/rip6/.(tag)(file_family)
-rw-rw-r--   1 bakken   g023            1 Nov 16 21:24 /pnfs/rip6/.(tag)(file_family_width)
-rw-rw-r--   1 bakken   g023           11 Jan 27 18:45 /pnfs/rip6/.(tag)(file_family_wrapper)
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>sets/lists library tag to value <br>(must have correct cwd)</TD>
<TD NOSAVE>pcmd library [value]</TD>
<TD NOSAVE><pre>
$ pcmd library
ait
$ pcmd library xxx
$ pcmd library
xxx</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>sets/lists file family tag to value <br>(must have correct cwd)</TD>
<TD NOSAVE>pcmd file_family [value]</TD>
<TD NOSAVE><pre>
$ pcmd file_family
jon-ait-3
$ pcmd file_family xxx
$ pcmd file_family
xxx
</pre></TD>
</TR>


<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>sets/lists file family width tag to value <br>(must have correct cwd)</TD>
<TD NOSAVE>pcmd file_family_width [value]</TD>
<TD NOSAVE><pre>
$ pcmd file_family_width    
2
$ pcmd file_family_width 10
$ pcmd file_family_width
10
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>sets/lists file family wrapper tag to value <br>(must have correct cwd)</TD>
<TD NOSAVE>pcmd file_family_wrapper [value]</TD>
<TD NOSAVE><pre>
$ pcmd file_family_wrapper
cpio_custom
$ pcmd file_family_wrapper cpio_odc
$ pcmd file_family_wrapper
cpio_odc
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists all the files on specified tape in volmap <br>*** Needs work to be fully functional ***</TD>
<TD NOSAVE>pcmd files volmap-tape</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the volmap-tape for the specified volumename <br>*** Needs work to be fully functional ***</TD>
<TD NOSAVE>pcmd volume volumename</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the bit file id of the file</TD>
<TD NOSAVE>pcmd bfid   file</TD>
<TD NOSAVE><pre>
$ pcmd bfid testfile
91551931700000L
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>*** lists the last parked location of the file <br>parked feature is not implemented</TD>
<TD NOSAVE>pcmd parked file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the debug info about the file transfer</TD>
<TD NOSAVE>pcmd debug  file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the cross-reference info about the file</TD>
<TD NOSAVE>pcmd xref   file</TD>
<TD NOSAVE><pre>
$ pcmd xref testfile
CA2902 (tape label)
'0000_000000000_0000132' (positioning info)
104857600 (file size)
jon-ait-1 (file family)
/pnfs/grau/ait/jon1/100MB.trand (original name)
/pnfs/grau/ait/volmap/jon-ait-1/CA2902/...
   ... 0000_000000000_0000132 (volume map name)
0001000000000000000928D0 (<em>pnfs</em> id of file)
0001000000000000000928E0 (<em>pnfs</em> id of volume map file)
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>does an ls on the named layer in the file</TD>
<TD NOSAVE>pcmd ls   file [layer]</TD>
<TD NOSAVE><pre>
$ pcmd ls testfile 3
4 -rw-rw-r-- bakken g023 3692 Jan 5 00:55 ./.(use)(3)(testfile)
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the layer of the file<br>it is easier to use pcmd bfid|parked|debug|xref commands</TD>
<TD NOSAVE>pcmd {cat|more|less} file layer</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists the tag in the directory<br>it is easier to use pcmd library|file_family|file_family_width commands</TD>
<TD NOSAVE>pcmd {tagcat|tagmore|tagless} tag  directory</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists whether Enstore is still accepting transfers</TD>
<TD NOSAVE>pcmd enstore_state  </TD>
<TD NOSAVE><pre>
$ pcmd enstore_state
Enstore enabled
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>lists whether <em>pnfs</em> mount point is up <BR>*** Not fully functional yet ***</TD>
<TD NOSAVE>pcmd pnfs_state mount-point</TD>
<TD NOSAVE><pre>
$ pcmd pnfs_state /pnfs/grau/ait
Pnfs up
</pre></TD>
</TR>

</TABLE></center>
<P>

Don't use these unless you know what you are doing:
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>FUNCTION</B></TD>
<TD NOSAVE><B>COMMAND</B></TD>
<TD NOSAVE><B>OUTPUT</B></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>echos text to named layer of the file</TD>
<TD NOSAVE>pcmd echo text file layer</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>deletes (clears) named layer of the file</TD>
<TD NOSAVE>pcmd rm file layer </TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>copies Unix file to named layer of file</TD>
<TD NOSAVE>pcmd cp unixfile file layer</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>copies Unix file to named layer of file</TD>
<TD NOSAVE>pcmd cp unixfile file layer</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>sets the size of the file</TD>
<TD NOSAVE>pcmd size file size</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>echos text to the named tag</TD>
<TD NOSAVE>pcmd tagecho text tagname</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>removes the tag (tricky, see DESY documents)</TD>
<TD NOSAVE>pcmd tagrm tag </TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>sets io mode (can't clear it easily)</TD>
<TD NOSAVE>pcmd io file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

</TABLE></center>
<P>


Don't use these unless you can interpret the results:
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>FUNCTION</B></TD>
<TD NOSAVE><B>COMMAND</B></TD>
<TD NOSAVE><B>OUTPUT</B></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the <em>pnfs</em> id</TD>
<TD NOSAVE>pcmd id file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the showid information</TD>
<TD NOSAVE>pcmd showid id</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the const information</TD>
<TD NOSAVE>pcmd const file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the filename</TD>
<TD NOSAVE>pcmd nameof id </TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the complete file path</TD>
<TD NOSAVE>pcmd path id</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the parent</TD>
<TD NOSAVE>pcmd parent id</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the counters</TD>
<TD NOSAVE>pcmd counters  file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows of the counters</TD>
<TD NOSAVE>pcmd counterN dbnum <br>(must have cwd in <em>pnfs</em></TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the cursor</TD>
<TD NOSAVE>pcmd cursor file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the directory position</TD>
<TD NOSAVE>pcmd position file</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the database information</TD>
<TD NOSAVE>pcmd database file </TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>shows the database information</TD>
<TD NOSAVE>pcmd databaseN dbnum <br>(must have cwd in <em>pnfs</em>)</TD>
<TD NOSAVE>&nbsp;<pre>
</pre></TD>
</TR>

</TABLE></center>
<P>

<h3><a name="volmaps">
1.1.5 <em>Pnfs</em> Volume Maps
</h3>

In order to request files from a tape in an optimal transversal, it is
necessary for the user to know the order of the files on a tape.  It is expected that an
experiment's catalog will keep this information.  As an additional aid for the user,
<em>encp</em> creates a duplicate file entry in <em>pnfs</em> (in addition to storing
the filename and its metadata).  This duplicate entry is organized by file
families and volumes instead of by the user's directory structure.  The naming
convention for the duplicate entries is such that the file order on the tape
could be readily known.  For example, for sequential files on tape, the name
is just the file number; for files on a disk, it is just the byte
offset. When a user wanted to know what was on a particular tape, he would
just look in the duplicate tree to get the files - then he would read the
necessary information about the linked file from one of the <em>pnfs</em> layers (such
as the bfid, original file name...) to make his transfer request to the mass
storage.

Let's say a user transferred a file to mass storage and called it
/pnfs/enstore/airedale/one.  The file was stored on disk floppy named
"flop301"  with a byte offset=0 and in a file family named "jon".

<pre>
$ ls -alsFt /pnfs/enstore/airedale/one
   0 -rw-rw-r--   1 bakken   root           26 Jul 21 12:09 /pnfs/enstore/airedale/one
</pre>

The duplicate entry is /pnfs/enstore/volmap/jon/flop301/000000000000
In the general case, "jon" would be replaced by the file family name,
"flop301" would become the volume name and "000000000000" would be the file
order on tape.

<pre>
$ ls -alsFt pnfs/enstore/volmap/jon/flop301/000000000000
   0 -rw-r--r--   1 root     root           26 Jul 21 12:09 /pnfs/enstore/volmap/jon/flop301/000000000000
</pre>

The original file and the duplicate file contain cross reference information
to allow the user to get to the other one and enough information to setup a
transfer. An example of this was shown in the previous section in "pcmd info file"

Consider a few cases.
<ul>
<li> If a user wants dozens of files, she can lookup up the volume name where
each file is stored and group her requests so files on one tape are grouped
together.
<li>If a user wants a dozen files from a certain file family but doesn't care
which ones, she can look into the volmap area and pick out files on a specific
volume and set up the request that way.
</ul>

Finally, since the user will not have delete authority to the duplicate
volmap file, this mechanism gives us an automatic trash can facility.  If the
user deletes his entry in <em>pnfs</em>, we still have the duplicate entry and can
"easily" restore the original.

<hr>
<h2><a name="encp">
1.2 <em>Encp</em>
</h2>
Reading and writing files means interacting with media.
Most users will just want to get their data file and do their work. They do
not want want all the "baggage" products (python, ftt libraries, libtp...)
that is required to run a complete Enstore system.  To this end, we
distribute a separate product, called <em>encp</em> along with
Enstore. This product basically consists of 1 stand-alone binary executable,
<em>encp</em>, and one UPS table file. This executable, and the mounting of
<em>pnfs</em>, is the only thing that clients need to access their data on
the robot.

<em>Encp</em> is very similar to the <em>cp</em> command in UNIX, and we
have tried to duplicate its behavior wherever possible.
The syntax is:
<pre>
% encp [options] src_file dst_file
</pre>
Currently there is no wild-carding allowed, but this is a straight forward
extension to <em>encp</em>.

<h3>
<a NAME="encp_options"></a>1.2.1 <em>Encp</em> command line options</h3>

<center><table BORDER COLS=3 WIDTH="100%" NOSAVE >
<tr VALIGN=CENTER NOSAVE>
<td NOSAVE><b>FUNCTION</b></td>
<td NOSAVE><b>SWITCH</b></td>
<td NOSAVE><b>DEFAULTS</b></td>
</tr>

<tr NOSAVE>
<td NOSAVE>print short help message about using <em>encp</em></td>
<td NOSAVE>--help</td>
<td NOSAVE>None</td>
</tr>

<tr NOSAVE>
<td NOSAVE>perform CRC check on the local user machine</td>
<td NOSAVE>--crc</td>
<td NOSAVE>CRC check is only performed on the mover computers</td>
</tr>

<tr NOSAVE>
<td NOSAVE>set the base priority = value</td>
<td NOSAVE>--pri=value</td>
<td NOSAVE>1</td>
</tr>

<tr NOSAVE>
<td NOSAVE>change the base priority by value after a period specified by the agetime switch</td>
<td NOSAVE>--delpri=value</td>
<td NOSAVE>0</td>
</tr>

<tr NOSAVE>
<td NOSAVE>specify the time period, in minutes, after which the base priority could change</td>
<td NOSAVE>--agetime=value</td>
<td NOSAVE>0 (no aging of priority)</td>
</tr>

<tr NOSAVE>
<td NOSAVE>give the library manager a hint that more work is coming for the
volume and it should not dismount the volume "too quickly" when this
transfer is completed </td>
<td NOSAVE>--delayed_dismount</td>
<td NOSAVE>None (immediate dismount on completion)</td>
</tr>

<tr NOSAVE>
<td NOSAVE>turn on special status printing requested by D0</td>
<td NOSAVE>--data_access_layer</td>
<td NOSAVE>D0 printing is off</td>
</tr>

<tr NOSAVE>
<td NOSAVE>change the amount of information printed about the transfer</td>
<td NOSAVE>--verbose=value</td>
<td NOSAVE>0 (no printing)</td>
</tr>

<tr NOSAVE>
<td NOSAVE>list the active and pending transfers for the specified node</td>
<td NOSAVE>--queue nodename</td>
<td NOSAVE>None</td>

<tr NOSAVE>
<td NOSAVE>create a new file family (width exactly 1) and copy files to this file family</td>
<td NOSAVE>--ephemeral</td>
<td NOSAVE>None</td>

<tr NOSAVE>
<td NOSAVE>copied files to specified file family</td>
<td NOSAVE>--family value<td>
<td NOSAVE>None</td>

<tr NOSAVE>
<td NOSAVE>specifies the hostname where the configuration server is running</td>
<td NOSAVE>--config_host=value</td>
<td NOSAVE>environmental variable, ENSTORE_CONFIG_HOST, set by the UPS setup command</td>
</tr>

<tr NOSAVE>
<td NOSAVE>specifies the port number that the configuration server responds to</td>
<td NOSAVE>--config_port=value</td>
<td NOSAVE>environmental variable, ENSTORE_CONFIG_PORT, set by the UPS setup command</td>
</tr>

</table></center>
<p>The data_access_layer option provides the output of <em>encp</em> in a format required
by the D0 SAM system. The example output is below:
<pre>
$  encp --data_access_layer 1GB.trand  /pnfs/grau/ait/jon1/
INFILE=/rip8a/enstore/random/1GB.trand
OUTFILE=/pnfs/grau/ait/jon1/1GB.trand
FILESIZE=1073741824
LABEL=CA2901
DRIVE=/dev/rmt/tps2d2n
TRANSFER_TIME=384.365273
SEEK_TIME=0.004476
MOUNT_TIME=24.688773
QWAIT_TIME=1.581097
TIME2NOW=434.628970
STATUS=ok

1 GB   copied to CA2901 at user 2.4 MB/S (2.7 MB/S IO rate)

</pre>

This output is easily parsable and provides information about input and
output files, file size, volume label, drive used to read/write data,
transfer time, file seek time, volume mount time, wait time in the request
queue, operation completion status, and total time since the invocation of <em>encp</em>
till the end of the operation.

<h3><a name="encp_throttle">
1.2.2 Throttling in <em>encp</em>
</h3>

It is important not to swamp any system.
In Enstore, a first level of throttling is implemented in
<em>encp</em>.
Control communications in Enstore uses a simple reliable
request-response protocol implemented in UDP, whereas data transfers
are implemented using two TCP ports.
A fixed number, currently 30, of pre-allocated TCP ports are
arbitrated among all instances of <em>encp</em> on a given machine.
Consequently, the system will survive the worst sort of abuse,
for example, someone forking off 200 copy requests,
since at most 15 will be active in the system at any time.

<h3><a name="encp_list_from hsm">
1.2.3 Specifying lists of files when reading from or writing to the HSM
</h3>

<em>Encp</em> duplicates unix cp's behavior when one tries to read or write
multiple input files from the HSM: <br><br> <em>encp</em> [options]
source... directory<br><br> That is, the final item has to be a directory when
specifying an input list.  There is one caveat when specifying multiple files
using a single <em>encp</em> command: there is at most one Mover processing your
request list at a time. If you want more than one Mover active, you should use
multiple <em>encp</em> commands when you are reading lists of files from more than
one volume.  The reason <em>encp</em> uses just one Mover is to keep the system
simple (if you want to use multiple Movers, then use many <em>encp</em>
commands).
<p>

On reads from the HSM, <em>encp</em> scans all specified files and groups them according
to which volume they are on, orders them according to location on a tape, and then submits all the file requests that are
on one specific volume, reads all the files for that volume from the HSM,
and then proceeds to the next volume.  <em>Encp</em> processes the volumes in any
order it chooses.
<p>

On writes to the HSM, <em>encp</em> processes each input file sequentially. Since
the user must specify a single output directory, all input files must belong to
the same file family, and hence could all go to the same tape (if
possible). <em>Encp</em> sets a flag,"don't dismount the volume too quickly -
there's more files coming for the same family", that the Mover uses to
postpone the dismount and thereby avoid the extra times involved in the
volume manipulations.  Please note that there is no guarantee that all the
files will go to one tape (there might not be room) or that they will be
grouped together on the tape (there may be other writes to the same family
that get intermixed).
<p>

Consider the following example (P=/pnfs/enstore/airedale) reading from
the HSM:
<p>

The following files on flop301: ran-1, ran-2 ran-3, ran-4<br>
The following files on flop302: ran-5, ran-6 ran-7, ran-8<br>
The following files on flop302: ran-9, ran-10 ran-11, ran-12<br>
<p>

<em>Encp</em> submits the requests for all files on flop301 and reads back those
files and then does the same for flop302 and flop303.
<p>

Here is the output of an actual test:
<pre>
$ encp $P/ran-1       $P/ran-2        $P/ran-3        $P/ran-4 \
       $P/test2/ran-5 $P/test2/ran-6  $P/test2/ran-7  $P/test2/ran-8 \
       $P/test3/ran-9 $P/test3/ran-10 $P/test3/ran-11 $P/test3/ran-12 .
$P/test2/ran-5  -> ./ran-5  : 102400 bytes copied from flop302 at 0.19 MB/S  requestor:bakken cum= 3.5
$P/test2/ran-6  -> ./ran-6  : 102400 bytes copied from flop302 at 0.42 MB/S  requestor:bakken cum= 3.7
$P/test2/ran-7  -> ./ran-7  : 102400 bytes copied from flop302 at 0.46 MB/S  requestor:bakken cum= 3.9
$P/test2/ran-8  -> ./ran-8  : 102400 bytes copied from flop302 at 0.46 MB/S  requestor:bakken cum= 4.2
$P/test3/ran-9  -> ./ran-9  : 102400 bytes copied from flop303 at 0.12 MB/S  requestor:bakken cum= 5.4
$P/test3/ran-10 -> ./ran-10 : 102400 bytes copied from flop303 at 0.49 MB/S  requestor:bakken cum= 5.6
$P/test3/ran-11 -> ./ran-11 : 102400 bytes copied from flop303 at 0.45 MB/S  requestor:bakken cum= 5.8
$P/test3/ran-12 -> ./ran-12 : 102400 bytes copied from flop303 at 0.45 MB/S  requestor:bakken cum= 6.1
$P/ran-1        -> ./ran-1  : 102400 bytes copied from flop301 at 0.12 MB/S  requestor:bakken cum= 7.4
$P/ran-2        -> ./ran-2  : 102400 bytes copied from flop301 at 0.45 MB/S  requestor:bakken cum= 7.6
$P/ran-3        -> ./ran-3  : 102400 bytes copied from flop301 at 0.42 MB/S  requestor:bakken cum= 7.8
$P/ran-4        -> ./ran-4  : 102400 bytes copied from flop301 at 0.45 MB/S  requestor:bakken cum= 8.0
</pre>


<h3><a name="encp_queue">
1.2.4 <em>Encp</em> Transfer Lists
</h3>

One of the requests of the Fermilab Farms group was the ability to query
Enstore to determine what transfers were in progress and pending on a
certain node. If they need to take a farm node out of service they
want to know what transfers are active on the node before it is taken
down.  [Some users submit jobs even when they know the node is going to be
down and then complain when their jobs fail. This feature will allow the
farms group to send an automated message saying that the node was taken
down and explain why their transfers failed.]
<p>
This is a straightforward and easy command, except for 2 complications:
<ul>
  <li> Python is (currently) required to get the transfer queue
  <li> The command must be available everywhere the <em>encp</em> clients run and
       python isn't typically available everywhere.
</ul>

Normally <em>encp</em> is involved only with copying files.  It is also the
only task distributed with the <em>encp</em> client software.  We chose to
extend the <em>encp</em> client code so it could determine the transfer
queues in addition to its main responsibility of copying files.  This got
around both complications.
<p>
Here's an example of how it is used:
<pre>
$ encp --queue rip8.fnal.gov
rip8.fnal.gov bakken /raid/1MB.trand /pnfs/grau/ait/jon1/1MB.trand P
rip8.fnal.gov bakken /raid/1GB.trand /pnfs/grau/ait/jon2/1GB.trand M
rip8.fnal.gov bakken /raid/1GB.trand /pnfs/grau/ait/jon1/1GB.trand M

$ encp --queue rip4.fnal.gov
rip4.fnal.gov bakken /raid/1MB.trand /pnfs/grau/ait/jon2/1MB.trand M
</pre>

The 1st field in the output is the node name, the 2nd is the requester, the
3rd is the input filename, and the 4th is the output filename.  The 5th and
last field can have 2 values: "P" denotes a <u>P</u>ending transfer still
in the Library Manager queues and "M"
signifies a active transfer at a <u>M</u>over.

<h3><a name="encp_errors">
1.2.5 <em>Encp</em> Return Status 
</h3>
Every individual <em>encp</em> request returns a status in order to identify (and in some
cases resolve) any 
occurring problem, if any. <em>Encp</em> processes the status internally and either
retries the request (providing the user with intermediate status) or
terminates with the appropriate status. The only successful status returned by <em>encp</em> is <b>"OK"</b> and the only successful <em>encp</em> exit code is <b>0</b>. Below is the list of statuses returned to the user:
<p><center><table BORDER COLS=2 WIDTH="80%" NOSAVE >
<tr VALIGN=CENTER NOSAVE>
<td NOSAVE><b>STATUS</b></td>
<td NOSAVE><b>DESCRIPTION</b></td>
</tr>

<tr NOSAVE>
<td NOSAVE>OK</td>
<td NOSAVE>Operation Completed Successfully</td>
</tr>

<tr NOSAVE>
<td NOSAVE>KEYERROR</td>
<td NOSAVE>Not an existing reference key</td>
</tr>

<tr NOSAVE>
<td NOSAVE>DOESNOTEXIST</td>
<td NOSAVE>Object (file name, etc.) does not exist</td>
</tr>

<tr NOSAVE>
<td NOSAVE>NOMOVERS</td>
<td NOSAVE>No Movers to process request</td>
</tr>

<tr NOSAVE>
<td NOSAVE>MOUNTFAILED</td>
<td NOSAVE>Mount of required volume failed</td>
</tr>

<tr NOSAVE>
<td NOSAVE>DISMOUNTFAILED</td>
<td NOSAVE>Dismount of required volume failed</td>
</tr>

<tr NOSAVE>
<td NOSAVE>MEDIA_IN_ANOTHER_DEVICE</td>
<td NOSAVE>Requested Media is in another Device</td>
</tr>

<tr NOSAVE>
<td NOSAVE>MEDIAERROR</td>
<td NOSAVE>Bad Media</td>
</tr>

<tr NOSAVE>
<td NOSAVE>USERERROR</td>
<td NOSAVE>User Error</td>
</tr>

<tr NOSAVE>
<td NOSAVE>DRIVEERROR</td>
<td NOSAVE>Drive Error</td>
</tr>

<tr NOSAVE>
<td NOSAVE>UNKNOWNMEDIATYPE</td>
<td NOSAVE>Unknown media type</td>
</tr>

<tr NOSAVE>
<td NOSAVE>NOVOLUME</td>
<td NOSAVE>Volume does not exist</td>
</tr>

<tr NOSAVE>
<td NOSAVE>NOACCESS</td>
<td NOSAVE>Volume marked as no access</td>
</tr>

<tr NOSAVE>
<td NOSAVE>CONFLICT</td>
<td NOSAVE>Configuration conflict detected</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_NOTAPE
</td>
<td NOSAVE>Requested volume was not found in the library</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_TAPEBUSY</td>
<td NOSAVE>Requested volume is in another drive.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_DRIVEBUSY</td>
<td NOSAVE>A volume is already in the drive.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_BADMOUNT</td>
<td NOSAVE>Mount failure or load operation failed.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_BADSPACE</td>
<td NOSAVE>EOD cookie does not produce EOD.</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_ERROR</td>
<td NOSAVE>Error writing data block or file mark</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_EOT</td>
<td NOSAVE>Hit EOT while writing data block or file mark</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_NOBLANKS</td>
<td NOSAVE>No more blank volumes</td>
</tr>

<tr NOSAVE>
<td NOSAVE>WRITE_MOVER_CRASH</td>
<td NOSAVE>Mover crash during write operation</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_NOTAPE</td>
<td NOSAVE>Requested volume was not found in the library</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_TAPEBUSY</td>
<td NOSAVE>Requested volume is in another drive</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_DRIVEBUSY</td>
<td NOSAVE>A volume is already in the drive</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_BADMOUNT</td>
<td NOSAVE>Mount failure or load operation failed</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_BADLOCATE</td>
<td NOSAVE>Failed space or initial CRC's don't match</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_ERROR </td>
<td NOSAVE>Error reading data block</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_COMP_CRC</td>
<td NOSAVE>CRC mismatch</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_EOT</td>
<td NOSAVE>Hit EOT when reading</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_EOD</td>
<td NOSAVE>Hit EOD when reading</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_UNLOAD</td>
<td NOSAVE>Error unloading volume</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_UNMOUNT</td>
<td NOSAVE>Error when unmounting volume</td>
</tr>

<tr NOSAVE>
<td NOSAVE>READ_MOVER_CRASH</td>
<td NOSAVE>Mover crash during read operation</td>
</tr>
</table></center>
<br>
More detailed description of these and other statuses and how they are processed inside of the system can be found in section 4 of this document.

<h3><a name="encp_client">
1.2.6 <em>Encp</em> Client Installation
</h3>

<em>Encp</em> is distributed via the Fermilab UPD mechanism. It is a static
binary product that does not depend on any other products or executables.
The binary <em>encp</em> product is made using the standard Python freeze
tool.  Basically, the Python freeze tool uses the regular Python parser to
parse the Python code and all its modules to produce a binary that people who
don't have Python can run.  <p>

Typically 2 <em>encp</em> products are available in UPD, one for general
use and one explicitly tailored for D0/SAM.  This tailorint is simply for SAM's
convenience.  There will only be one version in the future.
<pre>
$ upd list -a encp

DATABASE=/ftp/upsdb 
        Product=encp    Version=v0_11-sam       Flavor=Linux+2
                Qualifiers=""   Chain=current

        Product=encp    Version=v0_11   Flavor=Linux+2
                Qualifiers=""   Chain=""
</pre>




The installation procedure is straightforward:
<pre>
$ upd install -G"-c" encp
informational: beginning install of encp.
informational: transferred /ftp/products/encp/v0_11/Linux+2/encp_v0_11_Linux+2
        from fnkits.fnal.gov to
        /home/products/encp/v0_11
informational: transferred /ftp/products/encp/v0_11/Linux+2/encp_v0_11_Linux+2.table
        from fnkits.fnal.gov:/ to
        /home/products/upsdb/encp/v0_11.table.new
informational: ups declare succeeded
informational: ups declare succeeded
</pre>

The entire product consists of the <em>encp</em> binary, pcmd (a <em>pnfs</em> script
described in the <em>pnfs</em> section), and some UPS tables.  The <em>encp</em> binary is
large since it is statically linked.
<pre>
$ ls
     179 Nov 24 09:49 .manifest.encp
 2976514 Nov 24 09:24 encp*
    1690 Nov 24 09:24 encp.table
       9 Dec  2 15:20 enstore_variables.table -> rip.table
   11313 Nov 24 09:24 pcmd*
     398 Nov 24 09:24 rip.table
     399 Nov 24 09:24 sam.table
</pre>

Two environmental variables, ENSTORE_CONFIG_PORT, and ENSTORE_CONFIG_HOST,
control to which Enstore system the <em>encp</em> requests go. In order to
allow a user to override the default control environmental
variables distributed with the product, the <em>encp</em> product uses the
UPS concept of "virtual" products.  The basic idea is that everything in
the <em>encp</em> table file is general, and everything in the virtual
product enstore_variables.table file is user/installation specific.
<p>
Finally, when <em>encp</em> is setup, it creates a directory in the /tmp
area where it stores debugging information and other non-user
information. The user can ignore the files in the /tmp area. 
<p>
As an aside, it should be noted that since Enstore is still
in development, no versions are cut.  The complete UPS product structure is
finished.  For new installations, typically we CVS checkout code, issue one
make command, and the product is ready to be used.  We expect to cut
versions of Enstore when it is appropriate. These versions will not be
frozen, <it>i.e.</it>, they will need Python and the other dependent products.

<hr>
<h2><a name="servers">
1.3.0 Enstore Servers
</h2>
Enstore servers are software modules that have specific functions.
The high level  concepts are as follows:
<dl>
<dt><em>Physical library</em>
<dd>A Physical Library represents a real, tangible collection of media
along with software drivers/utilities to manipulate, read and write
and organize them.

A physical library can be thought of as consisting of
<ul>
        <li>one or more virtual libraries
        <li>a media changer (robot arm)
        <li>one of more media export/import slots
        <li>one of more drives (tape, cdrom, disk, etc.)
        <li>volumes (tape cartridges, cdroms, etc.)
</ul>
<p>
<em>Virtual Library</em> -- A virtual library contains one and only one
kind of media.
For example, Enstore divides an STK Powderhorn
library holding 50, 20 and 10 GB redwood media into at least three
virtual libraries.  In common usage, the term "library" in Enstore
refers to a virtual library. Writes are directed to a specific (virtual)
library, thus selecting the media.
<p>
<em>Drives</em> -- Drives are bound to special processes called Mover
clients.
The drives can be dynamically assigned allowing the number of drives
to be less than the number of virtual libraries.
<p>
<em>Volumes</em> -- Are uniquely identified by an external label,
which is known to the Media Changer.
<p>
<dt><em>Quota Family</em>
<dd>A quota family is a set of pairs of media names and maximum number of volumes.
All files are created with respect to a quota family.
Creation of a file is not allowed if the maximum number of volumes
in that family would be exceeded.  *** Quotas are not implemented in Enstore yet ***
<p>
<dt><em>File family</em>:
<dd>A file family is specified by a name and an integer "width".
A file family is associated with every file creation.
Within a given library, Enstore keeps no more
than <em>"width"</em> volumes open for writing, and loads volumes on
no more than <em>"width"</em>
number of drives at any given moment.  There currently is no width for reading,
this could be added if deemed important.
This is not striping, but rather, the number of different volumes,
and hence different files, which can be active at one time.
Once a volume is associated with a file family, only files in that
family will be placed on the volume.
By design, there is no pre-set limit on the number of file families.
Clever use of file families will allow volumes to be faulted out to
"shelf", and also to decrease access times for subsequent reads.  When a file
family has filled all of its "width" media, new media
are drawn out of a pool of blanks.
</dl>
Media ejected to shelf are put into a shelf virtual library and
are controlled by a shelf Library Manager.
Users are informed that this data is currently unavailable, and if
they really want the data, arrangements should be made to have the
media placed in a library which is accessible,
or get it manually later.
<p>
Each of the servers listed below is discussed in further detail in its own
section.  Please refer to these sections for information on detailed 
functionality and specific command line interfaces.
<ul>
 <li>Configuration Server - administers Enstore system configuration information.
 <li>Library Manager - queues and dispatches work for a virtual library.
 <li>Mover - handles the actual transfer of data from a volume to the user.
 <li>Media Changer - represents a physical device or operator who performs mounts/dismounts of volumes on drives.
 <li>Inquisitor - monitors Enstore system status and activity.
 <li>File Clerk - administers file information (<it>e.g.</it> - location cookies).
 <li>Volume Clerk - administers volume information (<it>e.g.</it> bytes left).
 <li>Log Server - formats and records Enstore system log messages.
 <li>Admin Clerk - allows administrative access to the Enstore system.
 <li>Alarm Server - analyzes Enstore system status and activity information to determine system health.
</ul>
<h3><a name="servers_cmds">
1.3.0.1 General Command Line Control of Servers
</h3>
Enstore servers implement a common uniform interface.  Common parsing is used
to determine command line options.  All servers support a set of general options
as well as those specific in functionality.  Control of the servers is done via
<em>ecmd</em>.  This command provides a general way of accessing the individual
servers as well as the Enstore system as a whole.  Examples of using this command
to accomplish this are given following the table of general options. <em>ecmd</em>
recognizes the following server names when sending commands to the individual
servers:
<p>
<ul>
 <li>Configuration Server - cc
 <li>Library Manager - lmc
 <li>Mover - mvc
 <li>Media Changer - mcc
 <li>Inquisitor - ic
 <li>File Clerk - fcc
 <li>Volume Clerk - vcc
 <li>Log Server - lc
 <li>Alarm Server - ac
</ul>
For example : <em>ecmd ic --help</em>
<p>
When <em>ecmd</em> is used to start/stop servers, the server must be specified by
using the full Ascii name specified in the configuration file. For example:<br>
<ul>
<li>config
<li>rip6.library_manager
<li>rip6.mover
<li>rip6.media_changer
<li>file_clerk
<li>volume_clerk
<li>log_server
<li>alarm_server
</ul>

<p>
<table BORDER COLS=3 WIDTH="100%" NOSAVE >
<TH COLSPAN=3 VALIGN=CENTER>General Server Options</TH>
<tr VALIGN=CENTER NOSAVE>
<td NOSAVE><b>FUNCTION</b></td>
<td NOSAVE><b>SWITCH</b></td>
<td NOSAVE><b>DEFAULTS</b></td>
</tr>
<tr NOSAVE>
<td NOSAVE>check if the server process exists</td>
<td NOSAVE>--alive</td>
<td NOSAVE>None</td>
</tr>
<tr NOSAVE>
<td NOSAVE>specify the time to wait for a response from the server</td>
<td NOSAVE>--alive_rcv_timeout=value</td>
<td NOSAVE>10</td>
</tr>
<tr NOSAVE>
<td NOSAVE>specify the number of times to retry sending a message to a server</td>
<td NOSAVE>--alive_retries=value</td>
<td NOSAVE>None</td>
</tr>
<tr NOSAVE>
<td NOSAVE>specify the hostname where the configuration server is running</td>
<td NOSAVE>--config_host=value</td>
<td NOSAVE>environmental variable, ENSTORE_CONFIG_HOST, set by the UPS setup command</td>
</tr>
<tr NOSAVE>
<td NOSAVE>specify the port number that the configuration server responds to</td>
<td NOSAVE>--config_port=value</td>
<td NOSAVE>environmental variable, ENSTORE_CONFIG_PORT, set by the UPS setup command</td>
</tr>
<tr NOSAVE>
<td NOSAVE>print a short help message about using the server</td>
<td NOSAVE>--help</td>
<td NOSAVE>None</td>
</tr>
<tr NOSAVE>
<td NOSAVE>change the amount of information printed about the transfer (in the server)</td>
<td NOSAVE>--server_verbose=value</td>
<td NOSAVE>None</td>
</tr>
<tr NOSAVE>
<td NOSAVE>change the amount of information printed about the transfer (in the client)</td>
<td NOSAVE>--verbose=value</td>
<td NOSAVE>0 (no printing)</td>
</tr>
</table>
<p>
It should be noted that currently the <em>help</em> option produces insufficient 
and inelegant information.  This will be fixed in the future.
<p>
<table BORDER COLS=3 WIDTH="100%" NOSAVE >
<TH COLSPAN=3 VALIGN=CENTER>Enstore System Command Line Control</TH>
<tr VALIGN=CENTER NOSAVE>
<td NOSAVE><b>OPTION</b></td>
<td NOSAVE><b>COMMAND</b></td>
</tr>
<tr NOSAVE>
<td NOSAVE>start the Enstore system on the current node</td>
<td NOSAVE>ecmd start</td>
</tr>
<tr NOSAVE>
<td NOSAVE>start only the file_clerk on the current node</td>
<td NOSAVE>ecmd start --just file_clerk</td>
</tr>
<tr NOSAVE>
<td NOSAVE>start the Enstore system on the whole Enstore cluster</td>
<td NOSAVE>ecmd Estart</td>
</tr>
<tr NOSAVE>
<td NOSAVE>stop the Enstore system on the current node</td>
<td NOSAVE>ecmd stop</td>
</tr>
<tr NOSAVE>
<td NOSAVE>stop only the log_server on the current node</td>
<td NOSAVE>ecmd stop --just log_server</td>
</tr>
<tr NOSAVE>
<td NOSAVE>stop the Enstore system on the whole Enstore cluster</td>
<td NOSAVE>ecmd Estop</td>
</tr>
<tr NOSAVE>
<td NOSAVE>stop and then start the Enstore system</td>
<td NOSAVE>ecmd restart</td>
</tr>
<tr NOSAVE>
<td NOSAVE>stop and then restart only the Inquisitor on the current node</td>
<td NOSAVE>ecmd restart --just inq</td>
</tr>
<tr NOSAVE>
<td NOSAVE>stop and then start the Enstore system on the whole Enstore cluster</td>
<td NOSAVE>ecmd Erestart</td>
</tr>
<tr NOSAVE>
<td NOSAVE>display the mount status on the EMASS robot</td>
<td NOSAVE>ecmd emass</td>
</tr>
<tr NOSAVE>
<td NOSAVE>display the Enstore-associated processes on the whole Enstore cluster</td>
<td NOSAVE>ecmd Esys</td>
</tr>
</table>
<p>
<h3><a name="volume_clerk">
1.3.1 Volume Clerk
</h3>
The Volume Clerk keeps and administers volume information that it stores in a single table database.
There is one record for each volume known to the system. The record is looked up by a key, which  is the volume's external label.
The information tracked for each volume is described in the table below.
The default values are shown in parentheses ().
<center><table>
<td valign=top><b>Column Name</b>
<td valign=top><b>Type</b>
<td valign=top><b>Comments</b>
<tr>
<td valign=top>external_label
<td valign=top>string [primary_key]
<td valign=top>Volume name specified by user on volume creation; is used to
display volume metadata.
<tr>
<td valign=top>file_family
<td valign=top>string ("none")
<td valign=top>File family name, specified by user on volume creation; only
files that belong to this family will be stored on this volume.
<tr>
<td valign=top>media_type
<td valign=top>string
<td valign=top>Specified at volume creation; implies the block-size; used for
writing.
<tr>
<td valign=top>library
<td valign=top>string
<td valign=top>Specified by user on volume declaration; defines which (virtual)
library currently holds the volume
<tr>
<td valign=top>first_access
<td valign=top>int (-1)
<td valign=top>Unix time when user issues the first write command to copy data to the volume.
Set by the Volume Clerk.
<tr>
<td valign=top>last_access
<td valign=top>int (-1)
<td valign=top>Unix time when  user last accessed the volume. Set by the Volume Clerk.
<tr>
<td valign=top>declared
<td valign=top>int
<td valign=top>Unix time when the volume is declared available to the system. Set by the Volume Clerk.
<tr>
<td valign=top>capacity_bytes
<td valign=top>64-bit int
<td valign=top>Specified by user on volume creation; estimate of the number of
bytes that would fit on the volume.
<tr>
<td valign=top>blocksize
<td valign=top>int
<td valign=top>Set by the Volume Clerk; derived from the media type.
<tr>
<td valign=top>remaining_bytes
<td valign=top>64-bit int
<td valign=top>Specified by the user on volume creation; estimate of the number
of bytes that would fit on the volume; updated by the Volume Clerk every time
data are written to the media.
<tr>
<td valign=top>eod_cookie
<td valign=top>string ("none")
<td valign=top>Tells the driver how to space to the end of the volume; it is
driver specific; updated by the Volume Clerk when data are written on the
media.
<tr>
<td valign=top>wrapper
<td valign=top>string ("cpio")
<td valign=top>Wrapper method; currently specifies the format of the files on
the volume.
<tr>
<td valign=top>sum_rd_err
<td valign=top>int (0)
<td valign=top>Read error count; Volume Clerk increments this field when the Mover
receives an error while reading from the volume.
<tr>
<td valign=top>sum_rd_access
<td valign=top>int (0)
<td valign=top>Read access count; Volume Clerk increments this field
every time a file is read.
<tr>
<td valign=top>sum_wr_err
<td valign=top>int (0)
<td valign=top>Write error count; Volume Clerk increments this field when the
Mover receives an error while writing to the volume.
<tr>
<td valign=top>sum_wr_access
<td valign=top>int (0)
<td valign=top>Write access count; Volume Clerk increments this field every
time a file is written.
<tr>
<td valign=top>user_inhibit
<td valign=top>string (d:"none" or "readonly", "noaccess")
<td valign=top>Specified by user at volume creation; access level for this
volume, updated by Volume Clerk.
<tr>
<td valign=top>system_inhibit
<td valign=top>string (d:"none" or "writing", "readonly", "full", "noaccess")
<td valign=top>Administrator generated limitation on the kind of access permitted to
this volume; updated by Volume Clerk when data are written on the volume, an
error occurred while data were being written or the file size exceeded the
remaining number of bytes on the volume.
<tr>
<td valign=top>at_mover
<td valign=top>tuple. First element is state string ("unmounted","mounting", "mounted", "unmounting"). Second is a mover name
<td valign=top>Reflects state of volume. Used to keep track of volume mount state to avoid illegitimate mount requests. Transitions are as follows: "unmounted"->"mounting"->"mounted"->"unmounting"->"unmounted". All other transition and associated requests will be rejected
</table></center>
<p>
The Volume Clerk does the following operations:
<ul>
<li>show the name of all the volumes
<li>show volume information
<li>add a volume
<li>delete a volume
<li>restore a volume
<li>find an appropriate volume on which to write the file
<li>change the number of remaining bytes on the volume
<li>set the number of read/write errors
<li>set the current status of the volume
<li>set the volume as readonly
<li>start/stop backup of volume journals
</ul>

<h4><a name="volume_clerk_cmds">
1.3.1.1 Command Line Control of the Volume Clerk
</h4>
The user may interact with the Volume Clerk directly through the <em>ecmd vcc</em>
command.<p>
<center><TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>
<th> Function
<th> Command
<tr>
<td valign=top>show the name of all the volumes
<td valign=top>ecmd vcc --vols
<tr>
<td valign=top>show volume information
<td valign=top>ecmd vcc --vol volume_name
<tr>
<td valign=top>add a volume
<td valign=top>ecmd vcc --addvol library file_family media_type volume_name capacity remaining_capacity
<tr>
<td valign=top>delete a volume
<td valign=top>ecmd vcc --delvol volume_name
<tr>
<td valign=top>restore a volume (do not restore files)
<td valign=top>ecmd vcc --restorevol volume_name
<tr>
<td valign=top>restore a volume (restore files)
<td valign=top>ecmd vcc --all --restorevol volume_name
<tr>
<td valign=top>find an appropriate volume on which to write the file
<td valign=top>ecmd vcc --nextvol library_name minimal_remaining_bytes file_family
<tr>
<td valign=top>put volume into a new library
<td valign=top>ecmd vcc --newlib volume_name library_name
<tr>
<td valign=top>clear system inhibitors to the volume
<td valign=top>ecmd vcc -clrvol volume_name
<tr>
<td valign=top>mark no access to this volume
<td valign=top>ecmd vcc --noavol volume_name
<tr>
<td valign=top>set the volume as read only
<td valign=top>ecmd vcc --rdovol volume_name
<tr>
<td valign=top>start/stop backup of volume journals
<td valign=top>ecmd vcc --backup
</table></center>
<p>
<hr>
<h3><a name="file_clerk">
1.3.2 File Clerk
</h3>
The File Clerk tracks files in the system. There is one record for each file
in the system.
The records are keyed.
The key is the string version of the bit file ID.
The default values are shown in parentheses ().
The fields tracked are as follows:
<p><center><table>
<td valign=top><b>Column Name</b>
<td valign=top><b>Type</b>
<td valign=top><b>Comments</b>
<tr>
<td valign=top>bfid
<td valign=top>string [primary_key]
<td valign=top>bit file ID; uniquely identifies every file in the system.
<tr>
<td valign=top>external_label
<td valign=top>string
<td valign=top>Volume name on which the file has been written; same as the
external_label in the volume table.
<tr>
<td valign=top>bof_space_cookie
<td valign=top>string
<td valign=top>Driver specific string telling how to space to the file on the
media. A lexical sort of all bof_space_cookies for a given volume will yield a optimized
traversal of the volume.
<tr>
<td valign=top>complete_crc
<td valign=top>int
<td valign=top>crc of all the bits sent by the user.
<tr>
<td valign=top>sanity_cookie
<td valign=top>string ("(0,0)")
<td valign=top>Number of bytes used for a sanity crc and the sanity crc
itself.  The sanity crc is just the normal crc but only for the 1st N bytes in
the file. This allows the Mover to check early in the transfer process that it
probably has the right user file selected; it at least will know if it has the
wrong file.
</table></center>
<p>
The File Clerk supports the following requests:
<ul>
<li>show bfid of all the files
<li>show file information
<li>start/stop backup of file journals
<li>assist in processing file read requests
<li>delete/restore files
</ul>

<h4><a name="file_clerk_cmds">
1.3.2.1 Command Line Control of the File Clerk
</h4>
Users may interact with File Clerk directly through <em>ecmd fcc</em>
command.
<p><center><TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>
<th> Function
<th> Command
<tr>
<td valign=top>show bfid of all the files
<td valign=top>ecmd fcc --bfids
<td valign=top>
<tr>
<td valign=top>show file information
<td valign=top>ecmd fcc --bfid=bit-field-ID
<tr>
<td valign=top>start/stop backup of volume journals
<td valign=top>ecmd fcc --backup
<tr>
<td valign=top>declare file deleted/undeleted
<td valign=top>ecmd fcc --bfid=BFID --deleted={yes/no}
<tr>
<td valign=top>restore file by name
<td valign=top>ecmd fcc --restore="file_name"
<tr>
<td valign=top>restore file by name and restore a path
<td valign=top>ecmd fcc --r --restore="file_name"
</table></center><p>
<hr>
<h3><a name="library_manager">
1.3.3 Library Manager
</h3>
The Library Manager is a server which queues up and dispatches work for
a virtual library. There is one Library Manager for each virtual library.
It has two types of clients: 
<ol>
<li><em>Users</em> -- requesting to have their files read or written.
<li><em>Movers</em> -- seeking to actually read or write files.
</ol>
<p>
It can be also accessed from a command line interface
<p>
Enstore does not limit the number of Library Managers and the
relation between Library Managers and Movers is many to many.  That is, one
Library Manager may have many Movers associated with it and, one Mover may have
many Library Managers associated with it.

Information about Library Managers is contained in the Enstore configuration
dictionary and is available to clients via the Configuration Server.
Each Library Manager is specified in the configuration dictionary as follows:
<pre>
configdict['rip6.library_manager']   = { 'host':'rip5',
                                         'port':7506,
                                          'logname':'RP6LBM' }
configdict['ait.library_manager']    = { 'host':'rip5',
                                         'port':7507,
                                          'logname':'AITLBM' }
configdict['mam.library_manager']    = { 'host':'rip5',
                                         'port':7508,
                                         'logname':'MAMLBM' }
configdict['dlt.library_manager']    = { 'host':'rip5',
                                         'port':7509,
                                         'logname':'DLTLBM' }
configdict['red50.library_manager'] = { 'host':'rip5',
                                         'port':7510,
                                         'logname':'RD5LBM' }
configdict['red20.library_manager'] = { 'host':'rip5',
                                         'port':7511,
                                         'logname':'RD2LBM' }
where:

<b>*.library_manager</b> is the name of the Library Manager.
<b>host</b> is the host name where the Library Manager runs.
<b>port</b> is the Library Manager's command communication port.
<b>logname</b> is a name identifying the Library Manager in the log file.
</pre>
<p>
When the Library Manager starts, it requests from the Configuration Server a list
of Movers associated with it and stores them into an internal Mover List. Each
Mover has an entry in the configuration dictionary describing the Library
Manager(s) associated with it. This entry can be a single name or a list of
names:
<pre>
configdict['DE14DLT.mover'] = { 'host':'rip1',
                                'port':7527,
                                'logname':'DE14MV',
                                'library':'dlt.library_manager',
                                'device':'/dev/rmt/tps2d2n',
                                'driver':'FTTDriver', 
                                'mc_device':'DE14',
                                'media_changer':'de14.media_changer' }
</pre>

<p>
The Mover List is used to select Movers to do work and evenly distribute
work between all Movers associated with a Library Manager.

<p>
When the Mover starts, it sends the command("idle_mover") to all Library Managers
associated with it to declare itself active and available. If the Library Manager
does not have this Mover in its Mover List, it will be added to the list upon
receipt of this command. This Mover - Library Manager initial communication
allows the dynamic configuration of Movers.

<h3><a name="user_request">
1.3.3.1 Users' Requests
</h3>
<dl>
<dt>Writes into the system
<dd>Based on the user's <em>encp</em> destination filename, a <em>pnfs</em> tag
associated with the destination directory, identifies
    the library for a write request allowing the <em>encp</em> program to compose
    a write request and contact the appropriate Library Manager
    directly.
    The Library Manager queues the work, and acknowledges the request.
    When a write request is completed the Library Manager will send
    "unbind volume" message to the mover and it will dismount the corresponding
     volume.
    The Library Manager does not know that there is another
     request for the same volume coming a little bit later. However the User
     knows. To inform the Library Manager that there may be another request for
     the same volume, the user supplies a "delayed_dismount" flag in a current
     request. If this flag is set, the Library Manager will not dismount the
     volume even if there are no current requests for it. Instead it will
     postpone the dismount for a certain period of time and, if there are
     still no requests for this volume after a time out, the Library Manager will
     communicate with the corresponding Mover to dismount the volume.

<dt>Reads from the system
<dd>Given the fact that users may mv the <em>pnfs</em> files, on reads from the system,
     <em>pnfs</em> can only provide the bit
    file ID associated with the file. In this case, <em>encp</em> contacts the
     File Clerk, which returns the bit file ID and additional information about
     the requested file as well as the Library Manager associated with this file.
     Then <em>encp</em> sends the read request to this Library Manager.
<dt>Inquiries
<dd>Currently there is only one kind of Inquiry request allowing a user to observe
     requests queued in the Library Manager queues. This command asks the Library Manager to provide information about all current requests from a particular user node. The output format is: <br>
[user node] [user name] [input file] [output file] [request status]
     request status can be either P (pending) or M (at Mover)<br>
     The example of the output is given in 1.2.4
</dl>
<p>
Work can be prioritized.
Smaller priority number means higher priority.
Currently, write and read are both priority 1 for our test purposes.
Any priority mechanism could be developed to replace the existing one.
However, the system will exhaust all work for a volume,
given that it has been mounted, regardless of priority.
<p>
The Library Manager tries to sort read requests according to file location on
the tape. If a read request has been already sent to the Mover the next request
to this Mover for the same tape will be for the file whose location number is
higher than the current one. If the location number is less than the current 
one, it will be placed at the end of the request list.

<p>
Once a User request comes, the Library Manager tries to pick up the next
available (marked as "idle") Mover and send a "summon" message to it. The purpose
of this message is to cause a Mover to send a Mover Request to the Library
Manager. Mover Requests are described in the next section.
The mechanism of the selection of a particular Mover allows control of some
error conditions and implementation of retry logic. For this purpose there is dynamic
list of volumes on which write or read requests failed - Suspected Volumes
List.
It is keyed by the volume external label and contains sublists of Movers on
which the request for this volume failed. This tells the Library Manager to not
use the same Mover when the User retries its request.

When the Library Manager "summons" a Mover it changes the Mover state into the
Mover List to "summoned" and puts it into the Summoned Movers List. Every time
the Library Manager sends a message there is a time out handler that is being
invoked if a response does not arrive before the time out expires. The time out
handler will retry to "summon" the Mover whose time out has expired and,
eventually remove the Mover for which "summon" retries expire from the Mover
List.

<h3><a name="mover_request">
1.3.3.2 Movers' Requests
</h3>
<p>
The Enstore system keeps unassigned read and write requests in a queue of
unallocated (pending) work in the Library Manager. Once a request for the next work comes from the Mover ("idle" or "have bound volume: idle"), the Library Manager tries to change "at_mover" volume state to "mounting", and, if succeeds, puts the request in a "work at mover" queue and responds to the Mover with the appropriate ticket. The reason for this is to track the
volumes for scheduling : the Library Manager must not submit to a Mover a
request for a volume which is already in use by another Mover. It is the Mover, and not the Library Manager which completes the requests.
The two Library Manager request queues are:
<ul>
<li>pending work
<li>work at a Mover.
</ul>
<p>
It is important to keep these queues consistent. Volume and reading
errors are handled in the Mover and partially in the Library Manager.
<p>
Movers seek to transport data
between media and users over a TCP socket.
When "summoned" or having completed work, Movers contact the Library Managers
seeking work. If the Library Manager
has work, it sends a corresponding ticket to the Mover, which in turn
mounts the volume if necessary and transfers the data between user and media.
When the Mover completes some work it sends to the Library Manager a request for more
work and if it gets a reply that there is no more work for it, it dismount a
volume. 
A Mover may also have decided to dismount a volume unilaterally because it
ran into trouble. But it actually does it receiving no_work reply from the
Library Manager. Library Manager - Mover communications are in the tables
below
<p><table>
<td><b>Library Manager sends </b>
<td><b>Mover Sends</b>
<tr>
<td valign=top>summon
<td>idle - ready to do work;
<br>have bound volume:busy - doing work;
<br>or have bound volume:idle - volume is mounted but no work
</table>
<table>
<td><b>Mover sends</b>
<td><b>Library Manager may respond</b>
<tr>
<td valign=top>idle_mover
<td>if work needs to be done - read/write; <br>or no_work
<tr>
<td valign=top>have_bound_volume
<td>if reads/writes pending for the volume - read/write;  <br>or if no work - unbind_volume
<tr>
<td>unilateral_unbind
<td>no work
</table>
<p>
<table>
<td valign=top><b>Library Manager has just responded</b>
<td valign=top><b>Mover sends</b>
<td valign=top><b>Library Manager presumes</b>
<tr>
<td valign=top>read or...<br>write
<td valign=top>idle_mover
<td valign=top>Mover crashed and was re-started
<tr>
<td valign=top>
<td valign=top>have_bound_volume
<td valign=top>look for work on that volume<br>
    if work, give it<br>
    if none, unbind_volume
<tr>
<td valign=top>
<td valign=top>unilateral_unbind
<td valign=top>update Suspected Volumes List and respond with no_work
<tr>
<td valign=top>acknowledged a...<br>unilateral unbind or..<br>idle Mover <br>
no_work
<td valign=top>idle_mover
<td valign=top>Mover is available for work, If more work available, bind a
    volume
<tr>
<td valign=top>
<td valign=top>have_bound_volume
<td valign=top>it has restarted, the Mover had a volume from a previous
    instance of me, tell it to unbind
<tr>
<td valign=top>
<td valign=top>unilateral_unbind
<td valign=top>no work
</table>

Note that if a Mover should crash holding a volume, the worst that can
happen is that the Library Manager will be unable to schedule work for
that volume. If the physical library has more than one drive, the system
should be able to continue servicing requests.
<p>
<h3><a name="lm_commands">
1.3.3.3 Library Manager Query Commands
</h3>
The Library Manager supports queries that provide information about its
internal queues.
Some of these commands are general to all servers and are described elsewhere. Library Manager specific commands are:
<ul>
<li><b>getwork</b> - returns all work requests currently in the Library Manager
queues in two lists. 
The first is a list of pending work requests and the second is a list work at Movers.
<li><b>getmoverlist</b> - returns a list of the Movers currently known to this Library Manager and their status.
<li><b>get_suspect_vols</b> - returns a list of suspect volumes.
<li><b>loadmovers</b> - re(loads) list of movers assigned to specified library
     manager from configuration file.
<li><b>del_work</b> - remove work from the Library Manager queue of pending
     works
<li><b>change_priority</b> - change work priority in the queue of pending
     works
<li><b>get_del_dismount</b> - get list of works in the delayed dismount list
     
A description and the purpose of this list has been discussed above. 
This list contains volumes requests which have failed but are retryable.
</ul>
The format of these lists are python dictionaries.  Other programs retrieve these lists and format them
for presentation.
     Sample output from these commands:<br><br>
<b>getwork</b>
<pre>
$ ecmd lmc --getwork sphinxdisk.library_manager
[{'callback_addr': ('131.225.81.23', 7600),
  'encp': {'adminpri': -1,
           'agetime': 0,
           'basepri': 1,
           'curpri': 1,
           'delayed_dismount': 0,
           'delpri': 0},
  'fc': {'bfid': '91548494800000L',
         'complete_crc': 2048910256,
         'external_label': 'flop1',
         'location_cookie': '000000063488',
         'pnfsid': '000200000000000000514A98',
         'sanity_cookie': (9045, 2048910256),
         'size': 9045},
  'lm': {'address': ('131.225.81.23', 7503)},
  'retry_cnt': 0,
  'status': ('ok', None),
  'times': {'t0': 915731751.891, 'job_queued': 915731758.979},
  'unique_id': 'sphinx.fnal.gov-915731758.238293-3793',
  'vc': {'blocksize': 512,
         'capacity_bytes': 1400000L,
         'declared': 915469931.313,
         'eod_cookie': '000000108032',
         'external_label': 'flop1',
         'file_family': 'sphinx',
         'first_access': 915469958.425,
         'last_access': 915728933.0,
         'library': 'sphinxdisk',
         'media_type': 'diskfile',
         'remaining_bytes': 1291968L,
         'status': ('ok', None),
         'sum_rd_access': 0,
         'sum_rd_err': 0,
         'sum_wr_access': 0,
         'sum_wr_err': 0,
         'system_inhibit': 'none',
         'user_inhibit': 'none',
         'wrapper': 'cpio'},
  'work': 'read_from_hsm',
  'wrapper': {'fullname':'/usr/hppc_home/moibenko/enstore_test/enstore/src/tst/
admin_clerk_client.pyc',
              'gid': 5440,
              'gname': 'hppc',
              'inode': 0,
              'machine': ('Linux',
                          'sphinx.fnal.gov',
                          '2.0.35',
                          '#1 Thu Jul 23 14:01:04 EDT 1998',
                          'i686'),
              'major': 0,
              'minor': 5,
              'mode': 33268,
              'pnfsFilename': '/pnfs/enstore/sphinx/t1/admin_clerk_client.pyc',
              'pstat': (33204,
                        38881944,
                        5,
                        1,
                        6849,
                        5440,
                        9045,
                        915484948,
                        915484948,
                        915485267),
              'rmajor': 0,
              'rminor': 0,
              'sanity_size': 65535,
              'size_bytes': 9045,
              'uid': 6849,
              'uname': 'moibenko'}},
 {'callback_addr': ('131.225.81.23', 7600),
  'encp': {'adminpri': -1,
           'agetime': 0,
           'basepri': 1,
           'curpri': 1,
           'delayed_dismount': 0,
           'delpri': 0},
  'fc': {'bfid': '91548792000000L',
         'complete_crc': -1493930591,
         'external_label': 'flop1',
         'location_cookie': '000000073216',
         'pnfsid': '000200000000000000514B40',
         'sanity_cookie': (4538, -1493930591),
         'size': 4538},
  'lm': {'address': ('131.225.81.23', 7503)},
  'retry_cnt': 0,
  'status': ('ok', None),
  'times': {'t0': 915731751.891, 'job_queued': 915731759.085},
  'unique_id': 'sphinx.fnal.gov-915731758.243841-3793',
  'vc': {'blocksize': 512,
         'capacity_bytes': 1400000L,
         'declared': 915469931.313,
         'eod_cookie': '000000108032',
         'external_label': 'flop1',
         'file_family': 'sphinx',
         'first_access': 915469958.425,
         'last_access': 915728933.0,
         'library': 'sphinxdisk',
         'media_type': 'diskfile',
         'remaining_bytes': 1291968L,
         'status': ('ok', None),
         'sum_rd_access': 0,
         'sum_rd_err': 0,
         'sum_wr_access': 0,
         'sum_wr_err': 0,
         'system_inhibit': 'none',
         'user_inhibit': 'none',
         'wrapper': 'cpio'},
  'work': 'read_from_hsm',
  'wrapper': {'fullname':'/usr/hppc_home/moibenko/enstore_test/enstore/src/tst/
backup.py',
              'gid': 5440,
              'gname': 'hppc',
              'inode': 0,
              'machine': ('Linux',
                          'sphinx.fnal.gov',
                          '2.0.35',
                          '#1 Thu Jul 23 14:01:04 EDT 1998',
                          'i686'),
              'major': 0,
              'minor': 5,
              'mode': 33268,
              'pnfsFilename': '/pnfs/enstore/sphinx/t1/backup.py',
              'pstat': (33204,
                        38882112,
                        5,
                        1,
                        6849,
                        5440,
                        4538,
                        915487920,
                        915487920,
                        915488239),
              'rmajor': 0,
              'rminor': 0,
              'sanity_size': 65535,
              'size_bytes': 4538,
              'uid': 6849,
              'uname': 'moibenko'}},]

[{'callback_addr': ('131.225.81.23', 7600),
  'encp': {'adminpri': -1,
           'agetime': 0,
           'basepri': 1,
           'curpri': 1,
           'delayed_dismount': 0,
           'delpri': 0},
  'fc': {'bfid': '91548494100000L',
         'complete_crc': 1614017314,
         'external_label': 'flop1',
         'location_cookie': '000000055296',
         'pnfsid': '0002000000000000005149F8',
         'sanity_cookie': (7581, 1614017314),
         'size': 7581},
  'lm': {'address': ('131.225.81.23', 7503)},
  'mover': 'sphinxdisk.mover',
  'retry_cnt': 0,
  'status': ('ok', None),
  'times': {'in_queue': 1.77947795391,
            'lm_dequeued': 915731760.655,
            't0': 915731751.891},
  'unique_id': 'sphinx.fnal.gov-915731758.236400-3793',
  'vc': {'blocksize': 512,
         'capacity_bytes': 1400000L,
         'declared': 915469931.313,
         'eod_cookie': '000000108032',
         'external_label': 'flop1',
         'file_family': 'sphinx',
         'first_access': 915469958.425,
         'last_access': 915728933.0,
         'library': 'sphinxdisk',
         'media_type': 'diskfile',
         'remaining_bytes': 1291968L,
         'status': ('ok', None),
         'sum_rd_access': 0,
         'sum_rd_err': 0,
         'sum_wr_access': 0,
         'sum_wr_err': 0,
         'system_inhibit': 'none',
         'user_inhibit': 'none',
         'wrapper': 'cpio'},
  'work': 'read_from_hsm',
  'wrapper': {'fullname':'/usr/hppc_home/moibenko/enstore_test/enstore/src/tst/
admin_clerk_client.py',
              'gid': 5440,
              'gname': 'hppc',
              'inode': 0,
              'machine': ('Linux',
                          'sphinx.fnal.gov',
                          '2.0.35',
                          '#1 Thu Jul 23 14:01:04 EDT 1998',
                          'i686'),
              'major': 0,
              'minor': 5,
              'mode': 33268,
              'pnfsFilename': '/pnfs/enstore/sphinx/t1/admin_clerk_client.py',
              'pstat': (33204,
                        38881784,
                        5,
                        1,
                        6849,
                        5440,
                        7581,
                        915484942,
                        915484942,
                        915485261),
              'rmajor': 0,
              'rminor': 0,
              'sanity_size': 65535,
              'size_bytes': 7581,
              'uid': 6849,
              'uname': 'moibenko'}}]

</pre>
<b>getmoverlist</b>
<pre>
$ ecmd lmc --getmoverlist sphinxdisk.library_manager
[{'address': ('131.225.81.23', 7508),
  'last_checked': 915731762.917,
  'mover': 'sphinxdisk.mover',
  'state': 'idle_mover',
  'summon_try_cnt': 0,
  'tr_error': 'ok'}]
</pre>
<b>get_suspect_vols</b> 
<pre>
$ ecmd lmc --get_suspect_vols sphinxdisk.library_manager
[{'external_label': 'flop1', 'movers': ['sphinxdisk.mover']}]
</pre>
<b>loadmovers</b>
<pre>
$ ecmd lmc --loadmovers happydisk.library_manager
{'movers': [{'address': ('131.225.84.122', 7509),movers happdisk.library_manager 
             'external_label': 'flop1',
             'file_family': 'happy.cpio_custom',dmovers sphindisk.library_manager
             'last_checked': 922226963.097,--loadmovers sphinxdisk.library_manager
             'mover': 'happydisk1.mover',
             'state': 'idle_mover',
             'summon_try_cnt': 0,
             'tr_error': 'ok'},
            {'address': ('131.225.84.122', 7511),
             'external_label': 'flop1',
             'file_family': 'happy.cpio_custom',
             'last_checked': 922226968.162,
             'mover': 'happydisk3.mover',
             'state': 'idle_mover',
             'summon_try_cnt': 0,
             'tr_error': 'ok'},
            {'address': ('131.225.84.122', 7513),
             'external_label': 'flop1',
             'file_family': 'happy.cpio_custom',
             'last_checked': 922226922.662,
             'mover': 'happydisk5.mover',
             'state': 'idle_mover',
             'summon_try_cnt': 0,
             'tr_error': 'ok'},
            {'address': ('131.225.84.122', 7510),
             'external_label': 'flop1',
             'file_family': 'happy.cpio_custom',
             'last_checked': 922226929.446,
             'mover': 'happydisk2.mover',
             'state': 'idle_mover',
             'summon_try_cnt': 0,
             'tr_error': 'ok'},
            {'address': ('131.225.84.122', 7508),
             'external_label': 'flop1',
             'file_family': 'happy.cpio_custom',
             'last_checked': 922226947.063,
             'mover': 'happydisk.mover',
             'state': 'idle_mover',
             'summon_try_cnt': 0,
             'tr_error': 'ok'},
            {'address': ('131.225.84.122', 7512),
             'external_label': 'flop1',
             'file_family': 'happy.cpio_custom',
             'last_checked': 922226954.994,
             'mover': 'happydisk4.mover',
             'state': 'idle_mover',
             'summon_try_cnt': 0,
             'tr_error': 'ok'}],
 'status': ('ok', None),

</pre>
<b>del_work</b>
<pre>
$ ecmd lmc --del_work rip6.library_manager rip8.fnal.gov-922223453.580484-30688
ID rip8.fnal.gov-922223453.580484-30688
{'status': ('ok', 'Work deleted')}
</pre>
<b>change_priority</b>
<pre>
no example
</pre>
<b>get_del_dismount</b>
<pre>
no example
</pre>

<hr>
<h3><a name="mover">
1.3.4 Mover
</h3>
A Mover task is bound to a single drive, and seeks to use that drive to service
read and write requests.  It communicates with the Library Manager in a
defined protocol, as just described.
<p>
The Mover is responsible for efficient data movement and as such is an
integral part of the system.  The architecture allows for performance critical
code to be written in C thus allowing efficient access to fundamental OS
features such as forking with minimal to no language overhead.
<p>
Although a Mover is bound to a drive, a drive may serve more than one
virtual library, i.e., the Mover has a dynamic list of of Library Managers
that it is supposed to service.  This has two benefits.
First, since a Library Manager handles only one type of media, a drive which
handles multiple types of media (i.e. different capacity media) can be shared
without a static partitioning of the system.
Second, if we are partitioning resources in a library, we can assign a Library
Manager to each type of use.  For example, suppose Group A and Group B want to share
the capacity of a library.
Suppose half the tapes belong to Group A  and the other half to Group B. We want to guarantee that
Group A have one third of the tape drives, Group B have one third, and the last third
be shared.  The Movers can be configured to do this easily.  And with some slight
changes, this is how we can guarantee resources to data acquisition.
<p>

There has been a request to duplicate (write to two tapes) critical
data. This feature had been discussed but not implemented as a specific
method of implementation has not been decided upon. The following are
among the possible implementations:
<ul>
  <li> Assign two tape drives to one Mover.  If the Mover has a list of two
       volumes in the write_to_hsm response, the Mover binds both volumes
       and writes to both drives.  This Mover could be give a single volume
       for "normal" data writing.
  <li> Have the Library Manager summon two Movers and tell one it is a
       master and the other it is a slave. The master receives data from
       the user and in addition to writing to it's tape drive, it also sends
       the data on to the slave Mover. The slave Mover receives data from
       the master Mover.
</ul>

The "local mover" feature allows the mover process to
read/write the user data file directly, if the file/directory is accessible
and on a filesystem local to the computer on which the mover process is
running. By default, this feature is enabled. It can be controlled via
the "ecmd" command. For example:
<p>
<center>
ecmd mvc --local_mover=0 fndaprdisk.mover
</center>

<p>
<!-- ----------------------------------------------------->
When the Mover starts up, the 'idle_mover' request/command is sent to each
Library Manager configured and the responses from the Library Managers are
acted upon.  After the startup, the Mover waits until it is 'summoned' by a
Library Manager.

<p>
When a Mover is summoned by a Library Manager, it will send one of three
request/commands to the Library Manager that summoned the Mover:
<ol>
  <li> idle_mover
  <li> have_bound_volume, idle
  <li> have_bound_volume, busy
</ol>

When the Mover is busy, the Library Manager should respond with 'no_work.'
Otherwise, the Library Manager can respond with 'no_work,'
'read_from_hsm,' or 'write_to_hsm.'

When the Mover receives 'read_from_hsm' or 'write_to_hsm' it forks a
subprocess which handles the transfer utilizing a shared memory buffer for
both data transfer and communication with parent process. The
main Mover process can read shared memory locations to get the status of
the transfer.  This design will allow for easy implementation of DESY's
"slow user network abort" feature.  The parent process can watch the
transfer processes and determine (at some point early in the transfer) if
the tape drive is being starved or throttled such that the tape drive
resource is being abused.

The first thing the transfer process does is check to see if the waiting
<em>encp</em> is responsive. This involves contacting <em>encp</em> on the designated TCP
control port and sending along the TCP port designation for the data transfer.
If <em>encp</em> is responsive, the Mover proceeds with making
sure the proper volume is loaded in it's tape drive.

<p>
Reads -- Once a volume is bound the Mover may read a volume and send data
to a waiting <em>encp</em> program.
        The steps are:
<ol>
<li> Using the file_location_cookie, space to beginning of data.
<li> Read any wrappering information that precedes the actual data.
<li> Fork a process that reads and crc's the data from the volume verifying
     the sanity crc and placing the
     data in a 4 MB shared memory buffer.
<li> Write data from the shared memory to the user.
<li> Read any wrappering information that comes after the data.
<li> Close the data port.
<li> Tell the user done and all is well.
<li> Close the control port.
</ol>

<p>
Writes -- Once a volume is bound the Mover may receive data and write it to
the volume.
        The steps are:
<ol>
<li> Mark the volume as "writing". That will cause the volume to
     not be selected for subsequent writes, should we crash.
<li> Using the eod_space_cookie, space to end of volume. Try
     to verify that we are actually at the end of volume.
<li> Write any wrappering information that precedes the data.
<li> Fork a process that reads and crc's data from the user calculating the
     sanity crc and placing the data in a 4 MB shared memory buffer.
<li> Write data from the shared memory to the tape device.
<li> Close the data port.
<li> Write any wrappering information after the data.
<li> Compute new eod_cookie and tell Volume Clerk that the
     volume is writable. Update remaining bytes as well.
<li> Compute the file location cookie, and tell the bit
     File Clerk about the new file. Get a bit file ID in return.
<li> Give the bit file ID to <em>encp</em>. We are done.
</ol>

If any errors occur while reading or writing a volume, an attempt is made
to characterize them as either media or drive.  Depending upon the error, the
Mover will issue either have_bound_volume or unilateral_unbind to the
Library Manager.
This is discussed more completely in the section on Error control.
If the user drops the control tcp channel unilaterally, the Mover assumes he has
aborted the transfer.

If all is well with the entire transfer, the Mover issues a
have_bound_volume to the Library Manager and waits for further instructions.


<p>

<h4><a name="mover_cmds">
1.3.4.1 Command Line Control of the Mover
</h4>

The Mover is started and controlled through a command line interface using
ecmd. Option commands for "ecmd mvc [--option_command] <mover>" include the
general option commands
supported by all other servers.
Additionally the "status" option command
is supported and produces the following:
<br><p>
$ ecmd mvc --status fndaprdisk.mover<br>
{'wr_bytes': 6398896, 'rd_bytes': 6398896, 'no_xfers': 11, 'mode': 'w',
'bytes_to_xfer': 6398896, 'crc_func': '<built-in function ECRC>',
'state': 'idle', 'status': ('ok', None)}
<br>where
<dl>
<dt>wr_bytes
     <dd> the number of bytes written to the tape device when 'mode' is 'w'
	  else the number of bytes written to the user device.
<dt>rd_bytes
     <dd> the number of bytes read from the user device when 'mode' is 'r'
	  else the number of bytes read from the tape device.
<dt>no_xfers
     <dd> the number of completed transfers.
<dt>mode
     <dd> 'r' for reading from HSM, 'w' for writing to HSM.
<dt>bytes_to_xfer
     <dd> number of bytes to be transfer for current transfer if state is
	  'busy' or the last transfer is state is idle.
<dt>crc_func
     <dd>active crc function.
<dt>state
     <dd>'idle' if no transfer active, else 'busy.'
<dt>status
     <dd>should always be: ('ok', None)
</dl>

<h4><a name="mover_config">
1.3.4.2 Mover Config File Values
</h4>
<center><TABLE BORDER COLS=4 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>DICTIONARY ELEMENT</B></TD>
<TD NOSAVE><B>DEFINITION</B></TD>
<TD NOSAVE><B>DEFAULT</B></TD>
<TD NOSAVE><B>EXAMPLE VALUE</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>host</TD>
<TD NOSAVE>node where Mover runs</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>hppc</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>port</TD>
<TD NOSAVE>UDP port for Mover communication</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>7516</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>logname</TD>
<TD NOSAVE>ascii value used for id in messages to Log Server</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>FMOV</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>library</TD>
<TD NOSAVE>list of libraries that the Mover will contact when it starts up.</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>['fndaprdisk.library_manager']</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>media_changer</TD>
<TD NOSAVE>the name of the Media Changer server that will be communicated
with in order to load and unload tape cartridges.</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>'fndaprdisk.media_changer</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>mc_device</TD>
<TD NOSAVE>a device name or number to include with communications with the
Media Changer.</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>1</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>do_eject</TD>
<TD NOSAVE>used when testing stand alone tape drive (no robot).</TD>
<TD NOSAVE>'yes'</TD>
<TD NOSAVE>'no'</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>driver</TD>
<TD NOSAVE>the HSM driver</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>'FTTDriver'</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>device</TD>
<TD NOSAVE>device name used for driver device access. **</TD>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>'/dev/rmt/tps2d2n' (make sure this is a no-rewind device)</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>norestart</TD>
<TD NOSAVE>do not restart this server if it crashes</TD>
<TD NOSAVE>do a restart</TD>
</TR>
</TABLE></center>
<p>
** The mover process must have read and write access to the tape pseudo devices.
<p>
Linux tape devices are called /dev/nstX by default where X is Xth
serial device found on the system.  X can change if devices are added or removed
on the bus.   A script in the FTT product etc/mkscsidev.Linux creates
the files /dev/rmt/tpsNdMn where N is the bus number and M is the scsi
id of the device.  N and M do not change if the bus changes  (unless
scsi ids or controllers are changed) and so the enstore
configuration files do not need to change.  $FTT_DIR/etc/mkscsidev.Linux   
should be run at boot time; normally via /etc/rc.d/rc.local.
A sample rc.local:
<pre>
echo "Making scsi tape devices"
. /usr/local/etc/setups.sh
setup ftt
$FTT_DIR/etc/mkscsidev.Linux

chmod 0666 /dev/rmt/*
chmod 0666 /dev/sc/*
</pre>
<p>
<hr>
<h3><a name="config_server">
1.3.5 Configuration Server
</h3>
The Configuration Server maintains and distributes all information about
system configuration, such as the location and parameters of each server.
Upon startup, each server asks the Configuration Server for the information 
pertaining to itself (e.g. the location of any other server with which to 
communicate).  New configurations can be
loaded into the Configuration Server without disturbing the current running
system. Configurations are stored in a file called the Enstore configuration
file in Python dictionary format.  An example of this file is given below:<br>
<p>
<pre>
configdict['blocksizes'] = { 'diskfile'  : 512, \
                             'redwood'   : 131072, \
                             'floppy'    : 512, \
                             'cassette'  : 512, \
                             'cartridge' : 512, \
                             'exabyte'   : 131072, \
                             '8MM'       : 131072, \
                             'DECDLT'    : 131072 }

configdict['file_clerk']   = { 'host':'rip6', 'port':7501, 'logname':'FILSRV' }
configdict['volume_clerk'] = { 'host':'rip6', 'port':7502, 'logname':'VOLSRV' }
configdict['alarm_server'] = { 'host':'rip10', 'logname':'ALMSRV', \
                               'port'  : 7503 }

configdict['log_server']   = { 'host':'rip6', 'port':7504, \
                               'log_file_path':'/rip6a/enstore/log' }
configdict['database']     = { 'db_dir':'/rip6a/enstore/db' }
configdict['backup']       = { 'host':'rip6', 'dir':'/rip6a/enstore/db_backup'}

configdict['inquisitor']   = { 'host':'rip6', 'port':7505, 'logname':'INQSRV', \
                               'timeout':10, 'alive_rcv_timeout': 5, \
                               'alive_retries':1, \
                               'ascii_file':'/rip6a/enstore/inquisitor/', \
                               'html_file':'/fnal/ups/prd/www_pages/enstore/', \
                               'default_server_timeout': 15, \
                               'timeouts' : { 'ait.library_manager': 15} }

configdict['rip6.library_manager']  = { 'host':'rip5', 'port':7506, \
                                        'logname':'RP6LBM' }
configdict['dlt.library_manager']   = { 'host':'rip5', 'port':7509, \
                                        'logname':'DLTLBM' }
configdict['rip6.media_changer']    = { 'host':'rip6',  'port':7512, \
                                        'logname':'R6MC  ', \
                                        'type':'RDD_MediaLoader'  }
configdict['de13.media_changer']    = { 'host':'rip10', 'port':7517, \
                                        'logname':'DE13MC', \
                                        'type':'EMASS_MediaLoader' }
configdict['rip6.mover']    = { 'host':'rip6', 'port':7525, 'logname':'R6MOV ', \
                                'library':'rip6.library_manager', \
                                'device':'/rip6a/rip6/rip6.fake', \
                                'driver':'RawDiskDriver', \
                                'mc_device':'-1', \
                                'media_changer':'rip6.media_changer' }
configdict['DE13DLT.mover'] = { 'host':'rip1', 'port':7526, 'logname':'DE13MV', \
                                'library':'dlt.library_manager', \
                                'device':'/dev/rmt/tps2d1n', \
                                'driver':'FTTDriver', \
                                'mc_device':'DE13', \
                                'media_changer':'de13.media_changer' }
</pre>
<p>
The keys/values used in the above example are typical of a running system.
The <em>blocksizes</em> dictionary element specifies the size of a block on the
different devices known to the system. The <em>database</em> dictionary element
specifies where the Enstore database files are located.  The <em>backup</em>
dictionary element specifies the node and directory of where the database backups
will go.
<p>
Please see the individual server sections for more in depth descriptions of
all the server keywords.
<h4><a name="config_server_cmds">
1.3.5.1 Command Line Control of the Configuration Server
</h4>
Configuration Server functionality may be controlled through a command line 
interface using
<B>ecmd</B>.  A summary of the supported commands is given below.  In addition
to the following commands, the Configuration Server command line interface 
supports the general commands supported by all other servers.
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>FUNCTION</B></TD>
<TD NOSAVE><B>COMMAND</B></TD>
<TD NOSAVE><B>OUTPUT</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>load the specified Enstore config file into the configuration server</TD>
<TD NOSAVE>ecmd cc --config_file=/path/to/config_file --load</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>output the currently loaded Enstore configuration file</TD>
<TD NOSAVE>ecmd cc --dict</TD>
<TD NOSAVE>(same as the example in the previous section)</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>output the keys in the currently loaded Enstore configuration file</TD>
<TD NOSAVE>ecmd cc --get_keys</TD>
<TD NOSAVE><pre>
['DE13DLT.mover',
 'alarm_server',
 'backup',
 'blocksizes',
 'database',
 'de13.media_changer',
 'dlt.library_manager',
 'file_clerk',
 'inquisitor',
 'log_server',
 'rip6.library_manager',
 'rip6.media_changer',
 'rip6.mover',
 'volume_clerk']
</pre>
</TD>
</TR>
</TABLE></center>
<P>

<hr>
<h3><a name="log_server">
1.3.6 Log Server
</h3>
The Log Server receives messages from other processes and logs them into
formatted log files.
Basically, these messages are transactional records.
Log files are labeled by dates.
At midnight each day, the currently opened log file gets closed and another
one is opened. Below is an excerpt from the log file:
<pre>
10:03:42 sphinx.fnal.gov 006849 moibenko I FILC  File Clerk (re)starting
10:03:46 sphinx.fnal.gov 006849 moibenko I HLIBM  Library Manager sphinxdisk.library_manager(re)starting
10:03:50 sphinx.fnal.gov 006849 moibenko I HMC  Media Changersphinxdisk.media_changer(re) starting
10:03:55 sphinx.fnal.gov 006849 moibenko I HMOV  Mover starting - contacting libman
10:03:59 sphinx.fnal.gov 006849 moibenko I ADMC  Admin Clerk (re)starting
10:09:34 sphinx.fnal.gov 006849 moibenko I HLIBM  read Q'd /pnfs/enstore/sphinx/ut1/mover.py -> ........
10:09:34 sphinx.fnal.gov 006849 moibenko I HLIBM  read_from_hsm work on vol=flop1 ..........
10:09:34 sphinx.fnal.gov 006849 moibenko I HMOV  READ_FROM_HSM start{'times': ..........
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  Performing precautionary offline/eject.........
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  Completed  precautionary offline/eject.......
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  Requesting media changer load {' ............
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  Media changer load status('ok', None)
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  Requesting software mount flop1 ........
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  Software mount complete flop1 ........
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  WRAPPER.READ........
10:09:35 sphinx.fnal.gov 006849 moibenko I HMOV  READ DONE{'unique_id':  .............
</pre>
Fields in a log file are:
<ul>
<li>time
<li>node name
<li>user id
<li>user name
<li>severity indicator (I - information, E - Error)
<li>client abbreviation
<li>message
</ul>
<hr>
<h3><a name="media_changer">
1.3.7 Media Changer
</h3>

The Media Changer mounts and dismounts the media into and from the drive according to a request from
the Mover. One Media Changer can serve multiple drives and libraries. When the drives are in the robot, the
Media Changer is the interface to the robotic software. 
<p>
The Media Changer issues multiple simultaneous commands by forking processes
that do the work.  A Media Changer parameter, MAXWORK, limits the maximum number of
simultaneous outstanding operations.   If the Media Changer receives
mount/dismount requests while there are  MAXWORK unfinished operations then
the new operations are ignored, the Mover request will time out, and the
Mover will reissue the mount/dismount request.
<p>
The reason for the MAXWORK parameter is because when the EMASS robot has an operation for ten minutes
it reports a timeout failure even though it eventually finishes the operation.  The MAXWORK parameter
can be set to 0 when it is necessary to perform work on a robot.
<p>
The Media Changer returns three status values:
<ul>
<li>A canonical translation of the underlying status with the values: ok , TAPE, DRIVE,BAD 
<li>The status returned by the underlying agent
<li>A text description returned by the underlying agent
</ul>
<p>
The Media Changer and the Media Changer Client support the following requests:
<ul>
<li>maxwork=&lt max simultaneous operation&gt 
<li>getwork
</ul>
<p>
The Media Changer mounting agents:
<ul>
<li>EMASS/Grau robot
<li>STK robot
<li>null Media Changer used by the disk Movers and stand alone tape drives
<li>OCS operator assisted mounts - to be implemented
</ul>
<h3>
Tape Cleaning
</h3>
The Media Changer is not directly involved with tape cleaning.  The EMASS AMU and the
STK ACSLS tape library systems keep tape drive usage statistics and automatically
mount cleaning tapes. The Media Changer will not issue mount requests during the cleaning process.
<h3>
Tape statistics
</h3>
The Media Changer does not keep tape drive or cartridge statistics.  Summary statistics
are not very useful and the media does not run on the machine connected to
the tape drive. The overall tape and drive statistics repository is OCS,
and a Enstore interface has not yet been designed.
<p>
Enstore writes detail error statistics to its log when a file is closed. A
separate mount/dismount log can be easily separated from the main log.



<hr>
<h3><a name="inquisitor">
1.3.8 Inquisitor
</h3>
The Inquisitor obtains information from the Enstore system and creates the 
following reports using this information:<BR>
<UL>
<LI>an <a href="#inquisitor_ascii_status">ascii file</a> continuously recording the Enstore system status
<LI>an <a href="#inquisitor_html_status">html file</a> recording the latest status snapshot of the Enstore system
<LI>an <a href="#inquisitor_encp_status">html file</a> recording a snapshot of a history of <em>encp</em> commands 
<LI>a <a href="#inquisitor_plot_ita">plot of individual transfer activity</a>
<LI>a <a href="#inquisitor_plot_btd">plot of total bytes transferred/day</a>
<LI>a <a href="#inquisitor_plot_mph">plot of mounts per hour</a>
<LI>a <a href="#inquisitor_plot_mlat">plot of mount latencies</a>

</UL>

The reports are updated periodically based on 
<a href="#inquisitor_config">timeout values</a> in the Enstore
config file directing the Inquisitor to gather
each servers' information on a specific time frequency.  Each Enstore server may
have its own unique timeout value specified for it.  For example, the Inquisitor
may be instructed to gather information from the file_clerk every 60 seconds but
from the log_server every 135 seconds.  However the plots are not updated
automatically and may be updated by a user initiated command or by a cron job
for example.  The information for plotting is obtained from the log files.
<p>
In addition to the above reports, the Inquisitor will make available on the
web, the contents of the configuration file, all current Enstore log files and
any additional log files useful to the user.
<p>
The Inquisitor will listen for command
line requests sent to it and will periodically check to see if it is time to
update information for any of the servers that it is monitoring.  If so, then the
server in question is contacted and the resulting information is formated for
output to the various reports. The possible information gathered from each of the
servers and which report it ends up in are listed below.  In addition to
gathering information from each Enstore server, the Inquisitor will collect
information from the log files on <em>encp</em> commands and report on the blocksizes
set in the Enstore config file.

<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>SERVER</B></TD>
<TD NOSAVE><B>INFORMATION GATHERED</B></TD>
<TD NOSAVE><B>REPORTS EFFECTED</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE>blocksizes</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>&nbsp;</TD>
<TD NOSAVE><em>encp</em> command history</TD>
<TD NOSAVE>continuous Ascii status file and<br><em>encp</em> html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Alarm Server</TD>
<TD NOSAVE>alive status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Configuration Server</TD>
<TD NOSAVE>alive status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>File Clerk</TD>
<TD NOSAVE>alive status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Inquisitor</TD>
<TD NOSAVE>alive status<br>refetch config file from config server</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Library Manager(s)</TD>
<TD NOSAVE>alive status<br>suspect volume list<br>mover list<br>work queues</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Log Server</TD>
<TD NOSAVE>alive_status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Media Changer(s)</TD>
<TD NOSAVE>alive status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Mover(s)</TD>
<TD NOSAVE>alive status<br>Mover activity status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>Volume Clerk</TD>
<TD NOSAVE>alive status</TD>
<TD NOSAVE>continuous Ascii status file and<br>html snapshot file</TD>
</TR>
</TABLE></center>
<P>

Since the Inquisitor requests a new config file from the config_server 
periodically, it is possible to dynamically change the way information is
displayed and the type of information that is displayed without restarting the
Inquisitor.

<h4><a name="inquisitor_cmds">
1.3.8.1 Command Line Control of the Inquisitor 
</h4>
Inquisitor functionality may be controlled through a command line interface using
<B>ecmd</B>.  A summary of the supported commands is given below.  In addition
to the following commands, the Inquisitor command line interface supports the
general commands supported by all other servers.  Any particular server name
mentioned in the table below may be replaced by any legal server name.
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>FUNCTION</B></TD>
<TD NOSAVE><B>COMMAND</B></TD>
<TD NOSAVE><B>OUTPUT</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>get the maximum size of the ascii status file</TD>
<TD NOSAVE>ecmd ic --get_max_ascii_size</TD>
<TD NOSAVE>maximum ascii size</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>get the maximum number of <em>encp</em> status lines displayed</TD>
<TD NOSAVE>ecmd ic --get_max_encp_lines</TD>
<TD NOSAVE>maximum number of <em>encp</em> lines</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>get the html status file auto refresh rate</TD>
<TD NOSAVE>ecmd ic --get_refresh</TD>
<TD NOSAVE>refresh time</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>get the frequency for monitoring the Volume Clerk</TD>
<TD NOSAVE>ecmd ic --get_timeout volume_clerk</TD>
<TD NOSAVE>volume_clerk timeout value</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>get the frequency for looking for work</TD>
<TD NOSAVE>ecmd ic --get_timeout</TD>
<TD NOSAVE>Inquisitor wakeup time</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the maximum size of the ascii status file</TD>
<TD NOSAVE>ecmd ic --max_ascii_size=40000</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the maximum number of <em>encp</em> status lines displayed</TD>
<TD NOSAVE>ecmd ic --max_encp_lines=13</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots</TD>
<TD NOSAVE>ecmd ic --plot</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots, keep the data files and put them in /tmp.</TD>
<TD NOSAVE>ecmd ic --plot --keep --keep_dir=/tmp</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots and put the plot files in /tmp.</TD>
<TD NOSAVE>ecmd ic --plot --out_dir=/tmp</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots and use the log files located in the specified directory</TD>
<TD NOSAVE>ecmd ic --plot --logfile_dir=/tmp/logs</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots and only plot information after the specified start_time</TD>
<TD NOSAVE>ecmd ic --plot --start_time=1998-12-25</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots and only plot information before the specified stop_time</TD>
<TD NOSAVE>ecmd ic --plot --stop_time=1998-12-31</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>recreate the Inquisitor plots and only plot information between the specified times</TD>
<TD NOSAVE>ecmd ic --plot --start_time=1998-12-01 --stop_time=1998-12-31</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the html status file auto refresh rate</TD>
<TD NOSAVE>ecmd ic --refresh=60</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the frequency for monitoring the alarm_server to the value in the config file</TD>
<TD NOSAVE>ecmd ic --reset_timeout alarm_server</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the frequency for looking for work to the value in the config file</TD>
<TD NOSAVE>ecmd ic --reset_timeout</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the frequency for monitoring the file_clerk</TD>
<TD NOSAVE>ecmd ic --timeout=55 file_clerk</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>reset the frequency for looking for work</TD>
<TD NOSAVE>ecmd ic --timeout=10</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>close the current ascii status file and open a new one</TD>
<TD NOSAVE>ecmd ic --timestamp</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>monitor the Log Server now</TD>
<TD NOSAVE>ecmd ic --update log_server</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>monitor all the servers now</TD>
<TD NOSAVE>ecmd ic --update</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
</TABLE></center>

<h4><a name="inquisitor_config">
1.3.8.2 Inquisitor Config File Values
</h4>
The Inquisitor looks for the following values in the Inquisitor section of the
Enstore config file. The default value is used if the dictionary element is not
found. Dictionary elements with no default must be specified in the Enstore 
config file.  All frequencies are specified in seconds.<BR>
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>DICTIONARY ELEMENT</B></TD>
<TD NOSAVE><B>DEFINITION</B></TD>
<TD NOSAVE><B>DEFAULT</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>alive_rcv_timeout</TD>
<TD NOSAVE>seconds to wait for response to alive request</TD>
<TD NOSAVE>5</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>alive_retries</TD>
<TD NOSAVE>times to retry alive request</TD>
<TD NOSAVE>2</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>ascii_file</TD>
<TD NOSAVE>directory for ascii status file(s)</TD>
<TD NOSAVE>./</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>default_server_timeout</TD>
<TD NOSAVE>frequency to monitor servers not listed in <em>timeouts</em></TD>
<TD NOSAVE>60</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>host</TD>
<TD NOSAVE>node where Inquisitor runs</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>html_file</TD>
<TD NOSAVE>directory for html status files</TD>
<TD NOSAVE>./</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>logname</TD>
<TD NOSAVE>ascii value used for id in messages to Log Server</TD>
<TD NOSAVE>INQS</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>max_ascii_size</TD>
<TD NOSAVE>maximum allowed size (bytes) of ascii status file</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>max_encp_lines</TD>
<TD NOSAVE>maximum number of <em>encp</em> lines to display</TD>
<TD NOSAVE>50</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>port</TD>
<TD NOSAVE>udp port for Inquisitor communication</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>refresh</TD>
<TD NOSAVE>frequency for auto-refresh of html status page</TD>
<TD NOSAVE>120</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>robot_adic_log_dir</TD>
<TD NOSAVE>location of adic log files to point to in the Inquisitor log page (NOTE: replace 'adic' with other text to add a link to a different log directory)</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>timeout</TD>
<TD NOSAVE>frequency that Inquisitor looks for work</TD>
<TD NOSAVE>5</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>timeouts</TD>
<TD NOSAVE>dictionary of frequencies for monitoring each server</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
</TABLE></center>
<P>
In addition to the information listed above, the Inquisitor will look for the
<em>inq_timeout</em> dictionary element in each of the individual server sections.
If present, the value of this dictionary element will be used to specify the 
timeout frequency for monitoring this server.  This is the same as if the 
<em>timeouts</em>  dictionary element mentioned
above contained a dictionary element for the particular server.  For example, 
in order to monitor the file_clerk every 65 seconds, the Enstore config file 
must have one of the following in it:<BR>

<UL>
<LI>in the Inquisitor section - a dictionary element, within the <em>timeouts</em>
dictionary element, for the File Clerk set to 65
<LI>in the file_clerk section - the dictionary element <em>inq_timeout</em> set to
65
</UL>
The value in the individual server dictionary element will take precedence over
the value in the Inquisitor dictionary element.
<P>
In order to block monitoring of a particular server, set it's timeout value to 
-1.
<P>
An example Inquisitor dictionary element is given below:<BR>
<P>
<PRE>
configdict['inquisitor'] = { 'alive_rcv_timeout'  : 5,
                             'alive_retries'  : 1,
                             'ascii_file'  : '/tmp',
                             'default_server_timeout'  : 15,
                             'host'  : 'rip7',
                             'html_file'  : '/fnal/ups/prd/www_pages/enstore/',
                             'http_log_file_path'  : '/enstore/log/',
                             'logname'  : 'INQSRV',
                             'max_ascii_size'  : 100000000,
                             'port'  : 7505,
                             'robot_adic_log_dir'  : '/enstore/adiclog/',
                             'timeout'  : 10,
                             'timeouts'  : {'ait.library_manager': 15},
                             'www_host'  : 'http://rip8.fnal.gov:' }
</PRE>

<h4><a name="inquisitor_outputs">
1.3.8.3 Example Inquisitor Reports
</h4>
These examples reflect a running system on the <em>rip</em> cluster.
<h4><a name="inquisitor_ascii_status">
1.3.8.3.1 Example Ascii Status File
</h4>
This file records a continuous history of the status of the Enstore system as
monitored by the Inquisitor.  It contains the following information:<br>
<ul>
<li>block size information as recorded in the Enstore config file
<li>alive status for each server including node, port, and time
<li>Library Manager specific information
<ul>
<li>suspect volumes
<li>list of known Movers, their ports, state, last time they were summoned and
number of attempts to summon them
<li>work queue including:
<ul>
<li>assigned Mover
<li>node, node type, and port where Mover is located
<li>work that Mover is doing
<li>device label
<li>file family and file family width
<li>priorities of the work
<li>associated times
</ul>
<li>pending work queue including:
<ul>
<li>node, node type, and port where work originated
<li>work to be done
<li>file family and file family width
<li>priorities of the work
<li>associated times
</ul>
</ul>
<li>Mover specific information
<ul>
<li>number of completed transfers
<li>current state of the Mover
<li>number of bytes read and written on the last transfer (if idle)
<li>number of bytes read and written so far on the current transfer (if working)
</ul>
</ul>
<pre>
ENSTORE SYSTEM STATUS
DC03MAM.mover : timed out on (rip1, 7552) at 1999-May-27 13:50:34
                last alive at ----
DC04MAM.mover : timed out on (rip1, 7553) at 1999-May-27 13:50:34
                last alive at ----
DC05MAM.mover : timed out on (rip1, 7554) at 1999-May-27 13:50:34
                last alive at ----
DC06MAM.mover : timed out on (rip1, 7555) at 1999-May-27 13:50:34
                last alive at ----
DM07AIT.mover : timed out on (ripsgi, 7556) at 1999-May-27 13:50:34
                last alive at ----
DM08AIT.mover : timed out on (ripsgi, 7557) at 1999-May-27 13:50:34
                last alive at ----
DM09AIT.mover : timed out on (ripsgi, 7558) at 1999-May-27 13:50:34
                last alive at ----
DM10AIT.mover : timed out on (ripsgi, 7559) at 1999-May-27 13:50:34
                last alive at ----
DM11AIT.mover : timed out on (ripsgi, 7560) at 1999-May-27 13:50:34
                last alive at ----
DM12AIT.mover : timed out on (ripsgi, 7561) at 1999-May-27 13:50:34
                last alive at ----
adicr1.media_changer : alive on (rip10, 7521) at 1999-May-27 13:50:34
adicr1TOM.media_changer : alive on (rip10, 9521) at 1999-May-27 13:50:34
ait.library_manager : alive on (rip5, 7512) at 1999-May-27 13:50:34

    SUSPECT VOLUMES : NONE

    KNOWN MOVER           PORT    STATE         LAST SUMMONED        TRY COUNT
    DM12AIT.mover         7561    idle_mover    1999-May-26 00:19:39    0  
    DM08AIT.mover         7557    idle_mover    1999-May-26 00:19:39    0  
    DM11AIT.mover         7560    idle_mover    1999-May-26 00:19:39    0  
    DM07AIT.mover         7556    idle_mover    1999-May-26 00:19:39    0  
    DM10AIT.mover         7559    idle_mover    1999-May-26 00:19:39    0  
    DM09AIT.mover         7558    idle_mover    1999-May-26 00:19:39    0  

    No work at movers
    No pending work

alarm server    : alive on (rip10, 7503) at 1999-May-27 13:50:34
blocksizes      : diskfile : 512,  exabyte : 102400,  DECDLT : 102400,
                  floppy : 512,  cartridge : 512,  redwood : 102400,
                  cassette : 512,  8MM : 102400
config server   : alive on (131.225.164.14, 7500) at 1999-May-27 13:50:34
disk.library_manager : alive on (rip7, 7510) at 1999-May-27 13:50:34

    SUSPECT VOLUMES : NONE

    KNOWN MOVER           PORT    STATE         LAST SUMMONED        TRY COUNT
    disk1.mover           7530    idle_mover    1999-May-26 16:23:33    0  
    disk2.mover           7531    idle_mover    1999-May-26 16:23:32    0  

    No work at movers
    No pending work

disk.media_changer : alive on (rip7, 7520) at 1999-May-27 13:50:34
disk1.mover : alive on (rip7, 7530) at 1999-May-27 13:50:34

    Completed Transfers : 0,  Current State : idle 
    Last Transfer :  Read 0 bytes,  Wrote 0 bytes

disk2.mover : alive on (rip7, 7531) at 1999-May-27 13:50:34

    Completed Transfers : 0,  Current State : idle 
    Last Transfer :  Read 0 bytes,  Wrote 0 bytes

dlt.library_manager : alive on (rip5, 7514) at 1999-May-27 13:50:34

    SUSPECT VOLUMES : NONE

    No moverlist
    No work at movers
    No pending work

encp            : 15:44:11 on rip4.fnal.gov by bakken (Data Transfer Rate : 2.62 MB/S)
                     1073741824 bytes copied to CA2252 at a user rate of 2.08 MB/S
                  15:43:39 on rip4.fnal.gov by bakken (Data Transfer Rate : 2.62 MB/S)
                     1073741824 bytes copied to CA2258 at a user rate of 1.88 MB/S
                  15:40:36 on rip4.fnal.gov by bakken (Data Transfer Rate : 2.68 MB/S)
                     1073741824 bytes copied to CA2257 at a user rate of 1.79 MB/S
                  15:34:30 on rip4.fnal.gov by bakken (Data Transfer Rate : 2.63 MB/S)
                     1073741824 bytes copied to CA2252 at a user rate of 2.11 MB/S
                  15:34:00 on rip4.fnal.gov by bakken (Data Transfer Rate : 2.64 MB/S)
                     1073741824 bytes copied to CA2258 at a user rate of 2.03 MB/S
                  15:30:57 on rip4.fnal.gov by bakken (Data Transfer Rate : 2.67 MB/S)
                     1073741824 bytes copied to CA2257 at a user rate of 1.84 MB/S

file clerk      : alive on (rip6, 7501) at 1999-May-27 13:50:34
inquisitor      : alive on (rip7, 7505) at 1999-May-27 13:50:34
log server      : alive on (rip10, 7504) at 1999-May-27 13:50:34
mam.library_manager : alive on (rip5, 7513) at 1999-May-27 13:50:34

    SUSPECT VOLUMES : NONE

    KNOWN MOVER           PORT    STATE         LAST SUMMONED        TRY COUNT
    DC05MAM.mover         7554    idle_mover    1999-May-26 00:19:39    0  
    DC03MAM.mover         7552    idle_mover    1999-May-26 00:19:39    0  
    DC04MAM.mover         7553    idle_mover    1999-May-26 00:19:39    0  
    DC06MAM.mover         7555    idle_mover    1999-May-26 00:19:39    0  

    No work at movers
    No pending work

null.library_manager : alive on (rip7, 7511) at 1999-May-27 13:50:34

    SUSPECT VOLUMES : NONE

    KNOWN MOVER           PORT    STATE         LAST SUMMONED        TRY COUNT
    null2.mover           7533    idle_mover    1999-May-26 16:23:33    0  
    null1.mover           7532    idle_mover    1999-May-26 16:23:33    0  

    No work at movers
    No pending work

null1.mover : alive on (rip7, 7532) at 1999-May-27 13:50:34

    Completed Transfers : 0,  Current State : idle 
    Last Transfer :  Read 0 bytes,  Wrote 0 bytes

null2.mover : alive on (rip7, 7533) at 1999-May-27 13:50:34

    Completed Transfers : 0,  Current State : idle 
    Last Transfer :  Read 0 bytes,  Wrote 0 bytes

volume clerk    : alive on (rip6, 7502) at 1999-May-27 13:50:34


</pre>

<h4><a name="inquisitor_html_status">
1.3.8.3.2 Example Html Status Snapshot File
</h4>
The html snapshot file contains the last known status of the Enstore system. 
As such it will be a repeat of the last set of information in the Ascii status
file, formatted for browsing and minus the <em>encp</em> information.

<h4><a name="inquisitor_encp_status">
1.3.8.3.3 Example <em>encp</em> History Snapshot File
</h4>
Each <em>encp</em> history line contains the following information
<ul>
<li>end of transfer time
<li>node of <em>encp</em> process
<li>user running <em>encp</em>
<li>number of bytes transferred
<li>volume name
<li>data transfer rate (MB/s)
<li>user rate of transfer
</ul>
<p>
<title>Enstore Status</title>
<pre>

ENSTORE SYSTEM STATUS
</pre><P>
<CENTER><TABLE BORDER COLS=7 WIDTH="100%" NOSAVE>
<TH COLSPAN=7 VALIGN=CENTER>History of ENCP Commands</TH>
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>TIME</B></TD>
<TD NOSAVE><B>NODE</B></TD>
<TD NOSAVE><B>USER</B></TD>
<TD NOSAVE><B>BYTES</B></TD>
<TD NOSAVE><B>VOLUME</B></TD>
<TD NOSAVE><B>DATA TRANSFER RATE (MB/S)</B></TD>
<TD NOSAVE><B>USER RATE (MB/S)</B></TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>15:19:22</TD>
<TD NOSAVE>rip8.fnal.gov</TD>
<TD NOSAVE>moibenko</TD>
<TD NOSAVE>21036</TD>
<TD NOSAVE>rip6-01</TD>
<TD NOSAVE>2.47</TD>
<TD NOSAVE>0.04</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>15:18:59</TD>
<TD NOSAVE>rip8.fnal.gov</TD>
<TD NOSAVE>moibenko</TD>
<TD NOSAVE>21036</TD>
<TD NOSAVE>rip6-01</TD>
<TD NOSAVE>0.664</TD>
<TD NOSAVE>0.0322</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>12:57:19</TD>
<TD NOSAVE>rip4.fnal.gov</TD>
<TD NOSAVE>bakken</TD>
<TD NOSAVE>1048576</TD>
<TD NOSAVE>CA2904</TD>
<TD NOSAVE>0.698</TD>
<TD NOSAVE>0.00589</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>12:57:04</TD>
<TD NOSAVE>rip8.fnal.gov</TD>
<TD NOSAVE>bakken</TD>
<TD NOSAVE>1048576</TD>
<TD NOSAVE>CA2903</TD>
<TD NOSAVE>0.703</TD>
<TD NOSAVE>0.00589</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>12:53:57</TD>
<TD NOSAVE>rip4.fnal.gov</TD>
<TD NOSAVE>bakken</TD>
<TD NOSAVE>1073741824</TD>
<TD NOSAVE>CA2905</TD>
<TD NOSAVE>2.7</TD>
<TD NOSAVE>2.06</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>12:53:41</TD>
<TD NOSAVE>rip8.fnal.gov</TD>
<TD NOSAVE>bakken</TD>
<TD NOSAVE>1073741824</TD>
<TD NOSAVE>CA2903</TD>
<TD NOSAVE>2.7</TD>
<TD NOSAVE>1.88</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>12:52:31</TD>
<TD NOSAVE>rip8.fnal.gov</TD>
<TD NOSAVE>bakken</TD>
<TD NOSAVE>1048576</TD>
<TD NOSAVE>CA2904</TD>
<TD NOSAVE>0.711</TD>
<TD NOSAVE>0.0058</TD>
</TR>
<TR NOSAVE>
<TD NOSAVE>12:49:51</TD>
<TD NOSAVE>rip8.fnal.gov</TD>
<TD NOSAVE>bakken</TD>
<TD NOSAVE>104857600</TD>
<TD NOSAVE>CA2902</TD>
<TD NOSAVE>2.38</TD>
<TD NOSAVE>0.496</TD>
</TR>
</TABLE></CENTER>

<h4><a name="inquisitor_plot_ita">
1.3.8.3.4 Example Individual Transfer Activity Plot
</h4>
This plot shows the history of individual transfers (and their size) over a 
specified time interval.  This includes both reads and writes.
<p>
<center><img src="enplot_xfer.gif"></center>
<p>
<div align=right><a href="enplot_xfer.ps">(also available in Postscript)</a><div align=left>
<p>
<h4><a name="inquisitor_plot_btd">
1.3.8.3.5 Example Bytes Transferred/Day Plot
</h4>
This plot shows the number of bytes transferred per day over a specified time
interval.  This includes both reads and writes.
<p>
<center><img src="enplot_bpd.gif"></center>
<p>
<div align=right><a href="enplot_bpd.ps">(also available in Postscript)</a><div align=left>
<p>
<h4><a name="inquisitor_plot_mph">
1.3.8.3.4 Example Mounts Per Hour Plot
</h4>
This plot shows the number of mounts per hour for a single day.
<p>
<center><img src="enplot_mph.gif"></center>
<p>
<div align=right><a href="enplot_mph.ps">(also available in Postscript)</a><div align=left>
<p>
<h4><a name="inquisitor_plot_mlat">
1.3.8.3.4 Example Mount Latency Plot
</h4>
This plot shows mount latencies.
<p>
<center><img src="enplot_mlat.gif"></center>
<p>
<div align=right><a href="enplot_mlat.ps">(also available in Postscript)</a><div align=left>
<p>

<hr>
<h3><a name="alarm_server">
1.3.9 Alarm Server
</h3>
The Alarm Server maintains a record of alarms raised by other servers.  
Since Enstore attempts error recovery whenever possible,
it is expected that raised alarms will need human intervention to correct the
problem.
Currently, alarms are raised when the following conditions are detected -
<ul>
<li>A server has died and it is specified in the configuration file that it
should not be restarted.
<li>A server has died and the inquisitor was unsuccessful in restarting it.
</ul>
The alarm server compares a newly raised alarm with the previously raised ones
in order to not raise the same alarm more than once.
Raising an alarm means, the following - <br>
<ul>
<li>logging the alarm
<li>adding the alarm to the ascii alarm file
<li>adding the alarm to the Patrol alarm file
</ul>
<p>
The ascii alarm file is located in the same directory as the log files and is
called <i>enstore_alarms.txt</i>.  The Patrol alarm file is located in the same
directory and is called <i>enstore_patrol.txt</i>.
<p>
Resolving an alarm means the following - <br>
<ul>
<li>logging the cancellation
<li>removing the alarm from the ascii alarm file
<li>removing the alarm from the Patrol alarm file
</ul>
Currently it is only possible to cancel an alarm via the command line.

<h4><a name="alarm_server_cmds">
1.3.9.1 Command Line Control of the Alarm Server
</h4>
Alarm Server functionality may be controlled through a command line interface 
using <B>ecmd</B>.  A summary of the supported commands is given below.  In 
addition to the following commands, the Alarm Server command line interface 
supports the general commands supported by all other servers.
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>FUNCTION</B></TD>
<TD NOSAVE><B>COMMAND</B></TD>
<TD NOSAVE><B>OUTPUT</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>raise an alarm with root error of UNKNOWN and severity of WARNING</TD>
<TD NOSAVE>ecmd ac --alarm</TD>
<TD NOSAVE>None</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>raise an alarm with the specified root error and a severity of WARNING</TD>
<TD NOSAVE>ecmd ac --alarm --root_error="root_error"</TD>
<TD NOSAVE>None</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>raise an alarm with the specified severity and a root error of UNKNOWN</TD>
<TD NOSAVE>ecmd ac --severity=severity_value</TD>
<TD NOSAVE>None</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>resolve the specified alarm</TD>
<TD NOSAVE>ecmd ac --resolve=unique_id</TD>
<TD NOSAVE>None</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>get the name of the patrol file</TD>
<TD NOSAVE>ecmd ac --patrol_file</TD>
<TD NOSAVE>patrol file name</TD>
</TR>
</TABLE></center>

<h4><a name="alarm_server_config">
1.3.9.2 Alarm Server Config file Values
</h4>
The Alarm Server looks for the following values in the Alarm Server section of
the
Enstore config file. The default value is used if the dictionary element is not
found. Dictionary elements with no default must be specified in the Enstore 
config file.<BR>
<P>
<center><TABLE BORDER COLS=3 WIDTH="100%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>DICTIONARY ELEMENT</B></TD>
<TD NOSAVE><B>DEFINITION</B></TD>
<TD NOSAVE><B>DEFAULT</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>host</TD>
<TD NOSAVE>node where Alarm Server runs</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>logname</TD>
<TD NOSAVE>ascii value used for id in messages to Log Server</TD>
<TD NOSAVE>ALARM_SERVER</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>norestart</TD>
<TD NOSAVE>do not restart this server if it crashes</TD>
<TD NOSAVE>do a restart</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>port</TD>
<TD NOSAVE>udp port for Alarm Server communication</TD>
<TD NOSAVE>&nbsp;</TD>
</TR>
</TABLE></center>

<h4><a name="ascii_alarm_file">
1.3.9.3 Ascii Alarm File
</h4>
The ascii alarm file that the Alarm Server creates stores all of the current
raised alarms.  When the Alarm Server is started this file is read.  Below is
an example file -
<pre>
[927226812.665, 'rip7.fnal.gov', 13917, 'enstore', 'E', 'INQ_CHILD', 'CANTRESTART', {'server': 'DM12AIT.mover'}]
[927230044.586, 'rip7.fnal.gov', 18409, 'enstore', 'E', 'INQ_CHILD', 'CANTRESTART', {'server': 'DM07AIT.mover'}]
[927255672.586, 'rip7.fnal.gov', 835, 'enstore', 'E', 'INQ_CHILD', 'SERVERDIED', {'server': 'DM07AIT.mover'}]
[927255677.704, 'rip7.fnal.gov', 836, 'enstore', 'E', 'INQ_CHILD', 'SERVERDIED', {'server': 'DM08AIT.mover'}]
</pre>
<h4><a name="patrol_alarm_file">
1.3.9.4 Patrol Alarm File
</h4>
The Patrol alarm file that the Alarm Server creates stores all of the current
raised alarms in a format that Patrol can parse.  Below is an example file -
<pre>
rip7 Enstore 'E' INQ_CHILD on rip7.fnal.gov - CANTRESTART 
rip7 Enstore 'E' INQ_CHILD on rip7.fnal.gov - CANTRESTART 
rip7 Enstore 'E' INQ_CHILD on rip7.fnal.gov - SERVERDIED 
rip7 Enstore 'E' INQ_CHILD on rip7.fnal.gov - SERVERDIED 
</pre>
Patrol was developed at SLAC and enhanced and modified at DESY.  It is 
currently in use at these institutions and at Fermilab.  We have begun 
investigating its use in association with the Enstore system. 
<p>
<center><img src="patrol-status.gif"></center>
<p>
<div align=right><a href="patrol-status.ps">(also available in Postscript)</a><div align=left>
<p>

<hr>
<h2><a name="server_protocols">
1.4 Server Protocols
</h2>
<p>
Communications between clients and servers is implemented in the python modules udp_client.py
and dispatching_worker.py which contain the classes UDPclient and DispatchingWorker respectively.
For example, a Mover is a client of the edia_changer; i.e., it sends mount and dismount requests
to the media_changer and waits for replies.  The client and the server may run on the same or
different machines and messages, that is requests and replies, are passed using the UDP network protocol.
UDP is not a guaranteed reliable protocol but the Enstore protocols, described later, implement reliability.

<p>
Generally, each server module has a corresponding client module that implements the client interface
to the server.   For the media_changer, the Mover imports media_change_client.py, which 
implements load and unload methods.
So,  mover.py imports media_changer_client which encapsulates the media_changer interface and media_changer_client
imports udp_client which encapsulates the UDP communications.   On the server side, Media Changer
imports dispatching_worker which encapsulates server UDP implementation.
So far, we have mentioned modules that are imported with the python "import" command.  Within the
modules, there are python "new" commands that instantiate the corresponding classes.

<p>
All clients are themselves clients of the configuration server; so, each time they send
a request to their server, they send a request to the configuration server to get the address
of their server.   In this way the configuration server is the only server that has a hard coded address.
When each process starts it is given the IP address and port number of its configuration server.
<p>
When a client is instantiated it determines a free UDP port on its machine on which it sends requests
to its server.
When the server reads a request it also gets the address (host, port) of the client which sent the request
and uses it to reply.
<p>
Client requests are called tickets and they are python dictionaries.  The items in the dictionary
are agreed upon between the client and the server.   For example the Media Changer ticket
must contain a volume id and a drive id.
<p>
One item required in the ticket dictionary is "work".  The "work" item in the dictionary
is used in dispatching_worker as a method name and a corresponding method in the server
is called to perform the work that the client requests.   For example, the Media Changer
ticket must contain a "work" item with a value "load"  or "unload" and the Media Changer
server has methods named load and unload.
<p>
When UDPClient sends a request it first prepends a client identification stamp and a request time stamp (which
serve as a unique identification) to the
ticket and stringifies the result.  Then it calculates a CRC of the message and appends a stringified
version of the CRC to the message.   Finally it sends the message to the server and waits for a response.
<p>
The response format is client timestamp, response message, and server time stamp.  If 
the client receives any response that 
does not start with the original client time stamp or if the wait for the response times out then
the request is resent.   More about this later.
<p>
The server implementation of the protocol in DispatchingWorker does a select on a list of read
file descriptors which includes the socket (host, port) as issued by the configuration
server.   The select is repeated if it times out.
<p>
When input is detected on the socket, the server reads the request; checks the check sum; unpacks
and saves the client id, the client time stamp, and the ticket; 
converts the ticket to a python dictionary; 
and calls the method specified by the "work" item in the ticket.   If any of these things fail
then the request is ignored presuming the client will resend the request.
<p>
The "work" is a text string but python is interpreted and allows runtime evaluation of method
names.  In the Media Changer the load method is in the media_changer.py module which has imported
and instantiated a DispatchingWorker class.   When the work method is finished it calls the DispatchingWorker
method reply_to_caller with a status result ticket.
<p>
reply_to_caller builds a stringified reply with the client time stamp, the status ticket, and
its own time stamp.  It sends the reply to the client; saves the client address, the client message id,
and the complete reply in case of errors; and waits for more requests.
<p>
We save the complete reply in case of errors because we may get a request resent to the server which
the server has executed but whose response was not reliably returned.   Some requests,
for example, mounting a tape are not redoable; so, we save the reply and simply resend the reply.
When DispatchingWorker gets a request it first checks its request dictionary for a request that has the
same client id and time stamp and if it finds a match it resends the reply rather than executing the request.
<p>
The request dictionary contains all replies.
If it grows beyond a certain size (currently 1000 entries) then entries older
than 30 minutes are deleted.
<p>

The scheme described so far requires that servers handle one request at a time and that clients
queue in the servers udp input buffer waiting their turn.  This is satisfactory if requests
are guaranteed to finish quickly; however, the Media Changers operation may take a long time to complete
while other operations might be done simultaneously.   To accommodate this, dispatching_worker was extended
to allow forking in servers.
<p>
The select in dispatching_worker now watches for input from the client socket and a list of pipe
fds on which the forked servers report their final status.  The parent server process then
reports this status back to the client.
<hr>
<h2><a name="trace">
1.5 Trace 
</h2>
Trace is a utility to trace execution of code through information saved in
the circular buffer, residing in shared memory and available via special
commands. It was adapted from previous work where it has been used in the
real-time environment and is designed to have a minimal impact on the
performance of components of the system, as well as the overall performance.
Trace is widely used in all of the <em>Enstore</em> modules.
<hr>
<h2><a name="db">
2 Databases in Enstore
</h2>
Enstore uses databases to store persistent information.
Aside from the databases associated with <em>pnfs</em>, there are two databases, "file" and "volume" used by
File Clerk and Volume Clerk respectively.
<p>
The database used in Enstore must provide the following:
<ul>
<li>
Support journaling of the database to record all changes and support full
     database recovery.
<li> 
Support transaction control to ensure the integrity of the information
in database.
<li>
Support database check-pointing in order to enable full database recovery.
<li>
Support performing daily backups of the database, log, and journal files.
<li>
Support recovery of corrupted databases using the journal or log files.
<li>
Support the "python dictionary" interface.
</ul>
The directory that contains all database related files is called the
"database directory" and is defined in configuration.

<h3><a name="current_db">
2.1 Current Underlying Database Implemented in Enstore
</h3>

The current Enstore implementation uses LIBTP (http://www.sleepycat.com)(BSD DB v2.3) as the underlying
database product.
LIBTP is free for non-profit organizations like Fermilab, and has the
following features:

<ul>
<li>
one key dictionary-like database. It is designed to
store/retrieve binary large objects (BLOBs) of arbitrary length, by text key.
<li>
ability to store data items of unlimited size
<li>
support for various data storage structures: hash table, binary tree,
numbered records
<li>
allows duplicate keys (Enstore doesn't use them)
<li>
data scanning with cursors, multiple cursors may be opened at the same time
<li>
different levels of cursor stability
<li>
transactions
<li>
transaction logging
<li>
check-pointing
<li>
backup and recovery tools
<li>
custom locks
<li>
deadlock detection
</ul>


A LIBTP-Python shelve-like interface was developed. It provides access to:
<ul>
<li>All three data structures: hash table, binary tree, numbered records
<li>Cursors
<li>Transactions
<li>Locks
</ul>

LIBTP was chosen based on the following considerations:

<ul>
<li>
Nimbleness to allow us to set up test stands while developing and not being encumbered by
     database licensing issues.
<li>
It is similar to dbm-like databases used for the initial Enstore design.
This made it easy to develop a Python interface for it and any necessary
changes to the Enstore code were localized and relatively easy to make.
<li>
Database maintenance is relatively inexpensive. It requires only two
processes to run. One for check-pointing and the other for deadlock detection.
<li>
It is simple and fast enough.
<li>
It provides tools for database transaction logging, database backup and
recovery.
<li>
It is readily obtainable and free.
</ul>

<p> We have examined LibTP, and find that it meets the current modest database
requirements of the project.  We have exploited the "freeware" aspect
of it putting up many test stands.

We could replace LibTP with a Run II standard
database. However, we have no definite plans to do this, given our experience
with the tool, and the lack of any driving requirement to do this.

<p>
In addition to the databases, the File Clerk and Volume Clerk also maintain
separate journal files.
These journal files can be used to recover databases when they can not
be recovered under normal circumstances.

<h3><a name="backup_recovery">
2.2 Backup and Recovery Procedures
</h3>
<h3><a name="backup">
2.2.1 Backup
</h3>
Backup is a stand-alone procedure which can be performed manually at
any time or routinely using a cron job.
Currently the files that are backed up are database
files which contain the persistent data, log files which record the
transactions and journal files which are secondary transaction records
implemented to further help the recovery of the database if there is a need.
Enstore does live backups.
It copies those files to a
designated directory on a remote host.
The remote host and directory are defined in the Configuration Server.
The backup procedure will perform the following actions:
<p>
<center><table>
<tr>
<td valign=top>Libtp database
<td valign=top><ul>
<li>identifies the log files that are involved in active transactions<br>
<li>creates the tar file of database files and all log files <br>
<li>deletes all log files that are not involved in active transactions
</ul>
<tr>
<td valign=top>Volume journal files
<td valign=top><ul>
<li>does journal file checkpointing (hold database access,
move current file to volume.jou.time_stamp, open empty
journal file, release database access)
<li>creates tar file of volume database file and journal files
<li>deletes old journal files
</ul>
<tr>
<td valign=top>File journal file
<td valign=top><ul>
<li>does journal file checkpointing
<li>creates tar file of file database file and journal files
<li>deletes old journal files
</ul>
<tr>
<td valign=top>Archives creation
<td valign=top><ul>
<li>creates new directory on remote host under designated
"root archival" directory (name dbase.time_stamp)
<li>moves all the tar files to this area
</ul>
<tr>
<td valign=top>Archives cleanup
<td valign=top><ul><li>deletes all the archival directories created more then
N days ago (default is 10 days)</ul>
</table></center>
<h3><a name="recovery">
2.2.2 Recovery
</h3>
Recovery (restore.py) is a job initiated manually in case of database
corruption.
<p>
<center><table>
<tr>
<td valign=top>restore.py
<td valign=top><ul>
<li>save current (corrupted?) database files
<li>find the last backup
<li>retrieve database files and log files from last backup
<li>run db_recover to syncronize database files
<li>retrieve journal files from last backup
<li>check database files using journal files, make correction if it
    is necessary
</ul>
</table></center>

<hr>
<h2><a name="admin_tools">
2.3 Administrative Tools
</h2>
*** Administrative tools will exist in a layer on top the current Enstore system
and as such will not require any redesign or reimplementation of existing code.

Administrative tools will provide the following operations:
<ul>
<li>Display all volumes for a specified media
<li>List all the files and their location on a single or set of media
<li>List file/files on the media by creation date
<li>List all the media that belongs to a specified file family
<li>List files that belongs to a specified file family
<li>Display the date of the last mount for a specified volume
<li>List all media belonging to a file family sorted by the most recent media
mount date
<li>List all media belonging to a file family where the last access date is
before a specified date
<li>Export metadata of ejected media into a flat file
<li>Import metadata from a flat file when importing the media from outside the
Enstore system
<li>List all files/volumes that belong to user/group
<li>Mark the volume as readonly if all of the files on the media are older
than a specified date
<li> Delete specified files in the <em>pnfs</em> trash bin.
<li>Find and recycle volumes from which all files have been deleted.
<li>Check for files known to the File Clerk but unknown to <em>pnfs</em>
</ul>

In addition, tools will be provided to implement the administrative functions
mentioned in the D0 Functional Specification section of this document.
<p>
<hr>
<h2><a name="protocol">
3 Communication Protocols
</h2>
The base protocol for Enstore is UDP for "brief" messages and TCP for data
transfers.

UDP message sizes are all less than the size of the maximum UDP packet size so the
protocol is very simple.

<p>
The base server protocol is the same for all servers.  State-fullness is
minimized, not eliminated.
<p>
Each transmission has a unique ID, timeout and maximum number of retries
associated with it.  The timeout allows for debugging.
For each reception, the "message" is checked against messages received to see
if the reception is a repeat. If the reception is a *repeat request*, send a
saved copy of the response; if the reception is a *repeat response*, just
ignore it. This will take care of the case when a timeout/retry happens just
before a response is received.
<p>
Some transfers do not require replies and using a described UDP communication
may even hurt the system performance. One of such examples could be messages sent to the Log Server. For this purpose "pure" UDP messaging is used. 

<h3><a name="read_protocol">
3.1 Read Protocol
</h3>
The communications performed during a read operation are illustrated in the
diagram below and described more fully in the following text.
<p>
NOTE: The communications between the Mover and the Configuration Server happens
approximately every two minutes.  It has been added to the following drawing
to show that this communication is important, but it can occur anywhere in the
communications flow before the Mover contacts the Library Manager.
<p>
<center><img src=read.gif></center>
<p>
<div align=right><a href="read.ps">(also available in Postscript)</a><div align=left>
<p>
<ul>
<li>
The user (through <em>encp</em>) contacts <em>pnfs</em> asking for a bit file ID (bfid)
for the named file.
<li>
<em>pnfs</em> returns the bfid to <em>encp</em>.
<li>
<em>Encp</em> asks the Configuration Server with which File Clerk should it be
communicating.
<li>
The Configuration Server returns the location of the appropriate File Clerk.
<li>
<em>encp</em> asks the File Clerk for the information about the file with the given bit file ID.
<li>
The File Clerk asks the Volume Clerk for information for the given Volume Label
<li>
The Volume Clerk returns the information to the File Clerk
<li>
The File Clerk returns file information containing the Volume Label and the Library Manager name
<li>
<em>encp</em> asks the Configuration Server the location of the Library Manager
dealing with this File Family
<li>
The Configuration Server returns the location of the Library Manager
<li>
<em>encp</em> sends the read request to the Library Manager
<li>
The Library Manager asks the Volume Clerk if the volume for the
requested file has a read access.
<li>
The Volume Clerk confirms access permission
<li>
The Library Manager puts the read request into an internal request queue and
tells <em>encp</em> that the request has been accepted
<li>
The Library Manager finds the next potentially available Mover in its list
of Movers and sends a summon message to it initiating Mover dialog with
this Library Manager
<li>
The Mover "wakes up" receiving the summon message from the Library Manager
and asks the Library Manager if there is any work for it to do.
<li>
The Library Manager asks the Volume Clerk to mark the volume as "mounting".
<li>
The Volume Clerk confirms change of the state
<li>
The Library Manager moves the file internally from the request queue to the
work queue. 
<li>
The Library Manager tells the Mover which file to read and which volume to
mount. 
<li>
The Mover tells <em>encp</em> from which host and port to read the data.
<li>
The Mover asks the Media Changer to mount a particular volume.
<li>
The Media Changer responds once the volume is mounted.
<li>
The Mover (as the Media Changer Client) asks the Volume Clerk to mark the volume as "mounted".
<li>
The Volume Clerk confirms change of the state
<li>
The Mover sends the data to <em>encp</em>.
<li>
The Mover tells <em>encp</em> when all the data has been transferred and sends the crc information.
<li>
The read has completed.
<li>
The Mover tells the Library Manager that he still has the volume mounted.
</ul>

<h3><a name="write_protocol">
3.2 Write Protocol
</h3>
The communications performed during a write operation are illustrated in the
diagram below and described more fully in the following text.
<p>
NOTE: The communications between the Mover and the Configuration Server happens
approximately every two minutes.  It has been added to the following drawing
to show that this communication is important, but it can occur anywhere in the
communications flow before the Mover contacts the Library Manager.
<p>
<center><img src=write.gif></center>
<p>
<div align=right><a href="write.ps">(also available in Postscript)</a><div align=left>
<p>
<ul>
<li>
The user (through <em>encp</em>) contacts <em>pnfs</em> with a request to create a file.
<li>
<em>pnfs</em> returns the file family and volume library information to <em>encp</em>.
<li>
<em>encp</em> asks the Configuration Server with which Library Manager should
it be communicating.
<li>
The Configuration Server returns the location of the appropriate Library
Manager.
<li>
<em>encp</em> sends the write request to the Library Manager, including file
family and number of bytes.
<li>
The Library Manager puts the write request into an internal request queue and tells
<em>encp</em> that the request has been accepted.
<li>
The Library Manager finds the next potentially available Mover in its list
of Movers and sends a summon message to it initiating Mover dialog with
this Library Manager
<li>
The Mover "wakes up" receiving a summon message from the Library Manager
and asks the Library Manager if there is any work for it to do.
<li>
The Library Manager asks the Volume Clerk for a volume for the file with the
specified size and file family. 
<li>
The Volume Clerk returns the volume to the Library Manager. 
<li>
The Library Manager asks the Volume Clerk to mark the volume as "mounting".
<li>
The Volume Clerk confirms change of the state
<li>
The Library Manager moves the file internally from request queue to
work queue. 
<li>
The Library Manager tells the Mover which file to write and which volume to
mount. 
<li>
The Mover asks the Media Changer to mount a particular volume.
<li>
The Media Changer responds once the volume is mounted.
<li>
The Mover (as the Media Changer Client) asks the Volume Clerk to mark the volume as "mounted".
<li>
The Volume Clerk confirms change of the state
<li>
The Mover tells <em>encp</em> to which host and port to write the data.
<li>
The Mover tells the Volume Clerk that he is appending to this volume. 
<li>
The Volume Clerk acknowledges this. 
<li>
<em>encp</em> sends the data to the Mover.
<li>
The Mover tells the Volume Clerk that the append operation is done and how much
space is left on the volume.
<li>
The Volume Clerk acknowledges this.
<li>
The Mover tells the File Clerk which file has been created.
<li>
The File Clerk responds with the bit file id.
<li>
The Mover tells <em>encp</em> that the file has been written and sends the bit
file ID and the crc.
<li>
<em>encp</em> tells <em>pnfs</em> that the file has been created, and the bfid should be stored.
<li>
The write has completed.
<li>
The Mover tells the Library Manager that he still has the volume mounted.
<li>
The Library Manager asks the Volume Clerk to mark the volume as "unmounting".
<li>
The Volume Clerk confirms change of the state
<li>
The Library Manager tells the Mover that there is no work to be done.
<li>
The Mover tells the Media Changer to dismount the volume.
<li>
The Media Changer responds once the volume is unmounted.
<li>
The Mover (as the Media Changer Client) asks the Volume Clerk to mark the volume as "unmounted".
<li>
The Volume Clerk confirms change of the state
</ul>

<hr>
<h2><a name="error">
4 Error Control
</h2>

<h3><a name="eass">
4.1 Assumptions about Errors
</h3>
Enstore conforms to the (oral) statements made about Run II operating conditions:
<UL>
	<LI>No single error when reading a tape is fatal to upper level
		software.

	<LI>When writing, errors should be handled by retries
		on different media.

	<LI>Mover nodes may crash, with minimal disruption of the system.

	<LI>The system should generate alarms and receive immediate service
	   when its throughput falls below predefined levels.

	<LI>Routine error conditions should be cleared in normal
	   business hours.

	<LI>It shall be possible to redirect writes to another library
	   in case of library failure.

	<LI>The system shall be capable of being monitored by PATROL.

</UL>
</P>

<h3><a name="eover">
4.2 Error Overview
</h3>

<P> Enstore is a distributed system. For a transfer to succeed, many of the
Enstore processes must be up and running.  Therefore, the servers are
robust, and run on reliable computers. Nevertheless, it is good to consider
the intrinsic ability for the system to recover when a process or
system running a process crashes.  This is summarized in the table below:
<p>

<center><TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>

<TH> <P><FONT COLOR="#0000ff"><B>Process</B></FONT></FONT></TH>
<TH> <P><FONT COLOR="#0000ff"><B>Where is State?</B></FONT></FONT></TH>
<TH> <P><FONT COLOR="#0000ff"><B>Effect of Crash</B></FONT></FONT></TH>


<TR VALIGN=TOP>
<TD> <P><em>Encp</em> </FONT> </TD>
<TD> <P>In the user's <em>encp</em> transfer command </FONT> </TD>
<TD> <P>Transfer is canceled/aborted </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Configuration Server </FONT> </TD>
<TD> <P>Static configuration file </FONT> </TD>
<TD> <P>Wait for restart of server </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>File Clerk </FONT> </TD>
<TD> <P>Persistent database table </FONT> </TD>
<TD> <P>Wait for restart of server </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Volume Clerk </FONT> </TD>
<TD> <P>Persistent database table </FONT> </TD>
<TD> <P>Wait for restart of server </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Library Manager </FONT> </TD>
<TD> <P>In-memory lists of what work is queued, and what work
is at what Mover </FONT> </TD>
<TD> <P>Recovery of state is not yet implemented. Recovery of state is possible through <em>encp</em> retries. </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Mover </FONT> </TD>
<TD> <P>If busy, the current transfer + the current volume </FONT> </TD>
<TD> <P><em>Encp</em> retries writes, exits with errors on read. </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P><em>pnfs</em> NFS Servers </FONT> </TD>
<TD> <P>DBM database "file metadata" </FONT> </TD>
<TD> <P>NFS retry mechanisms </FONT> </TD>


<TR VALIGN=TOP>
<TD> <P>Media Changer </FONT> </TD>
<TD> <P>In memory lists of work given to library micro </FONT> </TD>
<TD> <P>State refreshed by Enstore UDP retry protocol mechanism </FONT> </TD>


<TR VALIGN=TOP>
<TD> <P>Log Server </FONT> </TD>
<TD> <P>None </FONT> </TD>
<TD> <P>Logs are not written </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Inquisitor </FONT> </TD>
<TD> <P>None </FONT> </TD>
<TD> <P>Displays are not refreshed until restart </FONT> </TD>



</TABLE></center>
<p>

<h3><a name="edet">
4.3 Detailed Error Discussion
</h3>

<P>Much of the system state is stored within the user's <em>encp</em> client.
This allows the <em>encp</em> client to retry on a large number of different
errors. This retry is given a very high priority when it is received
by the Library Manager so the user doesn't have to wait again for
their job. It is the Library Manager's responsibility to ensure the
error is not just repeated; for example, on a volume read error, the
volume should not go to the same drive on a retry. The Library
Manager gets the retry, volume and drive information from the ticket.</P>

<P>Many interesting errors are related to cases where the volume
cannot be written or read, or when it is suspected that volume is
jammed, etc. More experience is needed with the actual hardware
before the correct error control behavior is established. In the
interim, Enstore will make the following working assumptions: 
</P>
<UL>
	<LI>If there is trouble during a load or unload operation, the
	volume is assumed to be physically jammed. No operations on the
	drive or the volume until an administrator looks at the problem. 
	<LI>If several drives have fatal write errors on a volume, the
	volume will be marked read only. 
	<LI>If several drives have fatal read errors on a volume, the volume
	will be marked no access. 
	<LI><P>If a drive has several fatal errors on different volumes, the
	drive will be marked offline.</P>
</UL>
<DL>
	<DT><BR>
	</DT>
	<DT>The following table describes the error conditions that Enstore
	handles. 
	</DT>
	<DT><BR>
	</DT>
	<DT><BR><BR>
	</DT>
</DL>
<center><TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>
	<TR VALIGN=TOP>
		<TH>
			<P><FONT COLOR="#0000ff"><B>Error Code</B></FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Description</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Administrator</FONT></FONT></P>
			<P><FONT COLOR="#0000ff">Responsibility</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Mover</FONT></FONT></P>
			<P><FONT COLOR="#0000ff">Responsibility</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Library Manager</FONT></FONT></P>
			<P><FONT COLOR="#0000ff">Responsibility</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff"><em>encp</em></FONT></FONT></P>
			<P><FONT COLOR="#0000ff">Responsibility</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Retry</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Volume </FONT></FONT>
			</P>
			<P><FONT COLOR="#0000ff">State</FONT></FONT></TH>
		<TH>
			<P><FONT COLOR="#0000ff">Drive </FONT></FONT>
			</P>
			<P><FONT COLOR="#0000ff">State</FONT></FONT></TH>
	</TR>
	<TR>
		<TH COLSPAN=9 VALIGN=TOP>
			<P><BR><BR>
			</P>
			<P><BR>
		</TH>
	</TR>
	<TR>
		<TH COLSPAN=9 VALIGN=TOP>
			<P><FONT COLOR="#ff3333">Volume Write Errors</FONT></FONT></TH>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_NOTAPE</B> </FONT>

		</TD>
		<TD>
			<P>Requested volume was not found in the library. Volume Clerk's data base is inconsistent with library micro's database. </FONT>
  			<A href=write_notape.gif> use case </a>

		</TD>
		<TD>
			<P>Check volume in morning </FONT>
		</TD> 
		<TD>
			<P>Mark volume no access</FONT></P>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_TAPEBUSY</B> </FONT>
		</TD>
		<TD>
			<P>Requested volume is in another drive. Enstore bug,
			or some other system has mounted volume or library micro put
			volume elsewhere. </FONT>
  			<A href=write_tapebusy.gif> use case </a>

		</TD>
		<TD>
			<P>Check volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_DRIVEBUSY</B> </FONT>
		</TD>
		<TD>
			<P>A volume is already in drive. Enstore bug or
			misconfiguration. Note: Mover waits for automatic cleaning tape to
			be ejected. </FONT>
  			<A href=write_drivebusy.gif> use case </a>

		</TD>
		<TD>
			<P>Check drive and configuration in morning </FONT>
		</TD>
		<TD>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_BADMOUNT</B> </FONT>
		</TD>
		<TD>
			<P>Mount failure or load operation failed. Must
			assume jammed volume. </FONT>
  			<A href=write_badmount.gif> use case </a>

		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_BADSPACE</B> </FONT>
		</TD>
		<TD>
			<P>EOD cookie does not produce EOD. Wrong volume,
			Enstore bug or drive space error. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_ERROR</B> </FONT>
		</TD>
		<TD>
			<P>Error writing data block or file mark. </FONT>
  			<A href=write_error.gif> use case </a>

		</TD>
		<TD>
			<P>Check drive in morning </FONT>
			</P>
			<P><BR><BR>
			</P>
			<P>Check volume in morning </FONT>
		</TD>
		<TD>
			<P>If several errors occur with different volumes,
			offline the drive.</FONT></P>
			<P>If several errors occurs with different drives,
			mark volume as read only </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
			</P>
			<P><BR><BR>
			</P>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
			</P>
			<P><BR><BR>
			</P>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P><BR><BR>
			</P>
			<P><BR><BR>
			</P>
			<P>Read Only</FONT></P>
			<P><BR>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_EOT</B> </FONT>
		</TD>
		<TD>
			<P>Hit EOT while writing data block or file mark. </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Mark volume as full and read only </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P>Read only </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_UNLOAD</B> </FONT>
		</TD>
		<TD>
			<P>Error unloading volume from drive. Must assume
			jammed volume. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Not involved </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_NOBLANKS</B> </FONT>
		</TD>
		<TD>
			<P>No more blank volumes. </FONT>
		</TD>
		<TD>
			<P>Administrator should be paged.</FONT></P>
			<P>DAQ should switch to alternate library. </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>WRITE_MOVER_CRASH</B></FONT></TD>
		<TD>
			<P>If Mover is connected to an <em>encp</em>, <em>encp</em> will notice
			its sockets being torn down prematurely. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Mark volume as no access, retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=9 VALIGN=TOP>
			<P><BR><BR>
			</P>
			<P><BR>
		</TD>
	</TR>
	<TR>
		<TH COLSPAN=9>
			<P><FONT COLOR="#ff3333"><B>Volume Read Errors</B></FONT></FONT></TH>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_NOTAPE</B> </FONT>
		</TD>
		<TD>
			<P>Requested volume was not found in the library. Volume Clerk's data base is inconsistent with library micro's database. </FONT>

		</TD>
		<TD>
			<P>Check volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_TAPEBUSY</B> </FONT>
		</TD>
		<TD>
			<P>Requested volume is in another drive. Enstore bug,
			or some other system has mounted volume or library micro put
			volume elsewhere. </FONT>
		</TD>
		<TD>
			<P>Check volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_DRIVEBUSY</B> </FONT>
		</TD>
		<TD>
			<P>A volume is already in drive. Enstore bug or
			misconfiguration. Note: Mover waits for automatic cleaning tape to
			be ejected. </FONT>
		</TD>
		<TD>
			<P>Check drive and configuration in morning </FONT>
		</TD>
		<TD>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_BADMOUNT</B> </FONT>
		</TD>
		<TD>
			<P>Mount failure or load operation failed. Must
			assume jammed volume. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_BADLOCATE</B> </FONT>
		</TD>
		<TD>
			<P>Failed space or initial CRC's don't match. Either
			file location cookie is corrupted, wrong volume in the drive or
			drive cannot space properly. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_ERROR</B> </FONT>
		</TD>
		<TD>
			<P>Error reading data block. Run of the mill read
			error. </FONT>
  			<A href=read_error.gif> use case </a>

		</TD>
		<TD>
			<P>Check drive in morning </FONT>
			</P>
			<P><BR><BR>
			</P>
			<P>Check volume in morning </FONT>
		</TD>
		<TD>
			<P>If several errors occur with different volumes,
			offline the drive.</FONT></P>
			<P>If several errors occurs with different drives,
			mark volume as read only </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Retry </FONT>
		</TD>
		<TD>
			<P>Yes</FONT></P>
			<P><BR><BR>
			</P>
			<P>No </FONT>
		</TD>
		<TD>
			<P><BR><BR>
			</P>
			<P><BR><BR>
			</P>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_COMP_CRC</B> </FONT>
		</TD>
		<TD>
			<P>CRC mismatch Drive and the volume are suspicious.
			Corrupt file location cookie, drive space error, wrong volume in
			the drive, etc. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume as no access</FONT></P>
			<P>Offline drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_EOT</B> </FONT>
		</TD>
		<TD>
			<P>Hit EOT when reading. Corrupt file location
			cookie, drive space error, or wrong volume in the drive. Should
			have hit an EOF. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume as no access</FONT></P>
			<P>Offline drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_EOD</B> </FONT>
		</TD>
		<TD>
			<P>Hit EOD when reading. Corrupt file location
			cookie, drive space error, or wrong volume in the drive. Should
			have hit an EOF. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume as no access</FONT></P>
			<P>Offline drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_UNLOAD</B> </FONT>
		</TD>
		<TD>
			<P>Error unloading volume from drive. Must assume
			jammed volume. </FONT>
		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Not involved </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>


	<TR VALIGN=TOP>
		<TD>
			<P><B>READ_MOVER_CRASH</B></FONT></TD>
		<TD>
			<P>If a Mover is connected to an <em>encp</em>, <em>encp</em> will
			notice its sockets being torn down prematurely. The volume is tied
			up at a Mover. </FONT>
		</TD>
		<TD>
			<P>Check volume and drive in the morning </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Mark volume no access </FONT>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P>No Access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR>
		<TD COLSPAN=9 VALIGN=TOP>
			<P><BR><BR>
			</P>
			<P><BR>
		</TD>
	</TR>
	<TR>
		<TH COLSPAN=9>
			<P><FONT COLOR="#ff3333"><B>Other Errors</B></FONT></FONT></TH>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>ENCP_GONE</B> </FONT>
		</TD>
		<TD>
			<P>User has gone away while request is queued. </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Unilateral unbind </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>TCP_HUNG</B> </FONT>
		</TD>
		<TD>
			<P>It appears that the data TCP link is hung.</FONT>
		</TD>
		<TD>
			<P>Check with user in morning </FONT>
		</TD>
		<TD>
			<P>Compute an anticipated transfer time for every
			socket operation and abort the transfer if the actual transfer
			takes more than three times the expected value. </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>LM_CRASH</B> </FONT>
		</TD>
		<TD>
			<P>Library Manager crashes, and loses its queue of
			pending work. The <em>encp's</em> will never be called back, and will wait
			forever. </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Ping Library Manager, every N mins (30) to see if
			its request has gotten lost. </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>MOVER_CRASH</B></FONT></TD>
		<TD>
			<P>Mover is idle. The system degrades. </FONT>
		</TD>
		<TD>
			<P>Check drive in morning </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Remove from list when Mover fails to respond to
			summon </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>
	<TR VALIGN=TOP>
		<TD>
			<P><B>ANY_UNMOUNT</B> </FONT>
		</TD>
		<TD>
			<P>Error unmounting volume. Volume is hanging in the
			drive. </FONT>
  			<A href=any_unmount.gif> use case </a>

		</TD>
		<TD>
			<P>Check drive and volume in morning </FONT>
		</TD>
		<TD>
			<P>Mark volume no access</FONT></P>
			<P>Offline the drive </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>Not involved </FONT>
		</TD>
		<TD>
			<P><BR>
		</TD>
		<TD>
			<P>No access </FONT>
		</TD>
		<TD>
			<P>Offline </FONT>
		</TD>
	</TR>


</TABLE></center>
<P><BR><BR>
</P>

<ul>
  <li> "Freeze the volume in the drive" means:
       <ul>
	 <li>Not unloading the volume from the drive
	 <li>Freezing the volume
	 <li>Offlining the drive
       </ul>
  <li> "Freezing the volume" means:
       <ul>
	 <li>mark the volume as "system noaccess"
	 <li>log that this happened and let an administrator look at the
	      problem in the morning.
	 <li><em>Encp</em> shall not retry.
       </ul>
  <li> "Offlining the drive" means:
       <ul>
	 <li>Preserving as much state as possible.
	 <li>Writing a complete description in an error log.
	 <li>Leaving the problem until business hours unless the capacity of
	      the system falls below a threshold.
       </ul>
</ul>

<hr>
<h2><a name="impexp">
5 Volume Import and Export
</h2>

It is certainly  possible to import and export information by copying disk resident data
from Enstore using the <em>encp</em> command. 
However, given the need to move large amounts of data, and the wide spread
use of compatible tape drives and
media, it is usually  more efficient to interchange tape volumes: that is, to write
tapes outside of Enstore and import them into the system, and to write tapes
inside of Enstore and remove them from the system. In this way, for example,
Enstore can be used as a kind of tape copy facility.

<p> What follows are draft design notions; importing and exporting are 
not yet fully implemented.

<h3><a name="volexp">
5.1 Volume Export
</h3>

<p> Exportable volumes are built in Enstore using the <em>encp</em> command, with the
command line switch --ephemeral, which specifies a temporary, "ephemeral" file family. An
ephemeral file family is a unique file family name created just for this <em>encp</em>
command, with a file family width of exactly one. Under these conditions, files will
be placed on the tape volume in the order specified by the user. Once the data is written to the
tape, the file family name is changed to the tape_label_name.ephemeral.

<p>An experimenter wishing to build an exportable volumes would follow these steps:

<ul>

<li> Select a file structuring method which is supported in Enstore, which
your users can read, and complies with tape interchange standards of your
experiment.  (For D0 this is the CPIO format.)

<li> Decide what kind of media you want for the exported volume. (For D0
this will be the media selected by the SMWG.)

<li> Identify and make locally disk resident all the files that you want to put on a
volume. Consider the capacity of the tape, and whether you can tolerate files
overflowing onto another volume.

<li> Specify those files on a single <em>encp</em> command line, in the order you would
like to have them placed on tape. Use the <em>encp</em> the --ephemeral file family
switch on the command line.
[After the initial <em>encp</em> copy, the file family for the tape is known. If the
user chooses, she may append additional files to the tape.  However,
the no additional tapes will be added to the file family once it is
full. It is recommended that all files be copied with one <em>encp</em> command.]

<li> Optionally generate metadata for the volume, if your user will want to
know what files are on the tape.

<li> Move the volume from the robot to a shelf library, using an Enstore
administration tool.

<li> Remove the volume from the Enstore system, using an Enstore
administration tool.

</ul>

An experiment can make tapes in the Enstore system at Fermilab and
give the volumes to an experimenter, who can read the tapes anywhere.
Experimenters can optionally generate a metadata file which provides a
map of the exported tape. However,
some tape formats, such as CPIO,  are sufficiently self-describing so that the tape may
be dumped to disk with standard utilities.
<p>
As an example, an experimenter can stage an entire CPIO exported volume using
gnu CPIO at her home institution. (Since there are many files on an
Enstore tape, special care should be taken to select a non-rewind tape
device.
On a UNIX system, CPIO tapes can be read with no special infrastructure
other than 
gnu CPIO. For example, here is a simple script to read an exported tape at
a home institution:

<pre>
#!/bin/sh

# en_dump_tape  A shell script to dump an  Enstore CPIO format tape.
# This is pseudo code, not functional yet

$tape=$1
test ! -f $tape || exit 1  ## Try to make sure we have not selected a device file
while /bin/true ; do  
   mt -t $tape fsf 1      || exit 1
   (dd if=$tape  | cpio -o  )  || exit 1
done

</pre>

<h3><a name="volimp">
5.2 Volume Import
</h3>

Volume import is suitable for repeated and sizeable
transfers of data. Volume import is not as easy as export and, therefore, it is not a good choice for small, occasional
transfers.

Planning is important.
Tapes in a robot require special labels that can be automatically
scanned and placed in the robot. The labels must be unique within a robot and
within an Enstore system. You will need to procure tape volumes with labels
meeting these requirements. Imported tapes are read-only in Enstore. (Details
of these requirements are TBD, pending the serial media working group
decision). 

<p> Although it is not mandatory, an Enstore tool will very likely have to be produced to get good
results for experimenters at home institutions wishing to make importable tapes. 

<p>If the tapes are to be accessed many times, the experiment must take some
time to think about the layout of data on the tapes and how the files ought
to fit into the Enstore name space.

<ul>
 <li> Files that are accessed together should likely be put on the same tape. 
 <li> Most likely, the same file should not be placed on more than one
      tape. Duplicate data files (very important data) is handled differently.
 <li> Files must definitely not span tapes. 
 <li> If a likely order of future access is known, files should be put on 
	tape in that order.
 <li> Think of how you would like the files to appear in the Enstore name
        space.
 <li> Identify a file structuring method that is compatible with Enstore and
        your experiment's data interchange standards.
 <li> Files should be written with a blocksize yielding good performance.
	(Precise recommendation is TBD, pending SMWG decision).
 <li> Files should be written with the recommended partitioning.
	(Precise recommendation is TBD, pending SMWG decision).

</ul>

<p> Since the objective is to import a large amount of data, it is required to
generate metadata for each tape; otherwise the tape will have to be scanned to
determine the metadata and this defeats the purpose of importing volumes!


<p> Metadata for each tape is:

<ul>
<li> The external bar-coded label of the tape.
<li> The kind of tape media.
<li> The file structuring method used to generate the tape.
<li> The blocksize used in writing the tape.
</ul>

<p> Metadata for each file is:

<ul>
<li> An Adler 32 CRC of the first 65536 bytes of the file. If not
     available, a value of "None" is acceptable and Enstore skips the check
     (not recommended).
<li> An Adler 32 CRC of all the bytes in the file. If not
     available, a value of "None" is acceptable and Enstore skips the check
     (not recommended).
<li> The number of blocks (or less desirably, the number of file marks) preceding the beginning of the wrapper.
<li> The number of the partition holding the file (if this feature is used).
<li> A name for the file.
<li> A path for the file in the <em>pnfs</em> namespace.
</ul>

<p> The procedure the user would follow to create an importable volume is:

<ul>
 <li>Identify the files you want to put on a tape.
 <li>Put an optically bar-coded tape in the tape drive. Sheets of bar codes
      could be sent to the remote site or actual pre-labeled tapes could be
      used. The important point is that the robot will be able to recognize
      the tapes.
 <li>Using a tool we provide:
 <ul>
   <li>Place the files on the tape.
   <li>Generate the  metadata for that file.
 </ul>
 <li> Remove the tape from the drive.
</ul>


The procedure for importing a volume is:

<ul>
  <li> Deliver the volume to the data center.

  <li> Use an Enstore administration utility to make a record for the volume
  in the volume table using the volume metadata and to set the physical
  location as the "shelf" library.

  <li> Use an Enstore administration utility to place the metadata for
  each file into the file table and <em>pnfs</em> namespace.

</ul>




<hr>
<h2><a name="test_system">
6 Test System
</h2>

The Enstore hardware test system was designed to be able to test
data movement at rates comparable to requirements for Run II data
logging, to evaluate gigabit networking technologies, and to 
determine scaling for the larger amount of hardware, required  to 
support all of Run II data handling.  The ability to sustain data rates comparable
to Run II data logging requirements allows the test system to double
as the RIP (Reconstruction Input Pipeline) test platform.
<p>
The following test system is installed in the Feymann Computing center
and runs several enstore systems.  One is for HPPP systems development
and testing and the othe is used by the D0/SAM project.  D0/SAM has
gigabit ethernet access to the enstore environment and uses the
system for testing and presented it at Super-Computing 98.

The RIP/Enstore hardware test system consists of the following:
<ul>
  <li> 10 x86 PC's with:
       <ul>
	 <li> dual 400 MHz Pentium II processors
	 <li> 128 MB SDRAM memory
	 <li> integrated fast ethernet
	 <li> integrated ultra wide SCSI (1 bus)
	 <li> integrated ultra SCSI (1 bus)
	 <li> integrated video
	 <li> 2 4-GB Seagate Barracuda SCSI disks
	 <li> gigabit ethernet interface (Packet Engines)
	 <li> two nodes with differential wide SCSI interface
	 <li> four nodes with wide LVD SCSI interface
	 <li> two nodes with Fibre Channel (for SCSI) interface
	 <li> streams 275 MBytes/sec memory bus bandwidth measurement
       </ul>
  <li> Disk chassis with 4 ultra wide SCSI buses, each with 2 18-GB disks
       
  <li> Disk chassis with dual FC-AL loop, FC controller, 4 9-GB FC disks.
       
  <li> Foundry fast ethernet switch with gigabit ethernet uplinks (2)
       
  <li> Foundry gigabit ethernet switch
       
  <li> Packet Engines gigabit ethernet full duplex repeater
</ul>

Two nodes are connected to tape drives on the EMASS robot.  One node,
via a single wide differential SCSI bus, is connected to four Sony AIT
tape drives.  The other is connected via a single bus to four Quantum
DLT 7000 drives, and two Exabyte Mammoth drives.
<p>
One node is connected to two STK redwood tape drives in a STK Powderhorn robot.
<p>
The RIP cluster is located physically adjacent to the SAM cluster,
which has similar PC's.  For testing throughput to/from clients, the
SAM cluster can be connected to the RIP cluster via 10, 100, and 1000
Mbps network uplinks (though each SAM node has only 10/100 Mbps
capability).
<p>
<center><img src="test-network.gif"></center>
<p>
<div align=right><a href="test-network.ps">(also available in Postscript)</a><div align=left>
<p>

Enstore has been installed on the Test System and is fully operational.
The administration of the system is flexible and can be changed by
modifying a single configuration file.
<p>
Currently, the configuration is as follows:
<center><TABLE BORDER COLS=2 WIDTH="50%" NOSAVE >
<TR VALIGN=CENTER NOSAVE>
<TD NOSAVE><B>NODE</B></TD>
<TD NOSAVE><B>SERVERS</B></TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip1</TD>
<TD NOSAVE>4-AIT Media Changers<br>2-AIT Media Changers<br>4-DLT Movers</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip2</TD>
<TD NOSAVE>4-AIT Movers</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip3</TD>
<TD NOSAVE>cluster console</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip4</TD>
<TD NOSAVE>General Use</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip5</TD>
<TD NOSAVE>Disk Library Manager<br>AIT Library Manager<br>DLT Library
Manager<br>Mammoth Library Manager<br>Redwood-50 Library
Manager<br>Redwood-20 Library Manager</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip6</TD>
<TD NOSAVE>Configuration Server<br>File Clerk<br>Volume Clerk<br>Admin
Clerk<br>Log Server<br>Inquisitor<br>Alarm Server<br>Disk Mover<br>Disk
Media Changer</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip7</TD>
<TD NOSAVE>General Use</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip8</TD>
<TD NOSAVE>General Use<br>Serves Home areas</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip9</TD>
<TD NOSAVE>2-STK Movers</TD>
</TR>
<TR VALIGN=LEFT NOSAVE>
<TD NOSAVE>rip10</TD>
<TD NOSAVE>4-DLT Media Changers<br>STK Media Changer</TD>
</TR>
</TABLE></center>
<P>

In the past, we have also tested exabytes on AIX machines. We have not
continued with this effort, but rather have concentrated on drives and cpus
that will most likely be used in conjunction with the EMASS robot.

<center><img src="test-configuration.gif"></center>
<p>
<div align=right><a href="test-configuration.ps">(also available in Postscript)</a><div align=left>
<p>

<h2><a name="ts_results">
6.1 Test System Results
</h2>

<h3>Test System Configuration:</h3>

<ul>
<li> EMASS Robot:
<center>     <table cols=2 width="50%">
     <tr>
     <td> 2 AITS
     <td> (15 of 84 tapes allocated)
     <tr>
     <td> 1 Mammoth
     <td> (15 of 42 tapes allocated)
     <tr>
     <td> 2 DLTS
     <td> (15 of 84 tapes allocated)
     </table></center>
<li> STK Robot:
<center>     <table cols=2 width="50%">
     <tr>
     <td> 2 Redwoods
     <td> (5 of 200 tapes allocated)
     </table></center>
<li> Disk test Movers
</ul>

<h3>Preliminary Rates Measurements:</h3>
<center><table cols=5 width="80%">
<tr>
<td> <B>Device</B>
<td> <B>Writing</B>
<td> <B>Reading</B>
<td> <B>Network</B>
<td> <B>"Mem->tape"</B>
<tr>
<td> &nbsp;
<td> (MB/S)
<td> (MB/S)
<td> (Mbits/S)
<td> (MB/S)
<tr>
<td> AIT
<td> 2.7
<td> 2.7
<td> 94
<td> 2.7
<tr>
<td> Mam
<td> 2.8
<td> 2.7
<td> 94
<td> 2.8
<tr>
<td> DLT
<td> 4.9
<td> 4.8
<td> 94
<td> 4.9
<tr>
<td> STK
<td> 8.8*
<td> 7.5*
<td> 83
<td> 9.8
</table></center>
<i><center>* == STK tests not repeated (yet) after coding changes that improved performance</center></i>

<dl>
<dt> Some STK details:</dt>
  <dd>
       <ul>
	 <li> 1 GB file transferred
	 <li> Mount time ~ 41 seconds
	 <li> Seek time ~ 0 seconds (beginning of tape)
	 <li> Enstore queue wait time ~ 1 second
	 <li> Transfer time ~ 116 seconds (8.8 MB/S)
	 <li> EOF time ~ 0 seconds
	 <li> Get stats time ~ 34 seconds
	 <li> Effective User rate: 5.7 MB/s (appending)
       </ul
	      </dd>
</dl>

<h3>Preliminary CPU Utilization for AIT transfers:</h3>
<center><table cols=3 width="40%">
<tr>
<td> &nbsp;
<td> <B>Mover</B>
<td> <B>User's <em>Encp</em></B>
<tr>
<td> <B>no crc</B>
<td> 5-10%
<td> 5-10%
<tr>
<td> <B>crc</B>
<td> 10-20%
<td> 10-20%
</table></center>


<hr>
<h2><a name="interface">
7 Interfaces and Integration
</h2>

Below is an (incomplete) summary of interfaces that are intrinsic to
the Enstore software. They are specified and coded as
part of the software project.
<p>
<center><TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>

<TH> <P><FONT COLOR="#0000ff"><B>Function</B></FONT></FONT></TH>
<TH> <P><FONT COLOR="#0000ff"><B>Person</B></FONT></FONT></TH>
<TH> <P><FONT COLOR="#0000ff"><B>Software</B></FONT></FONT></TH>


<TR VALIGN=TOP>
<TD> <P>Initiate a specific transfer between tape and disk </FONT> </TD>
<TD> <P>Experimenter </FONT> </TD>
<TD> <P><em>encp</em> </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Organize names </FONT> </TD>
<TD> <P>Experimenter </FONT> </TD>
<TD> <P><em>pnfs</em> </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Choose library to write to </FONT> </TD>
<TD> <P>Experimenter </FONT> </TD>
<TD> <P><em>pnfs</em> </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Create file families, administer width </FONT> </TD>
<TD> <P>Experimenter </FONT> </TD>
<TD> <P><em>pnfs</em> </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Current status on web </FONT> </TD>
<TD> <P>Enstore Administrator </FONT> </TD>
<TD> <P>Inquisitor </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Summary status on Web </FONT> </TD>
<TD> <P>Enstore Administrator </FONT> </TD>
<TD> <P>Inquisitor </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Routine periodic monitoring </FONT> </TD>
<TD> <P>TBD </FONT> </TD>
<TD> <P>Patrol  (or TBD?) + Alarm module </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Move volumes between shelf and library </FONT> </TD>
<TD> <P>Experimenter </FONT> </TD>
<TD> <P>Enstore Administration Utility </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Move volumes between shelf and out-of-system (includes new volumes) </FONT> </TD>
<TD> <P>Experimenter </FONT> </TD>
<TD> <P>Enstore Administration Utility </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Drain system </FONT> </TD>
<TD> <P>Enstore Administrator  </FONT> </TD>
<TD> <P>Enstore Administration Utility </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Shutdown system </FONT> </TD>
<TD> <P>Enstore Administrator </FONT> </TD>
<TD> <P>Enstore Administration Utility </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>(Re)Start system </FONT> </TD>
<TD> <P>Enstore Administrator </FONT> </TD>
<TD> <P>Enstore Administration Utility </FONT> </TD>

</TABLE></center>

<p> Interfacing to an experiment means placing Enstore in a larger
system context. 
 From the point of view of Enstore with network attached tapes, there is an
Enstore system which interfaces to the rest of D0 on the NIC-card cable
connector. In addition to the interfaces to the user and administrators (which
are intrinsic to Enstore software), there are other miscellaneous interface
issues associated with a real instance of the software, since the whole system
must conform to the Experiments, Division's and Laboratories system
constraints:
<P>
<center><TABLE BORDER=1 CELLPADDING=2 CELLSPACING=0>

<TH> <P><FONT COLOR="#0000ff"><B>Type</FONT></FONT></TH>
<TH> <P><FONT COLOR="#0000ff"><B>Constraint</FONT></FONT></TH>
<TH> <P><FONT COLOR="#0000ff"><B>Imposed by</FONT></FONT></TH>

<TR VALIGN=TOP>
<TD> <P>Network </FONT> </TD>
<TD> <P>Conforming Physical Media </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Network </FONT> </TD>
<TD> <P>Protocol Extensions </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Network </FONT> </TD>
<TD> <P>16K minimum UDP Datagram size </FONT> </TD>
<TD> <P>Enstore </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Network </FONT> </TD>
<TD> <P>Traffic pattern to machines where one NIC card is not sufficient, </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Site</FONT> </TD>
<TD> <P>Location </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Operations </FONT> </TD>
<TD> <P>Run II Operations Software Framework (Patrol or TBD) </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Operations </FONT> </TD>
<TD> <P>Failure planning (i.e. broken tape library, Power) </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Operations </FONT> </TD>
<TD> <P>Upgrade-ability </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Operations + Security </FONT> </TD>
<TD> <P>Standard Administration </FONT> </TD>
<TD> <P>System </FONT> </TD>

<TR VALIGN=TOP>
<TD> <P>Security </FONT> </TD>
<TD> <P>Authentication etc are TBD </FONT> </TD>
<TD> <P>System </FONT> </TD>

</TABLE></center>


<p>All production hardware is to come from the D0 Budget, requisitioned by
D0. This includes the Enstore system, tape drives and other peripherals.
D0 have a baseline system design. From the point of view of the storage
management project, the main features of the D0 system are:    

<ul>
 <li>IP Based connectivity.

 <li>A few SMP boxes back-ending their DA at the D0 assembly building.

 <li>An analysis facility in FCC consisting of a large SMP box and
 smaller SMP boxes.

 <li>Many hundred farm nodes, most likely an ensemble of small PC's or
 economical RISC work stations provided by the lowest bidder.  Whether there
 are "I/O nodes" associated with the farm is  TBD.

 <li>An Enstore system with about 8-10 Mover nodes, and sufficient other
      nodes to run the rest of the system.
</ul>

<p> Given the discussion above, the main interface issues with D0 are:

<ul>
 <li> Specification  and design of a data LAN.
 <li> The number and type of NIC cards on each computer.
 <li> Tuning the features in Enstore for the significant multiple NIC card
      machines.
</ul>

<p> To keep transfers efficient, it is important to have a network design
which avoids congestion.  

<p> It is important to characterize the rate achievable on a NIC card, and the
amount of CPU required to drive NIC cards.  Typically, there is less CPU/BYTE
when writing to the network, than when reading from it. One vendor reports, for
CPU's available in late 1998:

<pre>
	10-11 MB/S on a 100 mbps ethernet NIC
	30-35 MB/S on a Gbit ethernet card (standard MTU)
	70-80 MB/S on a Gbit ethernet card (jumbo MTU)
	
	30-35 MB/S/CPU   standard ethernet frames
	78    MB/S/CPU   "jumbo" (~9000 byte) frames.
					(n.b. GB ethernet here...)
</pre>

<p>On an analysis server, allocation of streams to NIC cards is most easily
accomplished statistically. For machines with very many potential streams,
this is best effected by fewer, fatter pipes.  Ideally, there is little packet
loss and traffic is regulated by the TCP window.  If Jumbo frames were
acceptable not generally, but only between the Enstore system and the D0
analysis machine, statistical load balancing over four GB NICs consuming two
CPUS could easily sustain the (imagined) 150 MB/S peak tape rate
for D0, with very little congestion.

<p>The problem becomes more difficult as the throughput of a NIC card
decreases. The basic unit of transfer is a stream carrying the full tape
rate.  (i.e 5 MB/Sfor AIT-2 + some allowance for expansion).  It is in fact,
a little questionable whether two such tape streams should be multiplexed onto
a single 100 MBPS NIC card -- Congestion, slow start and other rate-inhibiting
mechanisms may be invoked.


<p>Other system design and integration issues<p>

<ul>
<li> A specific site for the Enstore installation has not been identified.
<li> The Enstore project has begun to learn about PATROL, but is unaware of
     its formal selection for Run II.
<li> The OSS department has work items relating to installing and administering the
     operating systems for the D0 Enstore system.
<li> Run II authentication systems are TBD.
<li> The Enstore mover machines have not yet been identified.
</ul>



<hr>
<h2><a name="d0req">
8 D0 Requirements
</h2>

As stated in the introduction, D0, and most specifically, SAM, has been very helpful in setting the
direction for what is needed from Enstore.  We believe a close and working
collaboration has been developed in which both SAM and Enstore have
profited.

In the followin subsections, we  present the requirements we have received from D0 and try to
indicate how we fulfill them.  We want to work with D0 to satisfy them
all. This should be possible since we control the source code.

<h3><a name="d0reqa">
8.1 Summary of D0 Functional Specifications
</h3>

<H3>
The Functionality D0 expects of a Storage Management Layer</H3>
There are 6 major functional areas. They are described in more detail
and broken down further below.
<UL>
<LI>
Cataloging and
Database Functions for Files and Tape Volumes</LI>

<LI>
Specification
and Control of Tape Volume Storage Locations</LI>

<LI>
Control of various
parameters which govern the functional behavior and performance of the
system</LI>

<LI>
Management of
the robot resources (including error recovery and tracking)</LI>

<LI>
Movement of files
between users machine/local disk and tape in robot.</LI>

<LI>
Operational procedures
to run and manage the robot, the data stored in the system, the tape drives,
and the "databases"</LI>
</UL>

<H3>
1) Cataloging and Database Functions</H3>


<H3>
1.1) Maintenance of the primary "database" of file
to tape volume information</H3>

<UL>
<LI>
reliable and backed up
"database" of each volume and file. the volume location of each file,
and the position within each volume for each file</LI>

<p>
     Enstore has 2 simple internal databases, the <a href="#volume_clerk">volume</a> and <a href="#file_clerk_cmds">file</a>
databases and the <em>pnfs</em> databases. These databases are based on LIBTP and contain sufficient
information to read each file in Enstore or write new volumes to available volumes.
<p>
We believe LIBTP to
be reliable - although we could replace it with a commercial database such
as Oracle if required.  We have developed backup scripts to recover from
potential database corruption. Finally, we expect the databases to be saved
in a SCSI RAID level 5 system for
redundancy and reliability. We also support live backups without any user impact.
<p>
D0's experiment catalog can also contain the basic information in our
databases. The initial loading of this information is done via the return
information from <em>encp</em>.  And, since we do not expect any movement or compacting of data, this
information should not change.  If it does, syncing methods will need to be developed.
<p>
Enstore also stores data in <em>pnfs's</em> databases, such as the bit file
id.  These <em>pnfs</em> databases have been reliable in our experience and
they are supported by DESY.
<P>

<p> <b><em>Pnfs</em> backup issues are not completely understood and will be treated in DESY visit this February </b></P>

<LI>
assurance that all movement
of files/deletion of files is correctly reflected in the "database"</LI>
<p>
If an experimenter moves or deletes files in the <em>pnfs</em>
file system, it is immediately reflected in the <em>pnfs</em> databases.  Therefore,
in the case of moved files, Enstore still has the correct pointer information
available to it for the transfers; for deleted files, the user won't
be able to find the file in the namespace and won't be able to start
the transfer.
<p>
In addition to the user namespace, Enstore maintains another namespace
that is ordered by file family, tape and position on the tape.  The
user can't delete or move items (UNIX permissions) in this namespace
because it represents the physical ordering of files on
tapes. Recovery of accidental deletions from the user's namespace can
potentially be recovered by using this volume based namespace. [Not
yet implemented.]
<p>
No changes in the internal Enstore databases are required when a user
moves or deletes files since nothing has been moved or deleted on the
physical media.  Initial tools are available to delete entire volumes,
nothing is planned for compacting data on volumes.
<P>

<LI>
notation of volume/file
status (e.g. if unreadable or errors)</LI>
<p>
Enstore has implemented a special format, --data_access_layer, at the end of each file
transfer. The status of the current file transfer is available in this
way. The only successful status code is "OK" and an exit code of
0. All other values represent failures.
<p>
Another possible return is NOACCESS, which indicates the volume
can not be read. This return happens before submission to the library
manager's queue, so it happens very quickly.
<p>
In principle, since SAM has the volume information as Enstore and
could update its tables to reflect the NOACCESS returns. If the 
volume is put back into service, a tool to reflect this change would
have to be developed.
Another possibility is for Enstore to flag the affected files from the
NOACCESS volume in <em>pnfs</em> in pnfs for the user.
<P>
<p><b>
A consistent, apriori way of marking all files from on a
volume unreadable after the volume has been declared unreadable has not
been fully worked through. (The general idea is that SAM never makes
an <em>encp</em> request for files on unreadable tapes.)
</b></P>

<LI>
tracking of the tape volume format</LI>
<p>
Enstore only one format is allowed per tape, it is not possible to mix
formats. Enstore tracks this information in its volume database and errors
out if it doesn't match.
<p>
Another more obvious method we are developing is to add the tape format
to the file family name.  For example, the file family would be "top.cpio"
and not just "top".  In this way, the user can select the format he wants
to use and tapes automatically have just one format (since different
formats would have different file family names.)
<p>
</UL>



<H3>
1.2) Provide access to File namespace
and Volume Information</H3>

<UL>
<LI>
tools for users to easily
and intuitively view all files in the system along with other commonly
needed information about the file - such as owner, 'grouping', date written,
etc.</LI>

<LI>
tools for users to easily
and intuitively view all volumes in the system</LI>

<LI>
tools for viewing file/volume
related information such as all files on a volume</LI>

<p>
Enstore uses the <em>pnfs</em> namespace from DESY and it furnishes all
these items.
<p>
The library manager has commands to list all the volumes in the system or
file family as well as the statistics about specific volumes. 

<p>
Enstore also manages a duplicate namespace that is ordered by file family
and volumes and position on tape that also supplies this information for
the user.
<p>

<LI>
tools for exporting all,
or recently changed parts, of the file and volume database to the
data access layer (for performance reasons) or to remote institutions</LI>

<p><b>
This has not been addressed.
</b></P>


</UL>


<H3>
2) Specification and control of Tape storage locations</H3>

<UL>
<LI>
ability
to handle several distinct robot storage locations</LI>
<p>
Robot storage locations are controlled by the <em>pnfs</em> library
tag. This is user settable.
<p>
<LI>
ability
to treat a single physical robot as multiple logical storage locations</LI>
<p>
Enstore can divide a physical library into many virtual libraries.  Mover
computers, and therefore, tape drives, can be assigned to one or more of
these virtual libraries.
<p>
<LI>
ability
to migrate tape volumes between storage locations</LI>
ability
to handle various physical 'shelves' as possible storage locations</LI>
<p>
Enstore treats 'shelves' as just another library. Tools are available to
change volumes between different libraries.  Insert/Eject tools are being
developed for the EMASS robot to transfer  volumes from robotic storage to
vault shelves.
<p>

<LI>
ability
to import volumes into storage locations (given sufficient meta-data in
an acceptable format)</LI>
<LI>
ability
to export volumes (with their associated meta-data)</LI>
<p> Enstore is developing import and export tools that meet these
requirements as described in <a
href="#impexp">section 5</a>
<p>
<LI>
possibly
implementation of quota system for particular user/group within a storage
location</LI>
<p><b>
This has not been addressed.
</b><P>

</UL>

<H3>
3) Control of parameters which govern the functional
behavior of the system</H3>


<H3>
3.1) Control of parameters which govern allocation
and use of tape drives</H3>

<UL>
<LI>
possibly specification of preference
or affinity between certain access modes, users or groups, and certain
subsets or classes of physical tape drives</LI>
<p> <b>This has not been addressed.</b><P>
</UL>


<H3>
3.2) Control of parameters which govern how files
are written to tape</H3>

<UL>
<LI>
specification of "groupings" or File
Families for files</LI>
<LI>
specification of "width" for a grouping
<p>
File families and widths are a fundamental design notions of Enstore.
<p>
Enstore allows the user to change the file family and width tags in <em>pnfs</em>. Regular
UNIX permissions prevent unauthorized changes.
<P>
<LI>
possibly specification of a list of
files to be treated logically as one 'work unit'</LI>
<p>
Enstore allows a cp-like syntax where the input files can be a list.
<P>
<LI>
specification of "append to tapes"
policy</LI>
<p>
Enstore tries to append to tapes to fill them to their capacity.  Tapes can
also be marked "full" at any point 
<p>
<LI>
specification of file wrappering format</LI>
<p>
Enstore has developed a flexible wrappering module. We want to be able to
support any wrappering format an experiment chooses.  We promote the use of
CPIO formats since it makes the tapes self-describing and readable on any
UNIX machine.
<p>
<LI>
association of tape volumes to a particular
file family and tape library</LI>
<p>
All volumes are inherently assigned to a file family before they are
written to by Enstore. The concept of File families has no meaning for reads.
<p>
Volumes can currently only be in one tape library.
<p>
</UL>

<H3>
<B>3.3) Control of parameters which govern how files
are read from tape</B></H3>

<UL>
<LI>
specification of error/retry behavior</LI>
<p> <b> Cannot do this dynamically, have static retry behavior, and will make
     this comply to D0 needs. </b></P>
</UL>
<H3>
<B>3.4) Control of parameters which govern</B> <B>access
to files and volumes</B></H3>

<UL>
<LI>
access control based on user/group
for each file and each file family</LI>
<p>
<em>Pnfs</em> provides this with normal UNIX file permissions.
</UL>

<H3>
<B>3.5) Control of parameters which govern network
routing between storage system Movers and client machines</B></H3>

<UL>
<LI>
ability to choose optimal path to load
balance in the case of multiple network interfaces on a single machine</LI>
<p>
Enstore provides this through the mover config file and the normal UNIX
table routing files.
<p>
<p>
A simple round-robin plan is envisioned for multiple interfaces.  This can be solved in any
specific case, we are not addressing the general case.
<p><b>
This has not been fully addressed.
</b><P>

</UL>

<H3>
<B>3.6) Ability to set defaults for many/most of
the above parameters</B></H3>

<UL>
<LI>
storing of default values to be used
for all transfers/work done for</LI>

<UL>
<LI>
a particular user/group</LI>
<p> The default value is the logged-in users default values
<p>

<LI>
a particular file family</LI>
<p> File families are inherited from the parent directory.
<p>
<LI>
a particular storage location</LI>
<p> Libraries are also inherited from the parent directory.
<p>
<LI>
? possibly others</LI>
</UL>
</UL>


<H3>
4) Management of the robot resources (including error
recovery and tracking)</H3>

<UL>
<LI>
Maintenance of a queue of work to do
in case of excess demand on the robot or on the tape drives</LI>
<p>
Enstore's library manager maintains a queue of active work and pending
work.
<P>
<LI>
Ability to specify policies governing
the ordering and manipulation of that queue of work, and therefore the
delay seen by the user, including (but not limited to)</LI>

<UL>
<LI>
specification of a priority for all
work requested</LI>
<p>
encp option --priority
<p>
<LI>
specification of a priority increment
and delta time in order to implement a priority boost/aging algorithm (or
equivalent mechanisms)</LI>
<p>
encp option --delpri and --agetime
<p>
<LI>
specification of policy for dismounting
of tapes after work completed</LI>
<p>
encp option --delayed_dismount
<p>
<LI>
other possible parameters to be decided
based on tests/tuning of system</LI>
<p>
</UL>

<LI>
Cleanup of work queue in case of errors
and canceled requesting processes</LI>
<p>
Enstore has spent considerable time developing robust error handling
plans. The queues are cleaned up on errors or canceled requests.
<p>
<LI>
Allocation of tape drives to units
of work in the queue</LI>
<p>
Mover computers can be assigned to a specific library or multiple
libraries. They can be changed dynamically, by an administrator, to reflect
changing load conditions.
<p>
<LI>
Retry of failed file reads/writes
up to specified maximum</LI>
<LI>
Repeat attempts at failed work using
alternate tape drive resources</LI>
<p>
Enstore's philosophy is to retry internally and only return to the user a
success code or a fatal error.  Much work has been done towards this goal.
<p>

<LI>
Notation and tracking of all work done,
all errors encountered, all retries performed</LI>
<p>
encp option  --data_access_layer provides this functionality, including retries.
<p>
</UL>


<H3>
<B>5) Movement of Files
between users machine/local disk and tape in robot.</B></H3>

<UL>
<LI>
ability
to transfer files from any network-connected machine to/from tape drive
in robot</LI>
<p>
Assuming a sufficient network connection, the only requirements are the <em>encp</em> client and the <em>pnfs</em>
namespace. 
<p>
<LI>
ability
to transfer files reliably and with error detection, and correction by
retry</LI>
<p>
This is inherent in Enstore's design
<p>
<LI>
ability
to transfer files at > N% of raw tape bandwidth. N is probably about 50.</LI>
<p>
Assuming a sufficient network connection, data should stream to tape at the
maximum tape speed.  We have designed the mover module to get the most
performance out of the hardware are we can. Operations such as mounting,
spacing, rewinding, etc, slow the overall rate down
and are somewhat beyond the control of Enstore.
<p>
<LI>
nothing
done to exclude the possibility of adding an intermediate disk cache layer
to adjust rate of data movement from tape drive to end user data sink -
should that become necessary</LI>
<LI>
nothing
done to exclude the possibility of cooperation with the data access layer
as a distributed disk cache of recently requested data</LI>

<p>
Disk buffering has not been excluded, as far as we can tell.
<p>

</UL>

<H3>
6) Operational procedures to run and manage the robot,
tape drives and "databases"</H3>


<H3>
6.1) Robot and Tape Drive Hardware</H3>


<UL>
<LI>
Well defined and safe procedures for
dealing with repair and maintenance of the robot itself</LI>
<p>
There is a maintenance contract on the robot.
<p>
Three Enstore people have attended training in Denver on the EMASS robot
<p>
The ESH Department is involved and helping to specify safe
operations. LOTO has already been instituted.
<p>
<LI>
Procedures for monitoring the status
of tape drives and for replacing faulty drives with drives which
have been checked and tested through another well-defined process.</LI>
<p>
Enstore keeps track of drive errors and marks drives as "unavailable" when
they exceed some limit.  It is expected that an administrator review the
bad drives in the morning.
<p>
Extensive 24 hour burn-in tests are planned for all repaired or replaced
drives to ensure that the end-user sees high quality drives.
<p>
</UL>

<H3>
6.2) Operator procedures for import/export of batches
of tapes</H3>

<UL>
<LI>
Interface between Storage Management
system and Operator work/console system</LI>

<LI>
Definition of policies for executing
batch imports/exports of tape volumes</LI>
<p>
Enstore's plans on queuing work requests for volumes that are not in the
robot into 3 categories:
<ul>
  <li> Rejecting the request immediately
  <li> Requesting an operator mount of the volume
  <li> Storing the request into a Insert Volume Queue
</ul>
The policy for which one is chosen is TBD and will be up to the experiment.
<p>
It is expected that an operator will visit the robot at most once/day and
exchange at most 100 volumes per visit.
<p><b>
This issue has not been addressed fully.
<p></b>

       

</UL>

<H3>
6.3) Quality assurance procedures to assure integrity
of the data and metadata</H3>

<UL>
<LI>
Routine backup of "database"</LI>
<p> Routine Live backups of Enstore databases almost finished now.
<p><b> <em>Pnfs</em> backup is TBD </b>
<p> SCSI RAID level 5 system needed for extra protection
<p>
<LI>
Maintenance of a water-tight redo log
of all transaction to be used in case of errors</LI>
<p>
All logs are kept online for at least 30 days and stored to tape after
that. They are as complete as we can make them.
<p>
<LI>
Recovery procedures in place, tested
and executed in case of failures</LI>
<p> We are working on recovery procedures and expect to have them completed
shortly.
<p>
<LI>
Ability to recover files and data on
tape in case of complete and catastrophic loss of all "databases"</LI>
<p>
All volumes are self-describing. Metadata information can be recovered by
scanning the tapes.  [This has not been written!]
<LI>
Routine checks on readability of sample
of tapes - maintenance of statistics</LI>
<p>
Hopefully, normal transfers will allow a big enough sample to perform
routine checks.
<p><b>
This has not been fully addressed.
<p></b>

</UL>


<h3><a name="d0reqb">
8.2 Sam/Enstore Interface Notes.
</h3>


Below are notes on the SAM/Enstore interface provided by D0.
Enstore complies in all software features except where noted.
For the most part, Enstore complies in software features. Exceptions
are noted.

<H3>
SAM/Enstore Interface</H3>
The SAM data access layer uses the command/executable provided by Enstore
to issue file commands.
<P>The basic format of this command is one of the following:
<P><em>encp</em> &lt;input file> &lt;destination directory
in <em>pnfs</em> space>
<BR><em>encp</em> &lt;file in <em>pnfs</em> file space> &lt;output
file>
<P>The exact syntax of the above may be changing somewhat, but is immaterial.
<P>The following enhancements have been requested and (we think) agreed
to by Enstore.
<BR>
<BR>

<TABLE BORDER COLS=3 WIDTH="100%"  NOSAVE >
<TR  NOSAVE>
<TD NOSAVE><b>Request to Enstore</b></TD>
<TD><b>Implementation proposed</b></TD>
<TD><b>Rationale</b></TD>
</TR>



<TR NOSAVE>
<TD NOSAVE>Allow wild cards in input or output file spec. As each file
arrives some notification should be provided.
<br><p><em>The notational issues in this items have not been addressed.
Enstore provides cp-like list features. The user can launch many <em>encps</em>.
Input wildcarding is allowed and furnished by the user's shell glob capabilities. Output
wildcarding is more problematic -- Enstore allows the user to specify an
input list of files and an output directory; in this case the input names
are used in creating the output files in the directory (<it>i.e.</it>,
similar to the UNIX cp command).<P></em>
</TD>

<TD>Enstore will implement notification by writing a message to stdout.
</TD>
<TD>Permits a number of files to be supplied or dispatched serially with
one <em>encp</em>.</TD>
</TR>


<TR>
<TD>Allow list of comma delimited files in input or output file spec
<br><p><em>The notational issues in this items have not been addressed.
Enstore provides cp-like list features and the delimiter in this case is a
space. <p>Notification after each transfer is provided with the --data_access_layer switch.<p></em>
</TD>

<TD>Notification of each file arrival (or dispatch) as for wild cards.</TD>

<TD>Permits a number of files to be supplied or dispatched serially with
one <em>encp</em>.</TD>
</TR>

<TR>
<TD>At the end of each file transaction provide information about the physical
location of the file, its position on the tape, error/retries, which tape
drive it was written on.
<br><p><em> encp provides this with the --data_access_layer option<p></em>
</TD>

<TD>This was originally discussed as being written to stdout along with
informational messages about the state of the copy job. Latest thoughts
appear to be to write all metadata related to the physical location of
the file and how it got there into a separate, but parallel <em>pnfs</em> file system,
into a file of the same name (we think?)</TD>

<TD>It is very convenient when doing queries in order to gather information
on files to optimize access patterns and when making reports, to
have all of the physical information on the files in the SAM Oracle file
and event catalog. Multiple <em>pnfs</em> query calls would be awkward and unsymmetric
with respect to files managed by SAM, but not stored in the Enstore Robot
space.</TD>
</TR>

<TR>
<TD>Allow additional parameters on the Enstore 'copy' command to control
the positioning of the job in the Enstore job queue. Initial priority,
Aging Delta Time and Priority Increment would be sufficient.
<br><p><em> encp provides this with the --priority, --delpri and --agetime
options<p></em>
</TD>

<TD>Exact implementation of the desired effect left to Enstore. Whether
at a certain priority a job becomes pre-emptive of a job already in progress
left for later stages of the project, after some experience with resource
allocation.</TD>

<TD>Need some degree of control over the ordering and priority of jobs
already submitted to the Enstore queue, in order to balance the flows of
data and minimize job latency where necessary, but without rigid allocation
of resources to particular access modes or projects</TD>
</TR>

<TR>
<TD>At the end of each file transaction provide information about the job
which copied the file - dwell time in queue, final priority, robot arm
wait time, file seek time, file transfer time and MBs, etc.
<br><p><em> encp provides this with the --data_access_layer option<p></em>
</TD>

<TD>This is now going to be available in the parallel <em>pnfs</em> file metadata
file system</TD>

<TD>This information is needed by the Global Resource Manager in order
to feed into the algorithm which adjusts the rate of flow of jobs by access
mode.</TD>
</TR>

<TR>
<TD>When an Enstore job fails because of a tape error or failure of the
receiving <em>encp</em> (or network or whatever) the job queue of Enstore should
be cleaned up appropriately.
<br><p><em> Failed transfers are flushed from the Enstore queues. <p></em>
</TD>

<TD>Could live without this in 1st implementation, but would be nice to
determine what is appropriate behavior in each of the possible failure
modes. We are expecting automatic retries when tape cannot be read or written
in a particular drive and the tape only marked as unreadable if tried in
n drives.</TD>

<TD>SAM does not wish to handle tape errors, tape statistics or retries
- merely to note relevant information on state of media and record drive
used in the File and Event Catalog</TD>
</TR>

<TR>
<TD>If the STK robot and a couple of drives cannot be hooked up with an
Enstore test system by October 1, then Enstore needs to emulate the delays
of a robot for Tape mount, File seek time, and File transfer time, in order
to test the Global Resource Manager.
<br><p><em> SAM has used Enstore to write to both the STK robot and the EMASS robots. <p></em>
</TD>

<TD>Part of this is already implemented as a 'simple' model. Is this
adequate - it is not installed yet, SAM have not tried it.</TD>

<TD>Essential to simulate queuing for scarce resources - the tape drive,
and the network bandwidth.</TD>
</TR>
</TABLE>

<BR>

<h3><a name="d0reqc">
8.3 Other D0, non-SAM Requests to Enstore
</h3>

Besides the preceding requests from SAM, other D0 experimenters have
suggested features, based on their experience, that would make Enstore more
usable.  We consider these requests valid and we will try to implement
them; however, since some of the requests are outside of the main
SAM framework, we assign them a lower priority and, in the cases where they
conflict with mainline SAM architecture, we will only start them after all
SAM requests have been satisfied and have extensive testing.

<ul>

  <li> Enstore should assign drives randomly, not just the first few drives.
       <p> Enstore uses all drives, not just the first ones, to allocate
       work. <p>

<li> Users, not just administrators, need easy access to the information
   about successful and failed mounts and transfers. 
     <p> Enstore logs will be available on the web for users to inspect. We
     welcome help! <p>

<li> A separate log with just mounts and a success/failure code would be
   useful.
     <p> Enstore will provide this capability, also available on the web. <p>

<li> All information in a log needs to be on a single line, otherwise it is
   impossible for mortals to parse.
     <p> Enstore logs are all single, sometimes very long, lines. <p>

<li> Enstore needs a procedure (certify job) that replaced drives must pass
   before they are put back into service.  This procedure should last
   around 24 hours and should exercise all functions.  It is foolish to put
   drives back in service and have them fail again right away.
     <p> This is planned. <p>

<li> Broken drives should be replaced. This budget should rest outside of the
   experiment.
     <p> Enstore agrees but doesn't set this policy. <p>

<li> Enstore should be able to deal in volumes. Ie, transfer a whole tape to
   disk and vice versa.
     <p> <b>All SAM traffic is with files, so this request is contrary to the
     SAM architecture. </b> It is currently possible to write a list of files to
     a tape. It is also possible to query the system to list the files that
     are on a tape, and then use that list to copy all the files to the
     disk. We believe these methods to be adequate. Otherwise,
     this issue will have to be developed and represents new work. <p>

<li> D0 needs a scripts to create Enstore importable tapes.
     <p> Enstore will provide these. <p>

<li> D0 is not interested in file sets. The impact on the databases is not
    so great that all the entries can't just in entered.
     <p> Enstore will not implement any file set features. <p>

<li> Enstore needs the capability to override its priority queue and do
    things in the exact order requested.
     <p><b> This request is outside the mainline SAM architecture which has
     indicated it wants priorities and optimal transversals of tapes.
     Moreover, this request is not straightforward and requires defeating the Enstore
     system in many ways and we'd prefer not to do it. More explicit needs can be addressed as they arise.</b> <p>

<li> Enstore needs to guarantee a certain set of files are grouped on tape.
     <p> This can be done with ephemeral file families that have a width
     of 1. Or, it can be done if only 1 user is writing to the file family
     at a time. <p>

<li> Enstore needs to duplicate important data.
     <p><b> This is part of the overall architecture, but it is not yet
     developed.</b> <p>

<li> Bad tapes need to be flagged for SAM to handle.  Maybe mark pnfs
    filenames so transfer is never tried? What does DESY do?
     <p><b> This is TBD.  We will discuss it with DESY during our upcoming
     visit.</B> <p>

<li> Direct RPC calls to the pnfs server might be nice so a user would not
    have to mount pnfs.
     <p><b> This is outside the main SAM architecture and there are no current plans to implement this.</b> <p>

</ul>

<hr>
<h2><a name="manp">
9 WBS and Effort Estimates
</h2>

The original plan for Enstore was to start with a working prototype,
representing about 6-8 months of effort, and evolve the code to the
initial release of the Enstore product for Run II.  This approach has been
followed.  There has been substantial overlap and simultaneous development
in all phases the WBS plan.  One of Enstore's original goals was to have a
working system during all phases of the development.  This, too, has been
achieved. This goal has slightly lengthened and sometimes constrained
overall development.  (For example, incompatibilities between the original
file/volume database design and the current one led to extra effort to
allow simultaneous operation of both design.) Overall, however, the ability
of D0 to test the Enstore software as it needed to,  provided valuable
feedback to us allowing us to allocate effort to problem areas.
<p>
Generally, the project is on track to its original estimate.  I believe
Enstore needs its current work force of 6 people, (Bakken, Berman, Huang,
Moibenko, Rechenmacher, Ruthmansdorfer) or their equivalents until May 99.
After May the Run II effort could drop to 4 people.  I expect to be able to
deliver a fully Run II functional version of Enstore by the end of July
99. At that point, I expect serious integration to be well underway with
D0.  Depending on how well this commissioning goes, what further
requirements and enhancements are deemed necessary, the Run II Enstore
effort could drop to 2-3 people.
<p>
Beyond the Run II work, Enstore will require effort to fulfill its
Computer Division strategic role in Mass Storage for the Laboratory. It is
expected that this work will begin in the Summer 99 time frame. The scope
and requirements of this effort are not yet fully determined.
<p>
The basic design philosophy of Enstore is to use layered products when
possible. There are  2 products which need to be updated or enhanced to
make Enstore fully functional:
<ul> 
 <li> OCS for Run II
  <ul>
    <li> Enstore plans on using OCS for the few operator mounts that are
    required for Run II operations.  OCS needs to streamlined to allow this
    capability.
    <li> OCS has been deemed the long term repository of tape and drive
    statistics. A mechanism for sending these statistics will be needed.
  </ul>
 <li> FTT optimization for selected drive and media
  <ul> 
   <li> FTT is the Fermilab source of all media and drive knowledge.  This
  product will have to be enhanced to use all the capabilities, for example
  partitioning, of the drive that is chosen by the Serial Media Working
  Group for Run II.
  </ul>
</ul>
<p>

Below is the current Storage Management WBS.  Instructions were to quit
working on it if it was correct to a factor of 2.  I believe the actual
estimate is good to 0.5. I have attempted to fill in the percentage
complete column in the WBS with a step of 25%.  Items listed as 0%
generally mean that no coding has been done for this item. It doesn't 
mean no thought has gone into the item. Some thought has gone into each item.
<p>

<table border="1">
    <tr>
        <th bgcolor="#DFDFDF"><NOBR>ID</NOBR></th>
        <th align="left" bgcolor="#DFDFDF"><NOBR>Task Name</NOBR></th>
        <th bgcolor="#DFDFDF"><NOBR>Duration</NOBR></th>
        <th bgcolor="#DFDFDF"><NOBR>Start</NOBR></th>
        <th bgcolor="#DFDFDF"><NOBR>Finish</NOBR></th>
        <th align="left" bgcolor="#DFDFDF"><NOBR>Resource Names</NOBR></th>
        <th bgcolor="#DFDFDF"><NOBR>% Complete</NOBR></th>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">1</td>
        <td bgcolor="#FFFFFF" style="margin-left:4"><b>Storage
        Management</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>151 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 4/20/01</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">24%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">2</td>
        <td bgcolor="#FFFFFF" style="margin-left:16">Management -
        ongoing 50% of JAB</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>120 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 9/15/00</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[50%]</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">3</td>
        <td bgcolor="#FFFFFF" style="margin-left:16">D0 Liaison -
        ongoing</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>120 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 9/15/00</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[20%]</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">4</td>
        <td bgcolor="#FFFFFF" style="margin-left:16">Hardware and
        Interface Problem Resolution - ongoing (DJH)</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>80 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 1/7/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 7/19/00</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[20%]</td>
        <td align="right" bgcolor="#FFFFFF">25%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">5</td>
        <td bgcolor="#FFFFFF" style="margin-left:16"><b>Working
        Operations</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>8.6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Sat 5/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 7/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">6</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Working OCS
        for operator mounts</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>0 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Sat 5/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Sat 5/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">7</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Working
        Interface to Tape/Drive Repository</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>0 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Sat 5/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Sat 5/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">8</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Working FTT
        with drive chosen by serial media working group</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>0 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 6/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 6/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">9</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Working
        Drives and Media in Robot for D0</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>0 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 7/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 7/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">10</td>
        <td bgcolor="#FFFFFF" style="margin-left:16"><b>Enstore
        V1</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>56.2 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/28/99</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[450%]</td>
        <td align="right" bgcolor="#FFFFFF">51%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">11</td>
        <td bgcolor="#FFFFFF" style="margin-left:28"><b>Organization
        and Methods of Working&nbsp;&nbsp;&nbsp;&nbsp; </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>56.2 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/28/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">69%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">12</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Packaging
        methods </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/26/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">13</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Coding
        standards </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/26/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">14</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Development
        tools </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/26/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">15</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Bug
        reporting and tracking procedure (GNATS)</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 6/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 6/28/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">16</td>
        <td bgcolor="#FFFFFF" style="margin-left:28"><b>Requirements&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
        </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>33 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 10/26/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/11/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">69%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">17</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Input and
        specification from experiments </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 10/26/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">18</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Input and
        specification from mss groups and operators </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 12/7/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">19</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Understand
        commonality of requirements and iterate </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 12/7/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">20</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Understand
        interfaces to other Run II Projects </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 12/7/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">21</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Understand
        testing dates and scope </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 12/7/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">22</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Understand
        hardware constraints </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/22/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 3/4/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">23</td>
        <td bgcolor="#FFFFFF" style="margin-left:40">Agree on
        change control mechanisms </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 5/3/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/11/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">24</td>
        <td bgcolor="#FFFFFF" style="margin-left:28"><b>Evolution
        of Prototype to Run II Product&nbsp;</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>51.2 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 7/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 6/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">47%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">25</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Client
        server framework </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/3/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 9/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">26</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Communications
        protocol and errors </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/3/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 9/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">27</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Robustness </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/3/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 9/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">28</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Error
        handling philosophy </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>16 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/3/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/20/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">29</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Component
        Retries </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/3/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 8/28/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">30</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">End-to-end
        recovery </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/31/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 9/25/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">31</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Fault
        tolerance and availability </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 9/28/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 10/23/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">32</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Reliability </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 10/26/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/20/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">33</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Encp
        framework&nbsp; </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12.8 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 9/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/27/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">83%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">34</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Design
        evaluation </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 9/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 9/28/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">35</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Options and
        switch analysis </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 9/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 9/28/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">36</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Optimization
        </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/27/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">37</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Binary
        distribution studies </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 10/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 11/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">38</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Improvements
        to Servers/Clients and Clerks Design </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>35 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 9/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 5/3/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">71%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">39</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Configuration
        server and clients </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 10/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 11/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">40</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Library
        manager and clients </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>20 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 12/15/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 5/3/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">41</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Media
        Changer and clients </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>10 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 12/15/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 2/22/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">50%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">42</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Volume clerk
        and clients </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">43</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">File clerk
        and clients </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/11/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">44</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Log server
        and clients </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>2 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 9/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 9/14/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">45</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Mover
        Modifications</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>19 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 3/12/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">38%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">46</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">File
        wrappering - self describing, different types, etc </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>8 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/25/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">50%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">47</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Optimization
        </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>8 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/25/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">48</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Read/Write
        Entire Volumes</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 2/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 3/12/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">49</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">FTT - new
        drives to support </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 2/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 2/26/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">50</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Testing
        Framework </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>18.2 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 3/8/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">63%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">51</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Debug and
        integration framework </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 12/15/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 3/8/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">50%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">52</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Configure
        Test Hardware Platform </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/27/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">100%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">53</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Database
        framework&nbsp; </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>17 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 2/26/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">45%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">54</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Evaluation
        of underlying database choice </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>8 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 1/4/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 2/26/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">25%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">55</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">User Queries
        </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/27/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">25%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">56</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Fault
        tolerance </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 11/27/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">57</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Backup </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 12/15/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 1/11/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">58</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Admin
        tools&nbsp; </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>48.6 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 7/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/4/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">26%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">59</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Pnfs </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>8 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 7/1/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 8/25/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">75%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">60</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Web status </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>22 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 11/2/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 4/2/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">25%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">61</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">User queries
        and reports </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>22 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 1/4/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 6/4/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">25%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">62</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">System and
        Tape Monitoring and Statistics (Patrol)</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>14 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 2/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 5/7/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">63</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Volume
        Import/Export</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>8 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 2/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 3/26/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">64</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Facility to
        Export/Eject Tapes from EMASS Robot</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 3/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 3/26/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">65</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Facility to
        Import Foreign Tapes to EMASS Robot</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 2/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 2/26/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">66</td>
        <td bgcolor="#FFFFFF" style="margin-left:40"><b>Security,
        with respect to Fermilab Policy </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 4/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 6/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">67</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Data
        protection, Authentication, Access </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 4/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 6/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">68</td>
        <td bgcolor="#FFFFFF" style="margin-left:52">Accidents </td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 4/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Wed 6/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">69</td>
        <td bgcolor="#FFFFFF" style="margin-left:16"><strong>Documentation</strong></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>24 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 7/6/98</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/18/98</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[600%]</td>
        <td align="right" bgcolor="#FFFFFF">50%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">70</td>
        <td bgcolor="#FFFFFF" style="margin-left:16"><b>Integration
        </b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>33.4 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/23/99</NOBR></td>
        <td bgcolor="#FFFFFF">JPP</td>
        <td align="right" bgcolor="#FFFFFF">9%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">71</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Integration
        with Experiment RIP and Production Farms</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>28 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 7/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">25%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">72</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Integration
        with Experiment Data Handling and Analysis</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>28 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 1/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Thu 7/15/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">73</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Commissioning</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 6/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">74</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Tuning</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>10 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 6/1/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/9/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">75</td>
        <td bgcolor="#FFFFFF" style="margin-left:16"><b>Enstore
        V2</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>16 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/10/99</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[250%]</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">76</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Support for
        Commissiong of D0 before run starts</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>16 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/10/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">77</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Addition of
        new features as discovered</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>16 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 8/23/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 12/10/99</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">78</td>
        <td bgcolor="#FFFFFF" style="margin-left:16"><b>Enstore
        V3</b></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>16 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 1/4/00</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 4/24/00</NOBR></td>
        <td bgcolor="#FFFFFF">JPP[250%]</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">79</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">Support for
        run</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>16 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 1/4/00</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 4/24/00</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">80</td>
        <td bgcolor="#FFFFFF" style="margin-left:28">New features
        discovered when there is beam</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>12 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Tue 1/4/00</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 3/27/00</NOBR></td>
        <td align="right" bgcolor="#FFFFFF">&nbsp;</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
    <tr>
        <td align="center" bgcolor="#FFFFFF">81</td>
        <td bgcolor="#FFFFFF" style="margin-left:16">Ongoing
        Support</td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>52 wks</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Mon 4/24/00</NOBR></td>
        <td align="right" bgcolor="#FFFFFF"><NOBR>Fri 4/20/01</NOBR></td>
        <td bgcolor="#FFFFFF">JPP</td>
        <td align="right" bgcolor="#FFFFFF">0%</td>
    </tr>
</table>
<p>

<hr>
<h2><a name="manp">
10 Year 2000 Issues
</h2>

Problems associated with two digit year differences fall into 3 broad
categories for the Enstore project:
<ul>
  <li> The Enstore code itself.  We believe the Enstore code is clean and
       does not have Y2K problems. This category includes the Enstore
       python and  C code and the libtp python and C code.
  <li> Generally supported Fermilab products that Enstore depends on.  We are
       relying on the Fermilab developers and supporters to ensure that this
       code is error free.  We do not know of any Y2K problems with the
       Fermilab products we use.  This category includes FTT and
       OCS. Fermilab's Year 2000 web page is
       <a href="http://dcdserver1.fnal.gov/year2000">http://dcdserver1.fnal.gov/year2000.</a>
  <li> Finally there are vendor products and freeware products that Enstore
       depends on.  We are relying on the vendor to supply working software
       that doesn't have any year 2000 troubles.  Moreover, we believe none
       of the vendor software currently has this type of difficulty. This category includes EMASS
       robotic library software (ACI), STK robotic library software and the
       python interpreter.
</ul>

</body>
</html>
