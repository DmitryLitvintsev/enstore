{\rtf1\mac
\deff10
{\fonttbl
{\f0\fmodern Courier;}
{\f1\fnil ZapfDingbats;}
{\f2\fmodern Courier;}
{\f3\fswiss Helvetica;}
{\f4\ftech Symbol;}
{\f5\fswiss Helvetica;}
{\f6\froman Times;}
{\f7\ftech Symbol;}
{\f8\froman Times;}
{\f9\fnil ZapfDingbats;}
{\f10\froman Times;}
{\f11\froman Times;}
}
{\colortbl ;
\red0\green0\blue0;
\red255\green255\blue255;
\red255\green0\blue0;
\red0\green255\blue0;
\red0\green0\blue255;
\red0\green255\blue255;
\red255\green0\blue255;
\red255\green255\blue0;
}
{\stylesheet
{\s1\f11\fs36\b\ulnone\cf1 \fi-900\li900\sb360\sa180\keepn\sl-419\tx900 \sbasedon0\snext7 apndx_heading1;}
{\s2\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 \sbasedon0\snext7 apndx_heading2;}
{\s3\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 \sbasedon0\snext7 apndx_heading3;}
{\s4\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 \sbasedon0\snext7 apndx_heading4;}
{\s5\f11\fs48\b\ulnone\cf1 \qc\li720\ri720\sb960\sa960\keepn\sl560 \sbasedon0\snext5 apndx_title;}
{\s6\f10\fs24\ulnone\cf1 \qj\fi-720\li1080\sb80\sa80\sl280\tx1080 \sbasedon0\snext6 bib_item;}
{\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 \sbasedon0\snext7 body;}
{\s8\f10\fs24\ulnone\cf1 \qj\li360\ri360\sb120\sa120\sl280 \sbasedon0\snext8 body_center1;}
{\s9\f10\fs24\ulnone\cf1 \qj\li720\ri720\sb120\sa120\sl280 \sbasedon0\snext9 body_center2;}
{\s10\f10\fs24\ulnone\cf1 \qj\li1080\ri1080\sb120\sa120\sl280 \sbasedon0\snext10 body_center3;}
{\s11\f10\fs24\ulnone\cf1 \qj\li1440\ri1440\sb120\sa120\sl280 \sbasedon0\snext11 body_center4;}
{\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \sbasedon0\snext12 body_indent1;}
{\s13\f10\fs24\ulnone\cf1 \qj\li720\sb120\sa120\sl280 \sbasedon0\snext13 body_indent2;}
{\s14\f10\fs24\ulnone\cf1 \qj\li1080\sb120\sa120\sl280 \sbasedon0\snext14 body_indent3;}
{\s15\f10\fs24\ulnone\cf1 \qj\li1440\sb120\sa120\sl280 \sbasedon0\snext15 body_indent4;}
{\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 \sbasedon0\snext16 bullet;}
{\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 \sbasedon0\snext17 bullet_indent1;}
{\s18\f10\fs24\ulnone\cf1 \qj\fi-360\li1080\sb80\sa80\sl280\tx1080 \sbasedon0\snext18 bullet_indent2;}
{\s19\f10\fs24\ulnone\cf1 \qc\sb80\sa80\sl280 \sbasedon0\snext19 center_textline;}
{\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 \sbasedon0\snext20 code_fragment;}
{\s21\f10\fs20\ulnone\cf1 \qc\sl200 \sbasedon0\snext21 date_pagefooter;}
{\s22\f10\fs24\ulnone\cf1 \qj\fi-3240\li3600\sb240\sa240\sl280\tx3600 \sbasedon0\snext22 define_longkey;}
{\s23\f10\fs24\ulnone\cf1 \qj\fi-1800\li2160\sb240\sa240\sl280\tx2160 \sbasedon0\snext23 define_shortkey;}
{\s24\f11\fs20\b\ulnone\cf1 \qc\sl200 \sbasedon0\snext24 draft_pagefooter;}
{\s25\f10\fs24\ulnone\cf1 \qc\sb240\sa240\sl280 \sbasedon0\snext25 equation;}
{\s26\f11\fs24\b\ulnone\cf1 \qc\sb240\sa480\sl-280 \sbasedon0\snext26 figure_label;}
{\s246\f10\fs20\ulnone\cf1 \qj\fi-360\li720\sb200\sa80\sl240\tx720 \sbasedon0\snext246 Footnote;}
{\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 \sbasedon0\snext7 heading1;}
{\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 \sbasedon0\snext7 heading2;}
{\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 \sbasedon0\snext7 heading3;}
{\s30\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 \sbasedon0\snext7 heading3_nonum;}
{\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 \sbasedon0\snext7 heading4;}
{\s32\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 \sbasedon0\snext7 heading4_nonum;}
{\s33\f11\fs24\b\ulnone\cf1 \qc\sb360\sa360\sl-280 \sbasedon0\snext33 label_nonum;}
{\s34\f10\fs24\ulnone\cf1 \qr\sb120\sa120\sl280 \sbasedon0\snext34 pagenum;}
{\s35\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 \sbasedon0\snext38 step1;}
{\s36\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 \sbasedon0\snext39 step1_indent1;}
{\s37\f10\fs24\ulnone\cf1 \qj\fi-360\li1080\sb80\sa80\sl280\tx1080 \sbasedon0\snext40 step1_indent2;}
{\s38\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 \sbasedon0\snext38 stepN;}
{\s39\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 \sbasedon0\snext39 stepN_indent1;}
{\s40\f10\fs24\ulnone\cf1 \qj\fi-360\li1080\sb80\sa80\sl280\tx1080 \sbasedon0\snext40 stepN_indent2;}
{\s41\f11\fs24\b\ulnone\cf1 \qc\li360\sb480\sa240\keepn\sl-280 \sbasedon0\snext41 table_label;}
{\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \sbasedon0\snext42 tableB_cellbody;}
{\s43\f11\fs24\b\ulnone\cf1 \sl-280 \sbasedon0\snext43 tableB_cellheading;}
{\s44\f10\fs20\ulnone\cf1 \fi-349\li467\ri467\sb60\sl-240\tx467 \sbasedon0\snext44 TableFootnote;}
{\s45\f10\fs18\ulnone\cf1 \sb80\sa80\sl-219 \sbasedon0\snext45 tableS_cellbody;}
{\s46\f11\fs20\b\ulnone\cf1 \sb100\sa100\sl-240 \sbasedon0\snext46 tableS_cellheading;}
{\s47\f11\fs48\b\ulnone\cf1 \qc\li720\ri720\sb960\sa960\keepn\sl560 \sbasedon0\snext47 title;}
{\s48\f10\fs20\ulnone\cf1 \qj\sb80\sa80\sl240 \sbasedon0\snext48 title_pagefooter;}
{\s61\f10\fs18\ulnone \sl-219 \sbasedon0\snext61 SortSpecIX;}
{\s58\f10\fs18\ulnone\cf1 \fi-360\li540\sl-200 \sbasedon0\snext58 Level2IX;}
{\s56\f11\fs24\b\ulnone\cf1 \fi-720\li720\sb240\sl-280\tx720\tqr\tx9360 \sbasedon0\snext56 apndx_heading1TOC;}
{\s55\f10\fs24\ulnone\cf1 \fi-720\li1440\sb80\sl-280\tx1440\tqr\tldot\tx9360 \sbasedon0\snext55 apndx_heading2TOC;}
{\s54\f10\fs20\ulnone \fi-900\li2340\sb40\sl-240\tx2340\tqr\tldot\tx9360 \sbasedon0\snext54 apndx_heading3TOC;}
{\s53\f10\fs20\ulnone\cf1 \fi-900\li3240\sl-240\tx3240\tqr\tldot\tx9360 \sbasedon0\snext53 apndx_heading4TOC;}
{\s60\f10\fs18\ulnone \sl-219 \sbasedon0\snext60 SpecIX;}
{\s62\f11\fs18\b\ulnone\cf1 \sb200\keepn\sl-219 \sbasedon0\snext62 GroupTitlesIX;}
{\s64\f10\fs24\ulnone\cf1 \sl-280 \sbasedon0\snext64 Paragraph;}
{\s63\f10\fs18\ulnone\cf1 \sl-219 \sbasedon0\snext63 IndexIX;}
{\s65\f10\fs24\ulnone \fi-1440\li1440\sb40\sl-280\tx1440\tqr\tldot\tx8640 \sbasedon0\snext65 FigureLOF;}
{\s59\f10\fs18\ulnone \fi-720\li720\sl-200 \sbasedon0\snext59 Level1IX;}
{\s68\f10\fs20\ulnone\cf1 \li1007\sb60\sl240 \sbasedon0\snext68 BulletedCont;}
{\s67\f0\fs20\ulnone\cf1 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \sbasedon0\snext67 Code;}
{\s52\f11\fs24\b\ulnone\cf1 \fi-720\li720\sb240\sl-280\tx720\tqr\tx9360 \sbasedon0\snext52 heading1TOC;}
{\s51\f10\fs24\ulnone\cf1 \fi-720\li1440\sb80\sl-280\tx1440\tqr\tldot\tx9360 \sbasedon0\snext51 heading2TOC;}
{\s50\f10\fs20\ulnone \fi-900\li2340\sb40\sl-240\tx2340\tqr\tldot\tx9360 \sbasedon0\snext50 heading3TOC;}
{\s49\f10\fs20\ulnone\cf1 \fi-900\li3240\sl-240\tx3240\tqr\tldot\tx9360 \sbasedon0\snext49 heading4TOC;}
{\s57\f11\fs24\b\ulnone \fi-1440\li1440\sb320\sl-280\tx1440\tqr\tx9360 \sbasedon0\snext57 apndx_titleTOC;}
{\s66\f10\fs24\ulnone \fi-1440\li1440\sb40\sl-280\tx1440\tqr\tldot\tx8640 \sbasedon0\snext66 TableTitleLOT;}
}
{\info{\comment Version of miftortf translator 5.1.}}
\paperw12240\paperh15840
\margl1440\margr1440
\margt1440\margb1440
\widowctrl\ftnbj\revisions\pgnstart1\ftnstart1
\ftnrestart\revbar2

\page
\sectd\sbkpage{\header }
{\footer \pard\plain\s48\f10\fs20\ulnone\cf1 \qj\sb80\sa80\sl240 Fermi Tape Tools (ftt) Library User\'d5s Guide
\par
\pard\plain\s21\f10\fs20\ulnone\cf1 \qc\sl200 \f10 \revised {\chdate }\f10 \par
\pard\plain\s24\f11\fs20\b\ulnone\cf1 \qc\sl200 Version 
v1_0
\par
\pard\plain\s34\f10\fs24\ulnone\cf1 \qr\sb120\sa120\sl280 \f10 \revised {\chpgn }\f10 \par
}
\cols1\colsx0
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {1\tab }Getting Started
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {1.1    }Basic Concepts
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 T
he 
\f10 \f11\b ftt
\b0\f10  library is used by creating a 
\f10 \f11\b descriptor
\b0\f10  for each tape drive being used
 and making various 
\f10 \f11\b ftt
\b0\f10  calls using that descriptor. The 
\f10 descriptor
\f10  itself c
ontains information about what system 
\f10 \f11\b devic
es
\b0\f10  are associated with the tape drive, what densities and formats are available, etc. 
T
o get a 
\f10 \f11\b descriptor
\b0\f10  for a particular tape drive, you need to know the 
\f10 \f11\b basename
\b0\f10  of the drive, which is basi
cally a common substring of the various system devices associated with the tape drive. Another 
important data 
structure i
s the 
\f10 \f11\b ftt_stat_buf
\b0\f10  which is used to hold tape drive 
statistics o
btained from 
the tape drive.
 T
hese types, as well as all of the function prototypes, preprocessor definitions, etc. 
are found in the 
\f10 \f11\b ftt.h
\b0\f10  header file.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {1.2    }Starting and Finishing
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The 
\f10 \f11\b ftt
\b0\f10  library can be used either to do tape input and output, to manage tape drives, to get infor
mation about tape 
devices,
 or all of the above.   All of these activities start with a call to
 
\f10 \f11\b f
tt_open
\b0\f10  
to get an
 
\f10 \f11\b f
tt
\b0\f10  descriptor.
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include <ftt.h
>
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d
;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 d = ftt_open(\'d2/dev/rmt0\'d3, FTT_RDONLY)
;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 /* do some stuff here */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_close(d);
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 There are several items that should be mentioned here.:
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }The header file 
\b0\f10 \f11\b ftt.h
\b0\f10  is included.
 T
his file contains the various preprocessor symbols and 
function 
declarations f
or users of the 
\f10 \f11\b ftt
\b0\f10  library.
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }We declare the 
\b0\f10 \f11\b descriptor
\b0\f10  variable with a type named 
\f10 \f11\b ftt_descriptor
\b0\f10 .
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }We pass in a read-only/read-write flag to the open call
.
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }\b0\f10 ftt_close
\f10  f
rees up all the memory associated with the 
\f10 \f11\b descriptor
\b0\f10  and closes any open sys
tem devices associated with the drive.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 If your program needs to deal with multiple tape drives, it can call 
\f10 \f11\b ftt_open
\b0\f10  multiple times, 
to g
et 
a 
unique 
\f10 \f11\b descriptor
\b0\f10  for each drive
. I
t should then issue an 
\f10 \f11\b ftt_close
\b0\f10  on each descriptor it got from 
\f10 \f11\b ftt_open
\b0\f10  before exiting
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {1.3    }Doing Input and Output
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Once you have a 
\f10 \f11\b descriptor
\b0\f10 , very often you want to read data from the associated drive, or write 
data to it.
 T
he
 
\f10 \f11\b f
tt
\b0\f10  library calls to read and write data look very much like the UNIX system calls 
\f10 \f11\b read
\b0\f10  a
nd
 
\f10 \f11\b w
rite
\b0\f10  a
nd are called (you guessed it)
\f10 \f11\b  ftt_read
\b0\f10  and 
\f10 \f11\b ftt_write
\b0\f10 .
 B
oth take as arguments the
 
\f10 \f11\b d
escriptor
\b0\f10  for the tape drive involved, a character pointer to the data buffer, and the number of 
bytes requested to be read or written.
 B
oth return the number of bytes actually transferred,
 o
r -1 to 
indicate an error. 
T
he calls look like:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 length = ftt_read(d, buffer, buffer_length);
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 or;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 length = ftt_write(d, buffer, data_length)
;
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {2\tab }Finding out what went wrong
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 If your
 
\f10 \f11\b f
tt
\b0\f10  calls return an error (a value of -1 for
 
\f10 \f11\b f
tt_read
\b0\f10  or 
\f10 \f11\b ftt_write
\b0\f10  or a value of 0 from
 
\f10 \f11\b f
tt_open
\b0\f10  
for example), you may want to know specifically what went wrong.
 T
o find out 
the specific error 
condition, y
ou can use the routine called 
\f10 \f11\b ftt_get_error
\b0\f10  which gives you an error string
 a
nd (op
tionally) an error number
. I
f you simply want to tell the user what went wrong, you can do 
something as simple as:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 fprintf(stderr, \'d2%s\\n\'d3, ftt_get_error(0));
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 which will print the error string on standard error.   If your program wants to attempt to do some
thing to recover from errors, you will need to pass a pointer to an integer into the first argument of 
\f10 \f11\b ftt_get_error
\b0\f10  which will give you back an error number.
 T
hen you can attempt to take appropriate 
action based on the error. This looks like:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *p;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int n;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ...
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 p = ftt_get_error(&n);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 if (n == FTT_ENOTAPE) \{
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab request_tape_mount();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \}
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The error numbers you get from 
\f10 \f11\b ftt_get_error
\b0\f10  will be one of the following
:
\f10 \par
\trowd\trrh0\trql\clbrdrb\brdrhair\clmgf\trgaph120\cellx2794 
\pard\plain\s41\f11\fs24\b\ulnone\cf1 \qc\li360\sb480\sa240\keepn\sl-280 \intbl {TABLE  1.    }\f11\b \f11\b ftt error codes
\cell
\clbrdrb\brdrhair\clmrg\trgaph120\cellx7834 
\cell \row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl ftt_errno
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Description
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_SUCCESS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl no error has occurred
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EPERM
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl you do not have permission to perform the specified 
operation on the device.
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENOTAPE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl there is no tape in the drive
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EFAULT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl you gave a buffer address range whose access yields a 
memory fault
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENOSPC
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl A write attempted to cross end of media
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENOENT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl User attempted to set density to a nonexistent one
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EIO
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Physical read or write error.0
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_
EBLKSIZE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Attempt to write
/read unsupported block size s
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENOEXEC
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Attempt to run setuid executable for security bypass 
failed -- not executable
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EBLANK
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Encountered blank tape (i.e. passed logical EOT)
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EBUSY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Asynchronous 
I/
O is g
oing on this device, or another 
process has it open
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENODEV
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl System does not have drive configured
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EINVAL
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl invalid compression flag value, or bad statbuf pointer, 
etc.
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENXIO
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Tried to contact a nonexistant process
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENFILE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl No system file descriptors available
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENOT
TAPE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl What we thought was a tape device was not.
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EROFS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Tape is write protected
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EWRONGVOL
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Wrong volume label on tape for verification
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EWRONGVOLTYP
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Wrong type of label on tape for verification
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ELEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl hit tape leader while skipping backwards
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EFILEMARK
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl hit file mark while skippin
g
 records
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ERWFS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Tape is not write protected (and should be)
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EPIPE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Setuid bypass died
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ENOMEM
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Unable to allocate memory required to perform call
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ERANGE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Record too large for buffer
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_E
NOTS
UPPORTED
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Unsupported device 
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EUNRECOVERED
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl previous error was 
unrecoverable,
 tape can only be 
unloaded/rewound 
(
to protect data
)
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2794 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EPARTIALSTAT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7834 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl unable to obtain some or all of the information 
requested
\cell
\row
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Your code can compare the error number (
\f10 \f11\b n
\b0\f10  in our example) to the 
values i
n this table to decide 
what went wrong in the preceding 
\f10 \f11\b ftt
\b0\f10  library call.
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {3\tab }Opening/closing Device
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 In general, to access a device, the user need simply call 
\f10 ftt_open()
\f10 . He can then perform normal 
tape operations (e.g., read, write, rewind). 
\f10 ftt_open()
\f10  doesn\'d5t actually open this device with the 
unix device driver. It simply creates/initializes the 
\f10 ftt 
\f10 file descriptor. Once the descriptor is created, 
the user can 
explicitly o
pen a thread to the device driver with 
\f10 ftt_open_dev()
\f10 , although this is not 
necessary. All 
\f10 ftt
\f10  routines will internally call 
\f10 ftt_open_dev() 
\f10 if the device has not yet been opened.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 A utility routine, 
\f10 ftt_open_logical()
\f10 , is provided to create an 
\f10 ftt
\f10  descriptor for a possibly fictitious 
device. It provides the opportunity to see what the various device names would be for specific 
modes/densities on a different operating system platform. The average user would not use this rou
tine to open the device, but would use 
\f10 ftt_open()
\f10  instead. 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The pair of close routines, 
\f10 ftt_close()
\f10  and f
\f10 tt_close_dev()
\f10 , are similar in function to the pair of 
open routines, f
\f10 tt_open() 
\f10 and 
\f10 ftt_open_dev()
\f10 . In general, the user need simply call 
\f10 ftt_close()
\f10  
when finished with the device. This routine will internally call 
\f10 ftt_close_dev()
\f10  if needed. 
\f10 ftt_close_dev() 
\f10 will ensure that the proper number of filemarks have been written at the end of tape 
(if writing) and that the tape is correctly positioned. 
\f10 ftt_close()
\f10  will free the 
\f10 ftt
\f10  file descriptor.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 It\'d5s important to note that some 
\f10 ftt
\f10  routines will internally call 
\f10 ftt_close_dev()
\f10 , which may write 
filemarks, if they need to close the normal unix device driver and open the raw scsi device. The 
documentation for the individual subroutines will indicate if a specific routine exhibits this 
behavior. 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Note that several f
\f10 tt_open_dev()
\f10  and f
\f10 tt_close_dev()
\f10  pairs can be called within a single 
\f10 ftt_open() 
\f10 and 
\f10 ftt_close()
\f10  pair.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {3.1    }\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  ftt_open
\f11\b \b0\f10 (char
\f11\b \b0  *basename, 
\f11\b \b0 int
\f11\b \b0  rdonly)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 opens a 
\f10 \f6\i basename
\i0\f10  for a device and returns a 
\f10 \f6\i descriptor, 
\i0\f10 which can be used to perform other 
operations on the device. The 
\f10 basename
\f10 \f11\b  
\b0\f10 argument can also be a full device name for a tape de
vice, and will internally be trimmed to a basename. 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The 
\f10 rdonly
\f10 \f11\b  
\b0\f10 argument indicates 
\par
\trowd\trrh0\trql\clbrdrb\brdrhair\clmgf\trgaph120\cellx2880 
\pard\plain\s41\f11\fs24\b\ulnone\cf1 \qc\li360\sb480\sa240\keepn\sl-280 \intbl {TABLE  2.    }rdonly flag values
\cell
\clbrdrb\brdrhair\clmrg\trgaph120\cellx5760 
\cell \row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Value
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx5760 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Description
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_RDONLY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx5760 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Device will not be written on
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_RDWR
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx5760 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Device is read and writable.
\cell
\row
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Note that FTT_RDONLY does not check that the device is physically write protected, nor does 
FTT_RDWR check that is not physically write protected; a call to 
\f10 \f11\b ftt_status 
\b0\f10 is required to ob
tain that information.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 This routine performs no positioning of the device.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Note that 
\f10 ftt_open
\f10  and 
\f10 ftt_close
\f10  do not need to be called to switch between reading and writ
ing, to cross filemarks, etc. The ftt software will perform operating system opens and closes as 
needed to allow those transitions.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_open
\b0\f10  does not perform any operations on the tape drive or tape devices, it simply does 
bookkeeping to prepare for such operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 d = f
tt_open(\'d2/dev/rmt/tps2d4\'d3, FTT_RDWR);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {3.2    }\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 ftt_open_logical(
\f11\b \b0\f10 c
har *
\f11\b \b0 basename, 
\f11\b \b0\f10 char *
\f11\b \b0 os, 
\f11\b \b0\f10 char 
*
\f11\b \b0 driveid, 
\f11\b \b0\f10 int 
\f11\b \b0 rdonly)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Create a (possibly mythical) ftt_descriptor for a device of type 
\f10 driveid 
\f10 on operating system 
\f10 os
\f10 , 
using base device name 
\f10 basename
\f10 , with 
\f10 rdonly
\f10  as in 
\f10 \f11\b ftt_open
\b0\f10 . This call will be used internally 
to construct a descriptor, but can also be used in combination with other 
\f10 ftt 
\f10 calls to see what 
the name of the high density EXB-8500 tape device would be on IRIX from an IBM system. 
Performing any actual tape-io from this descriptor will probably fail unless the 
\f10 os
\f10  and 
\f10 driveid
\f10  
and 
\f10 basename
\f10  are valid for the current system.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 d = f
tt_open_logical(\'d2/dev/rmt/tps2d4\'d3, \'d2IRIX\'d3, \'d2EXB-8500\'d3, 
FTT_RDWR);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {3.3    }\f11\b \b0\f10 int
\f11\b \b0  ftt_open_
dev
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Explicitly perform a UNIX open of the device
 f
or the currently selected density, etc. Routines 
which need the device open to work will call 
\f10 \f11\b ftt_open_dev
\b0\f10  if they need to.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 If the density and mode have not been set by 
\f10 \f11\b ftt_set_mode(), ftt_set_mode_dev(), 
\b0\f10 etc., the de
fault density and compression mode of the highest density the device supports and no 
compression will be used.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The routine may sets appropriate modes and/or flags on the underlying device to allow other ftt 
operations to proceed properly.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_open_dev
\b0\f10  performs antecessor operations to set the device density, etc. and actually per
forms an operating system open on the device
.
 No tape motion is performed.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_open_dev(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {3.4    }\f11\b \b0\f10 int
\f11\b \b0  ftt_close
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The 
\f10 \f11\b ftt_close 
\b0\f10 entry releases a descriptor, indicating that no further operations will be performed 
on that descriptor. If a device has been opened not closed, an 
\f10 \f11\b ftt_close_dev 
\b0\f10 will be performed.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_close
\b0\f10  will invoke 
\f10 \f11\b ftt_close_dev
\b0\f10  if needed, but performs no other tape or device operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_close(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {3.5    }\f11\b \b0\f10 int
\f11\b \b0  ftt_close_
dev(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 This call closes the system device which was opened by 
\f10 \f11\b ftt_open_dev
\b0\f10 , after ensuring proper 
double file mark termination of written data. To ensure this, if writes have been successfully 
performed since the last rewind or other tape motion, it writes two filemarks and backspaces 
over them before closing the device. Note that this means that if you are writing, perform an 
\f10 \f11\b ftt_close_dev
\b0\f10  followed by an 
\f10 \f11\b ftt_open_dev
\b0\f10 , and continue writing, you will overwrite the 
filemarks that 
\f10 \f11\b ftt_close_dev
\b0\f10  wrote.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Note that 
\f10 \f11\b ftt_close_dev
\b0\f10  can fail, due to insufficient room to write tape filemarks, etc.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_close_dev
\b0\f10  performs a close on the operating system device
.
 It will only perform tape mo
tion (writing filemarks and backspacing) if the preceding operation was a write or write 
filemark. No other operations or tape motions are performed.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_close_dev(d);
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {4\tab }Reading/Writing
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 All of these routines return -1 on failure, for which more information can be 
obtained a
s described 
in the section on 
\f10 \f6\i Finding out what went wrong.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {4.1    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_read
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d, 
\f11\b \b0 char *
\f11\b \b0 buf, 
\f11\b \b0 int
\f11\b \b0  length)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 If called with the tape positioned before a data block, the 
\f10 \f11\b ftt_read
\b0\f10  entry reads a block of length 
at most
\f10 \f11\b  
\b0\f10 \f10 length
\f10 \f11\b  
\b0\f10 from the tape into buffer
\f10 \f11\b  
\b0\f10 \f10 buf
\f10 , and returns the length of the block actually read. 
If the next block on the tape will not fit into the buffer, or if any other error occurs, -1 will be 
returned
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 If called with the tape positioned before an end-of-file mark, 0 is returned, and the position is 
moved to just after the end-of-file mark.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char data[32768]
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_read(d,data,32768);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {4.2    }\f11\b \b0\f10 int
\f11\b \b0  ftt_write
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d,
 
char *buf, 
\f11\b \b0 int
\f11\b \b0  length)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The ftt_write entry transfers as much as possible of the block in buffer 
\f10 buf
\f10  of 
\f10 length
\f10  to the tape, 
and returns the length written, unless an error occurs, in which case -1 is returned. The tape is 
positioned after the written block.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 In the case of an unrecoverable error, an error number of FTT_UNRECOVERED will be re
turned for this call, and all subsequent calls made until one of 
\f10 \f11\b ftt_rewind, ftt_unload,
\b0\f10  
\f10 \f11\b ftt_close_dev, 
\b0\f10 or 
\f10 \f11\b ftt_close
\b0\f10  is called.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char data[32768]
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_write(d,data,32768);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {4.3    }\f11\b \b0\f10 int
\f11\b \b0  ftt_writefm
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The ftt_writefm entry writes a single filemark to the tape. After the call, the tape position is af
ter the written filemark.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_writefm(d);
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {5\tab }Moving around on the tape
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Tape drives allow you to do more then just read and write, they also allow you to move around the 
tape, and perform other operations.
 T
he 
\f10 \f11\b ftt
\b0\f10  library contains several calls for tape motion
.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 All of these routines return -1 on failure, for which more information can be 
obtained a
s described 
in the section on 
\f10 \f6\i Finding out what went wrong.
\i0\f10 \par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.1    }\f11\b \b0 int
\f11\b \b0  
ftt_skip_fm
 (
\f11\b \b0 ftt_descriptor
\f11\b \b0  d,
\f11\b \b0  int
\f11\b \b0  count)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 s
kips forwards to just after a filemark, or backwards to just before a filemark. 
\f10 co
unt
\f10  
indicates 
the n
umber of filemarks to skip.
 
\f10 c
ount
\f10  should be negative to skip backwards.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = f
tt_skip_fm(d, 3);
\par
\pard\plain\s68\f10\fs20\ulnone\cf1 \f10 \li1007\sb60\sl240 to skip forward 3 filemarks, or
:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = 
ftt_skip_fm(d, -2);
\par
\pard\plain\s68\f10\fs20\ulnone\cf1 \f10 \li1007\sb60\sl240 to skip backwards 2 filemarks.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.2    }\f11\b \b0 int
\f11\b \b0  
ftt_skip_rec
 (
\f11\b \b0 ftt_descriptor
\f11\b \b0  d,
\f11\b \b0  int
\f11\b \b0  count)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 s
kips forward just past records, or backwards just before records.
 
\f10 c
ount
\f10  i
ndicates the n
umber 
of records to skip.
 
\f10 c
ount
\f10  should be negative to skip backwards. 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = 
ftt_skip_rec(d, 3);
\par
\pard\plain\s68\f10\fs20\ulnone\cf1 \f10 \li1007\sb60\sl240 to skip forward 3 records, or:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = 
ftt_skip_rec(d, -2);
\par
\pard\plain\s68\f10\fs20\ulnone\cf1 \f10 \li1007\sb60\sl240 to skip backwards 2 records.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.3    }\f11\b \b0 int
\f11\b \b0  
ftt_skip_to_double_fm
 (
\f11\b \b0 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 s
kips forward until it finds two filemarks in a row, and positions the tape between the two 
filemarks.
 T
his is often useful for appending to unlabeled tapes.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = 
ftt_skip_to_double_fm(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.4    }\f11\b \b0 int
\f11\b \b0  
ftt_rewind
 (
\f11\b \b0 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 s
kips backwards to the beginning of tape. 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_rewind(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.5    }\f11\b \b0\f10 i
nt 
\f11\b \b0 ftt_retension
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d
)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 retensions a
nd rewinds tape.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_rewind(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.6    }\f11\b \b0 int
\f11\b \b0  
ftt_unload
 (
\f11\b \b0 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 e
jects the tape from the tape drive (if possible).
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_unload(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {5.7    }\f11\b \b0 int
\f11\b \b0  
ftt_erase
 (
\f11\b \b0 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 e
rase
s and rewinds t
he tape in the tape drive (if possible).
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_erase(d)
;
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {6\tab }D
ensities, 
Compression,
 and other Modes
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The various tape drives generally
 r
ead and write at a particular 
\f10 \f11\b density
\b0\f10  (which refers to the amount 
of data per length or area of tape), and often have some densities they can read and write, some they 
can only read, etc.
 I
n 
addition d
rives can use 
\f10 \f11\b compression
\b0\f10  to write less data on the tape.
 A
lso, many 
operating systems provide devices with various software-generated modes, such as having the 
drive rewound when the system device is closed, or 
retensioned w
hen it is opened.   The 
\f10 \f11\b ftt
\b0\f10  library 
provides several calls for dealing with these various sorts of mode settings.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 All of these routines normally return a character pointer to a string containing the name of whatever 
system device will be used to perform I/O in this mode.
 T
he routines all return 0 if anything goes 
wrong, see the section 
\f10 \f6\i Finding out what went wrong
\i0\f10  for a discussion of errors.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {6.1    }\f11\b \b0 char *
\f11\b \b0 ftt_set_mode
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d, 
\f11\b \b0\f10 int 
\f11\b \b0 density, 
\f11\b \b0\f10 int
\f11\b \b0  cmp, 
\f11\b \b0\f10 int
\f11\b \b0  
blocksize) 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 l
ets you pick a specific density number
 in 
\f10 density
\f10 , turn compression on or off
 in 
\f10 cmp
\f10 , and set 
variable blocking, or a given fixed blocksize
 in 
\f10 blocksize
\f10 .
 T
his mainly has effect for writing 
tapes, since most drives will automatically switch densities when reading to match the density 
at which the tape was written.
 
\f10 b
l
ocksize 
\f10 is specified in bytes, with a 
\f10 blocksize
\f10  of zero indicating 
variable block mode.
 T
he routine returns the name of the system device it will use for opera
tions at that 
density,
 etc. 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *name;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int density;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int cmp = TRUE;
\tab \tab \tab \tab /* compression on */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int blocksize = 0;
\tab \tab \tab \tab /* variable block */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 n
ame = ftt_set_mode(d, density, cmp, b
lock
size);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {6.2    }\f11\b \b0 char *
\f11\b \b0 ftt_get_mode
 (
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d, 
\f11\b \b0\f10 int *
\f11\b \b0 density, 
\f11\b \b0\f10 int
\f11\b \b0  *cmp, 
\f11\b \b0\f10 int
\f11\b \b0  
*blocksize) 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 t
ells you what density
 in 
\f10 density
\f10 ,
 compression
 in 
\f10 cmp
\f10 ,
 and blocksize 
in blocksize 
were last set 
by 
\f10 \f11\b ftt_get_mode
\b0\f10 .
 T
his is mainly useful to find out what defaults were set, which should be the 
highest density, uncompressed format for the drive you are using. You pass in pointers to the 
integers you want back, so that the rout
i
ne can return multiple values
. 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *name;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int density;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int cmp;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int blocksize;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 name = ftt_get_mode(d, &density, &cmp, &b
lock
size);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {6.3    }\f11\b \b0 char *
\f11\b \b0 ftt_avail_mode
 (
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d, 
\f11\b \b0\f10 int 
\f11\b \b0 density, 
\f11\b \b0\f10 int
\f11\b \b0  cmp, 
\f11\b \b0\f10 int
\f11\b \b0  
fixed) 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 t
ells you whether a call to 
\f10 \f11\b ftt_set_mode
\b0\f10  with a given set of arguments should succeed, although 
it only checks whether the last argument is zero or nonzero, to indicate fixed blocksize or vari
able, respectively. It similarly returns the system device name that would be used when doing 
input/output at that density, etc.
 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *name;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int density;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int cmp = TRUE;
\tab \tab \tab \tab /* compression on */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int fixed = FALSE;
\tab \tab \tab \tab /* variable block */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 name = ftt_avail_mode(d, density, cmp, fixed);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {6.4    }\f11\b \b0\f10 char 
\f11\b \b0 *ftt_density_to_name (
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 int 
\f11\b \b0 density)
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Translates an integer density number to a descriptive string or name.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {6.5    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_name_to_density (
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d,
\f11\b \b0\f10  char *
\f11\b \b0 name)
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Translates a name to an integer density number. The name can be any prefix of a density string 
which would be returned by 
\f10 \f11\b ftt_density_to_name()
\b0\f10  for that device.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {6.6    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_get_max_blocksize (
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d)
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Returns the largest blocksize usable on this drive type and platform, suitable for getting a block 
size to allocate for a read/write or copy buffer.
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {7\tab }Dealing with System Device Names
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The various operating systems have multiple device names which are associated with the same tape 
drive.
 F
or example, the IRIX operating system currently has 38 device nodes for a single 8500 tape 
drive.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.1    }\f11\b \b0\f10 char **
\f11\b \b0 ftt_list_all
 
(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 returns a pointer to a static list of device pathnames related to this drive.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_list_all
\b0\f10  performs no tape operations. It returns the list of devices we think should be present, 
which is determined when 
\f10 \f11\b ftt_open_logical
\b0\f10  is called.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char **all_names;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 all_names = ftt_list_all(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.2    }\f11\b \b0\f10 int
\f11\b \b0  f
tt_chall
 
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 int 
\f11\b \b0 uid, 
\f11\b \b0\f10 int
\f11\b \b0  gid, 
\f11\b \b0\f10 int
\f11\b \b0  mode)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 All character special devices relating to the file named by descriptor have their ownership 
changed to the pass-ed in uid, gid. and are set to the given mode. This call will only succeed if 
called with the appropriate permissions, it will not be handled by a setuid executable.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_chall
\b0\f10  performs no tape operations, it merely changes permissions on the devices in 
\f10 \f11\b /dev
\b0\f10 .
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.3    }\f11\b \b0 int
\f11\b \b0  
ftt_get_mode_dev
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 char *
\f11\b \b0 devname, 
\f11\b \b0\f10 int 
*
\f11\b \b0 density,
\f11\b \b0\f10  int 
\f11\b \b0 *cmp, 
\f11\b \b0\f10 int *
\f11\b \b0 fixed,
\f11\b \b0\f10  int *
\f11\b \b0 rewind)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Returns the density in 
\f10 density
\f10 ,
 c
ompression in 
\f10 cmp
\f10 ,
 f
ixed block flag
, 
\f10 f
ixed
\f10 , and rewind/
retension 
s
tatus in 
\f10 rewind
\f10  f
or the device 
\f10 devname
\f10 .
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The 
\f10 rewind
\f10  value returned will have a value of 
\f10 \f11\b FTT_RWOC, FTT_RTOO
\b0\f10 , or bitwise combi
nations of these values, to indicate ReWind On Close and ReT
ension O
n Open, respectively.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 A 
\f10 fixed 
\f10 value
\f10  of 0 indicates variable blocking, a
 
\f10 f
ixed
\f10  of 1 indicates fixed block operation,
\f10 \f6\i  
\i0\f10 \f10 but 
does not provide the current blocksize.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_get_mode_dev
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \f0 \f10\fs24  
\f0\fs20 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *devname = \'d2/dev/my_favorite_device\'d3;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int density;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int cmp;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int fixed;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int rewind
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_mode_dev(d, devname, &density, &cmp, &fixed, 
&rewind);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.4    }\f11\b \b0 int
\f11\b \b0  
ftt_set_mode_dev
 
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d,
 
\f11\b \b0\f10 c
har * 
\f11\b \b0 devname,  
\f11\b \b0\f10 int 
\f11\b \b0 force)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Sets the compression, density, etc. to match that of the device name passed in. The argument 
must be a name associated with the device opened by 
\f10 \f11\b ftt_open
\b0\f10 . 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The 
\f10 force
\f10  flag (if set to one) forces the exact device name specified to be used, allowing access 
to devices which are otherwise unsupported.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_set_mode_dev
\b0\f10  performs no tape operations, it merely sets flags, etc. which will be used by 
\f10 \f11\b ftt_open_dev.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \f0 \f10\fs24  
\f0\fs20 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *devname = \'d2/dev/my_favorite_device\'d3;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int force = FALSE;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_set_mode_dev(d, devname, force);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.5    }\f11\b \b0 int
\f11\b \b0  
ftt_describe_dev
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 char *
\f11\b \b0 devname, 
\f11\b \b0\f10 FILE *pf
\f11\b \b0 )
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280  prints a description of the given device indicated in 
\f10 devname
\f10 , listing the density, compression 
options, rewind modes, etc. on the file 
\f10 pf
\f10 . It returns the number of bytes written on the file. This 
routine performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include <stdio.h>
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *devname = \'d2/dev/my_favorite_device\'d3;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_describe_dev(d, devname, stdout);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.6    }\f11\b \b0 char *
\f11\b \b0 ftt_get_basename
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 returns the basename for the device; thereby the basename for a tape device can be found by 
doing an 
\f10 \f11\b ftt_open
\b0\f10  followed by an 
\f10 \f11\b ftt_get_basename.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_get_basename
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *basename;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 basename = ftt_get_basename(d)
\f0 \revised ;
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {7.7    }\f11\b \b0\f10\revised int 
\f11\b \b0\revised ftt_list_supported(
\f11\b \b0\f10\revised FILE *
\f11\b \b0\revised pf)
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 \f10 \revised Prints a description of the device types and operating systerms that ftt officially supports on the file 
descriptor 
\f10 \f11\b\revised pf
\b0\f10 \revised . No ftt descriptors need to be open to make this call.
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {8\tab }T
ape Statistics
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Tape drives (especially newer ones) maintain a wealth of information about how much data they 
have written, how many errors they encountered, etc.
 The following table lists the various statistics 
that ftt keeps track of and what type of statistic i
t i
s: string, numeric, counter, or flag. Note that all 
drives do not support all statistics. 
\par
\trowd\trrh0\trql\clbrdrb\brdrhair\clmgf\trgaph120\cellx2880 
\pard\plain\s41\f11\fs24\b\ulnone\cf1 \qc\li360\sb480\sa240\keepn\sl-280 \intbl {TABLE  3.    }ftt statistics
\cell
\clbrdrb\brdrhair\clmrg\trgaph120\cellx7200 
\cell \clbrdrb\brdrhair\clmrg\trgaph120\cellx9360 
\cell \row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl stat
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Description
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Notes
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_VENDOR_ID
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Inquiry vendor id data
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_PRODUCT_ID
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Inquiry product id 
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_FIRMWARE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Inquiry firmware rev level
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_SERIAL_NUM
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Device serial number
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_HOURS_ON
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Number of
 hours d
evice has been on
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_CLEANING_BIT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Device thinks it needs cleaning
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_READ_COUNT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Decimal number of blocks read since 
rewind/
reset
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_WRITE_COUNT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Decimal number of blocks written 
since 
rewind/reset
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_READ_ERRORS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Read errors
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_WRITE_ERRORS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Write errors
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_DENSITY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Mode Sense 
Tape density
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_READ_COMP
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Compression factor for reads
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_
WRITE_C
OM
P
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl C
ompression factor
 for writes
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_FILE_NUMBER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl File number from BOT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_BLOCK_NUMBER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Block number in current file
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_BOT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl at beginning of tape
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_READY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Device ready status
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_WRITE_PROT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Device write protect status
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_FMK
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl At filemark
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_EOM
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl At end of 
media (early w
arning)
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_PEOT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl At physical end of tape (really at end)
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_MEDIA_TYPE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl S
CSI Media type
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_BLOCK_SIZE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Tape block size 
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_BLOCK_TOTAL
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Number of blocks on tape
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TRANS_DENSITY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Translated density 
ala f
tt_get_mode
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TRANS_COMPRESS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Translated compression 
ala f
tt_get_mode
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_REMAIN_TAPE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Remaining KB of tape
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_USER_READ
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl KB read since open/unload
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_USER_WRITE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl KB written since open/unload
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_CONTROLLER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Controller t
ype
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ILI
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI ILI bit from Req Sense
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_SCSI_ASC
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Additional Sense Code
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_SCSI_ASCQ
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Additional Sense Code Qualifier
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_PF
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI PF 
flag
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_CLEANDED_BIT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI cleaned bit
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TRACK_RETRY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Track retry errors
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_UNDERRUN
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl stop/start counter from EXB 8505s
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_MOTION_HOURS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl hours tape drive is in motion
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TUR_STATUS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Test Unit Ready response
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_COUNT_ORIGIN
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Origin of read/write kb counters
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_N_READS
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Number of read calls
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_N_WRITES
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Number of write and writefm calls
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl counter
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TNP
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Exabyte Tape Not Present bit
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl flag
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_SENSE_KEY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl SCSI Request 
Sense K
ey
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl numeric
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TRANS_SENSE_KEY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7200 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Above translated to strings
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl string
\cell
\row
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.1    }\f11\b \b0\f10 ftt_stat_buf
\f11\b \b0  ftt_alloc_stat
 
(void)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 allocates a statistic buffer for use with the other ftt statistics routines.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf stbuff;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 stbuff = ftt_alloc_stat();
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.2    }\f11\b \b0\f10 int
\f11\b \b0  ftt_free_stat(
\f11\b \b0\f10 ftt_stat_buf
\f11\b \b0  stbuff)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 frees a statistic buffer indicated by 
\f10 stbuff
\f10 .
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf stbuff;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_free_stat(stbuff);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.3    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_get_stats(
\f11\b \b0 ftt_descriptor
\f11\b \b0  d, 
\f11\b \b0 ftt_stat_buf
\f11\b \b0  stbuff)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 extracts current statistics for tape usage, including data written, data read, write errors, read er
rors, etc. and packs it into an ftt_stat_buf structure, 
\f10 stbuff
\f10 .
 N
ote that because on some platforms 
we must close and reopen devices to implement this call, ftt_get_stats will always put filemarks 
on your tape if you have been writing (see 
\f10 \f11\b ftt_close_dev
\b0\f10 )
.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf stbuff;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 stbuff = ftt_alloc_stat();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_stats(d,stbuff);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.4    }\f11\b \b0\f10 char *
\f11\b \b0 ftt_extract_stats
 
(
\f11\b \b0\f10 ftt_stat_buf 
\f11\b \b0 b, 
\f11\b \b0\f10 int
\f11\b \b0  stat)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 extracts a string describing a named piece of tape data, indicated by stat. Acceptable values for 
stat are listed in Table 2. The routine will return a null pointer (0) if a given statistic is not avail
able in the status block.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_extract_stats
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include <stdio.h>
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *value;
\tab \tab \tab \tab \tab /* value of extracted stat */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf stbuff;
\tab \tab \tab \tab \tab /* statistics buffer */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status, ftt_status;
\tab \tab \tab \tab \tab /* status of ftt calls */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *estring;
\tab \tab \tab \tab \tab /* error string */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 stbuff = ftt_alloc_stat();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_stats(d,stbuff);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 if (status == -1)
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \{
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    estring = ftt_get_error(&ftt_status);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    fprintf (stderr, \'d2Error: %s Error String: %s \\n\'d3,
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200       ftt_ascii_error[ftt_status],estring);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \}
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 value = ftt_extract_stats(stbuff,FTT_MOTION_HOURS);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_free_stat
(
stbuff);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.5    }\f11\b \b0\f10 void 
\f11\b \b0 ftt_sub_stats
 
(
\f11\b \b0\f10 ftt_stat_buf 
\f11\b \b0 b1
\f11\b \b0\f10 , ftt_stat_buf 
\f11\b \b0 b2
\f11\b \b0\f10 , ftt_stat_buf 
\f11\b \b0 res)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 subtracts numeric values in the stat buffer 
\f10 b1
\f10  from
 t
he values in 
\f10 b2
\f10 \f11\b  
\b0\f10 and the result is put in 
\f10 res
\f10 , 
to keep running totals, and/or compute deltas. String values are taken from 
\f10 b1
\f10 , unless the entry 
in 
\f10 b1
\f10  is null and the one in 
\f10 b2
\f10  is not. Flag values are taken from 
\f10 b1
\f10 .
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Note that media type and compression rates, while technically numeric, are not treated as such 
by these routines, since subtracting them is meaningless.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_sub_stats
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include <stdio.h>
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status, ftt_status;
\tab \tab \tab \tab \tab /* status of ftt calls */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *estring;
\tab \tab \tab \tab \tab /* error string */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf b1,b2,res;
\tab \tab \tab \tab \tab /* statistics buffers */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200  
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 b1 = ftt_alloc_stat();
\tab \tab \tab \tab \tab \tab /* get buffers */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 b2 = ftt_alloc_stat();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 res = ftt_alloc_stat();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_stats(d,b1);
\tab \tab \tab \tab \tab \tab /* get tape statistics */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 if (status == -1)
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \{
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    estring = ftt_get_error(&ftt_status);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    fprintf (stderr, \'d2Error: %s Error String: %s \\n\'d3,
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200       ftt_ascii_error[ftt_status],estring);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \}
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 /* do some tape i/o here */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_stats(d,b2);
\tab \tab \tab \tab \tab \tab /* get tape statistics again 
*/
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 if (status == -1)
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \{
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    estring = ftt_get_error(&ftt_status);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    fprintf (stderr, \'d2Error: %s Error String: %s \\n\'d3,
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200       ftt_ascii_error[ftt_status],estring);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \}
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_sub_stats(b1, b2, res);
\tab \tab \tab \tab \tab \tab /* get deltas and store in res 
*/
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_free_stat
(
b1);
\tab \tab \tab \tab \tab \tab /* free buffers */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_free_stat
(
b2);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_free_stat
(
res);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.6    }\f11\b \b0\f10 void 
\f11\b \b0 ftt_add_stats
 
(
\f11\b \b0\f10 ftt_stat_buf 
\f11\b \b0 b1
\f11\b \b0\f10 , ftt_stat_buf 
\f11\b \b0 b2
\f11\b \b0\f10 , ftt_stat_buf 
\f11\b \b0 res) 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 adds numeric values in the stat buffer 
\f10 b1
\f10 \f11\b  
\b0\f10 t
o
 t
he values in 
\f10 b2 
\f10 and the result is put in 
\f10 res
\f10 , to keep 
running totals, and/or compute deltas. String values are taken from 
\f10 b1
\f10 , unless the entry in 
\f10 b1
\f10  is 
null and the one in 
\f10 b2
\f10  is not. Flag values are taken from 
\f10 b1
\f10 .
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Note that media type and compression rates, while technically numeric, are not treated as such 
by these routines, since adding them is meaningless.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_add_stats
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example: see ftt_sub_stats example.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.7    }\f11\b \b0\f10 ftt_stat_buf *
\f11\b \b0 ftt_init_stats
 
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 returns pair of 
statistics b
uffers. The first is initialized with zeros and the second with current 
statistics for the drive. 
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 This routine performs a 
\f10 \f11\b ftt_get_stats
\b0\f10  which in turn calls 
\f10 \f11\b ftt_close_dev
\b0\f10  which will write file 
marks if the preceding operation was a write or write file mark.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf *bp;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 bp = ftt_init_stats(d);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.8    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_update_stats
 
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 ftt_stat_buf *
\f11\b \b0 bp)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 updates the status pair 
\f10 bp
\f10 \f11\b , 
\b0\f10 keeping running totals in 
\f10 bp[0]
\f10  and latest statistics in 
\f10 bp[1]
\f10 .This rou
tine performs a 
\f10 \f11\b ftt_get_stats
\b0\f10  which in turn calls 
\f10 \f11\b ftt_close_dev
\b0\f10  which will write file marks if 
the preceding operation was a write or write file mark.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf *bp;
\tab \tab \tab \tab \tab /* status buffer pair */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\tab \tab \tab \tab \tab /* ftt file descriptor */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status, ftt_status;
\tab \tab \tab \tab \tab /* status of ftt calls */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *estring;
\tab \tab \tab \tab \tab /* error string */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 bp = ftt_init_stats(d);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 /* do some tape i/o here */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_update_stats(d,bp);
\tab \tab \tab \tab \tab \tab /*
 u
pdate statistics again */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 if (status == -1)
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \{
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    estring = ftt_get_error(&ftt_status);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    fprintf (stderr, \'d2Error: %s Error String: %s \\n\'d3,
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200       ftt_ascii_error[ftt_status],estring);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    \}
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {8.9    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_dump_stats
 
(
\f11\b \b0\f10 ftt_stat_buf 
\f11\b \b0 b, 
\f11\b \b0\f10 FILE *
\f11\b \b0 pf)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 prints important statistics from the statistics buffer 
\f10 b 
\f10 on file descriptor 
\f10 pf
\f10 \f11\b . ftt_dump_stats
\b0\f10  per
forms no tape I/O. It returns the number of bytes written on the file.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include <stdio.h>
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_stat_buf stbuff;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 stbuff = ftt_alloc_stat();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_stats(d,stbuff);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_dump_stats (stbuff,stderr);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_free_stat
(
stbuff);
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {9\tab }\f11\b \b0\fs32  
\f11\fs36\b \b0 S
tatus Routine
s
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {9.1    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_status(
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d, 
\f11\b \b0\f10 int 
\f11\b \b0 timeout)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 returns a flags word with the following bits set:
\par
\trowd\trrh0\trql\clbrdrb\brdrhair\clmgf\trgaph120\cellx2880 
\pard\plain\s41\f11\fs24\b\ulnone\cf1 \qc\li360\sb480\sa240\keepn\sl-280 \intbl {TABLE  4.    }ftt_status flag bits
\cell
\clbrdrb\brdrhair\clmrg\trgaph120\cellx9360 
\cell \row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Bit setting
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Description
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_
A
BOT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl At beginning of tape
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_
A
EOT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl At Physical end of tape
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_
A
EW
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl At Early Warning mark near EOT
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_PROT
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Write Protected tape
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ONLINE
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl A tape is loaded and online
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx2880 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_BUSY
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx9360 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl The tape is rewinding, unloading, etc. and not responding.
\cell
\row
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 indicating the current tape position. This routine shall block up to 
\f10 timeout
\f10 \f11\b  
\b0\f10 seconds if there is a 
tape in the drive, waiting for the tape to come online, or to become not busy. If we cannot de
termine the presence of a tape, we will simply block until the timeout expires.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 An external setuid executable will be run to obtain this data if necessary (e.g. AIX), which 
means that file marks will be written if the last operation was a 
\f10 \f11\b ftt_write
\b0\f10  or 
\f10 \f11\b ftt_writefm,
\b0\f10  (see 
\f10 \f11\b ftt_close_dev
\b0\f10 ()). Therefore, calling 
\f10 \f11\b ftt_status
\b0\f10  after every write 
should b
e avoided.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d; 
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_status(d, 0);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {9.2    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_get_position(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 int *
\f11\b \b0 file, 
\f11\b \b0\f10 int *
\f11\b \b0 block)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 returns the current 
\f10 file
\f10  and 
\f10 block
\f10  position on the tape. It ails if no tape is loaded, or the position 
is unknown (i.e. the tape was just opened, has never been rewound and is not at BOT.) Note that 
both 
\f10 file
\f10  and 
\f10 block
\f10  are zero at BOT, the count is the number of file marks we are past BOT and 
the number of blocks past the last filemark, where BOT is treated as the 0-th filemark.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_get_position
\b0\f10  performs no tape operations, it merely reports bookkeeping information.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int fileno, blockno
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_get_position(d, &fileno, &blockno);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {9.3    }\f11\b \b0\f10 char *
\f11\b \b0 ftt_get_error
 
(
\f11\b \b0\f10 int *
\f11\b \b0 pn)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 returns a pointer to a string describing the result of the last call. If 
\f10 pn
\f10  is not null, it is treated as 
an integer pointer and the current error number is stored there.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_get_error
\b0\f10  performs no tape operations. Any mode sense data reported was obtained by the 
routine reporting the error.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include <stdio.h>
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int error;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *estring;
\tab \tab \tab \tab \tab /* error string */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 estring = ftt_get_error(&ftt_status);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 fprintf (stderr, \'d2Error: %s Error String: %s \\n\'d3,
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200    ftt_ascii_error[
e
rror],estring);
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {10\tab }V
olume verification
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {10.1    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_write_vol_label
 
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 int 
\f11\b \b0 type, 
\f11\b \b0\f10 char *
\f11\b \b0  vollabel)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 rewinds the tape, formats a label specified in 
\f10 vollabel
\f10  into a buffer, and writes the label on the 
tape, then writes two filemarks and backs over one by doing an 
\f10 \f11\b ftt_close_dev 
\b0\f10 and forward skip
ping one filemark.
\f10 type
\f10  can be any of the types specified in 
\f10 \f11\b ftt_guess_label 
\b0\f10 (except 
FTT_DONTCHECK)
\f10 \f11\b .
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 This routine performs numerous tape operations.
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_write_vol_label(d, FTT_ANSI_HEADER,\'d3mydog\'d3);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {10.2    }\f11\b \b0\f10 int
\f11\b \b0  ftt_verify_vol_label
 
(
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d, 
\f11\b \b0\f10 int 
\f11\b \b0 type, 
\f11\b \b0\f10 char *
\f11\b \b0 vollabel, 
\f11\b \b0\f10 int
\f11\b \b0  timeout, 
\f11\b \b0\f10 int 
\f11\b \b0 rdonly)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 rewinds the tape, uses 
\f10 \f11\b ftt_status
\b0\f10  to check if the tape is write protected, reads the first block, 
uses 
\f10 \f11\b ftt_guess_label
\b0\f10  to check that the label is the indicated type and volume label specified in 
\f10 vollabel
\f10 .
\f10 timeout
\f10  is the timeout for the status check for write protect status, in seconds. 
\f10 type
\f10  can 
be any of the types specified in 
\f10 \f11\b ftt_guess_label
\b0\f10 . 
\f10 rdonly
\f10  is a boolean flag to indicate if the device 
should be opened readonly.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The tape is left positioned after the volume label.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int status;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_descriptor d;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 status = ftt_verify_vol_label(d, FTT_ANSI_HEADER,\'d3mydog\'d3,0,TRUE);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {10.3    } 
\f11\b \b0\f10 int 
\f11\b \b0 ftt_guess_label
 
(
\f11\b \b0\f10 char *
\f11\b \b0 buf, 
\f11\b \b0\f10 int 
\f11\b \b0 length, 
\f11\b \b0\f10 char **
\f11\b \b0 vol,
\f11\b \b0\f10  int **
\f11\b \b0 vlen)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280  examines a buffer in 
\f10 buf
 
\f10 (ostensibly returned by ftt_read) with a length of 
\f10 length
\f10 , and attempts 
to guess what sort of tape format this is, assuming this is the first block of the tape. It returns a 
value of the following type:
\par
\trowd\trrh0\trql\clbrdrb\brdrhair\clmgf\trgaph120\cellx3167 
\pard\plain\s41\f11\fs24\b\ulnone\cf1 \qc\li360\sb480\sa240\keepn\sl-280 \intbl {TABLE  5.    }ftt_guess_label label types
\cell
\clbrdrb\brdrhair\clmrg\trgaph120\cellx7487 
\cell \row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Value
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s43\f11\fs24\b\ulnone\cf1 \sl-280 \intbl Description
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_ANSI_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl An ANSI X3.27 standard tape
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_FMB
_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl An FMB tape
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_TAR
_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl A tar tape (POSIX nnn)
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_CPIO
_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl A Cpio -c format tape
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_
UNKNOWN
_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl No known label type
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_BLANK
_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Verifies length is -1 and last error was 
FTT_BLANK
\cell
\row
\trowd\trrh0\trql\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx3167 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl FTT_DONTCHECK
_HEADER
\cell
\clbrdrl\brdrhair\clbrdrr\brdrhair\clbrdrb\brdrhair\clbrdrt\brdrhair\trgaph120\cellx7487 
\pard\plain\s42\f10\fs22\ulnone\cf1 \sa80\sl-259 \intbl Only used by ftt_verify_vol_label()
\cell
\row
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 \par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The 
\f10 vol
\f10  and 
\f10 vlen
\f10  arguments are taken to be the address of a character pointer and of an integer, 
and will be filled in with the address and length of the volume name in the tape header, if any.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_guess_label
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 In most cases, the user could use 
\f10 ftt_verify_vol_label
\f10  directly, which internally makes a 
\f10 ftt_guess_label call
\f10 .
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int type;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *databuf;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int buflen;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *vollabel;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int vollen;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 type = ftt_guess_label(databuf, buflen, vollabel, vollen);
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {10.4    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_format_label
 
(
\f11\b \b0\f10 char *
\f11\b \b0 buf, 
\f11\b \b0\f10 int 
\f11\b \b0 length, 
\f11\b \b0\f10 char *
\f11\b \b0 vol, 
\f11\b \b0\f10 int 
\f11\b \b0 vlen, 
\f11\b \b0\f10 int 
\f11\b \b0 type)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 This function will format a label pointed to by 
\f10 vol
\f10  and of length, 
\f10 vlen
\f10 , into a buffer, 
\f10 buf
\f10 , of 
length, 
\f10 length
\f10 , which will return the same volume label and type in later calls to 
\f10 \f11\b ftt_guess_label
\b0\f10 . Users can then write this label at the beginning of tape with 
\f10 \f11\b ftt_write
\b0\f10 . In most 
cases, the user would call 
\f10 ftt_write_label
\f10  directly. 
\f10 type
\f10  can be any of the types specified in 
\f10 \f11\b ftt_guess_label 
\b0\f10 (except FTT_DONTCHECK_HEADER)It returns the length of the filled in 
volume header block.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_format_label
\b0\f10  performs no tape operations.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int length;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *databuf;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 int buflen;
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 length = ftt_format_label(databuf, buflen, \'d2mydog\'d3, 
strlen(\'d3mydog\'d3), FTT_ANSI_HEADER);
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {11\tab }Issuing Commands Asynchronously
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 By default, all 
\f10 ftt
\f10  commands are issued synchronously. There are several commands, however, that 
a user may wish to issue asynchronously, e.g. f
\f10 tt_rewind()
\f10 . With the exception of 
\f10 ftt_open()
\f10  and 
\f10 ftt_close()
\f10  themselves, all 
\f10 ftt
\f10  commands can optionally be asynchronous. 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 When a user decides to issue a command asynchronously, he should issue an 
\f10 ftt_fork()
\f10  command. 
The child then does the desired commands and returns the status vi 
\f10 ftt_report()
\f10 . The parent pro
cess can continue doing whatever it wants and then rendezvous with the child via 
\f10 ftt_wait()
\f10 . It can 
also periodically check if the child process has completed via 
\f10 ftt_check()
\f10 ;
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 It is important to note that only one asynchronous operation at a time may be active on a given file 
descriptor.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {11.1    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_fork (
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Creates an asynchronous process for performing ftt calls, which should report status via 
\f10 \f11\b ftt_report()
\b0\f10  which will in turn be collected via 
\f10 \f11\b ftt_wait()
\b0\f10 . Returns a process ID in the parent 
process, a 0 in the child process, and -1 in the case of failure. The call is generally used as 
follows:
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Example:
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #include \'d2ftt.h\'d3
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 char *switch(ftt_fork(d))\{
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 case 0: /* child */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_skip_fm(d,2);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_rewind(d);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_report(d);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 default: /* parent */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab do_stuff_during_rewind();
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_wait(d);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab break
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 case -1: /* error */
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab pc = ftt_get_error(&err);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab fprintf(stderr,pc);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab exit(0);
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \}
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {11.2    }\f11\b \b0\f10 void
\f11\b \b0  ftt_report (
\f11\b \b0\f10 ftt_descriptor 
\f11\b \b0 d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Collects up the status from the last 
\f10 \f11\b ftt
\b0\f10  call, reports it to the parent process, so that it will be col
lected by 
\f10 \f11\b ftt_wait()
\b0\f10 , and exits.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {11.3    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_wait (
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 Waits for a pending asynchronous operation to report its status with 
\f10 \f11\b ftt_report()
\b0\f10 , and sets the 
error string and error code for ftt_get_error to the result of the completed operation.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_wait
\b0\f10  performs no tape operations of its own.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {11.4    }\f11\b \b0\f10 int 
\f11\b \b0 ftt_check (
\f11\b \b0\f10 ftt_descriptor
\f11\b \b0  d)
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 The ftt_check routine succeeds if the asynchronous operation occurring on the device has com
pleted, otherwise it returns a busy device error.
\par
\pard\plain\s12\f10\fs24\ulnone\cf1 \qj\li360\sb120\sa120\sl280 \f10 \f11\b ftt_check
\b0\f10  performs no tape operations.
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {12\tab }f
tt test
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 An binary is provided with ftt to verify that the test routines themselves work as intended as well 
as that an individual drive is behaving normally. ftt_test is a command line parser. It is very unso
phisticated in that it doesn\'d5t support any flow control whatsoever: it simply executes one line at 
time. It can be run interactively, through a shell script, or by redirecting stdin.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 ftt_test can only have one drive open at a time. The drive name is specified in one of the following 
fashions, in descending order of priority:
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }on the ftt_open call itself (e.g., ftt_open /dev/rmt/tps2d4)
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }on the invocation line (e.g., ftt_test -f /dev/rmt/tps2d4)
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }from the environment variable FTT_TAPE (e.g. setenv FTT_TAPE /dev/rmt/tps2d4).
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {12.1    }ftt_test Command
s
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 For testing purposes, it is desirable to issue commands that will generate a certain expected error. 
To avoid a lot of unnecessary clutter, this expected error messages to stderr can be suppressed. Each 
command can take a \'d2-status [FTT_ERROR]\'d3 option which indicates the expected error for that 
command. An error message will be written to stderr only if this error code is not returned. The list 
of valid values for FTT_ERROR are all of the error returns listed earlier in this document (e.g., 
FTT_EIO, FTT_ENOENT, FTT_ENOTAPE).
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 All commands optionally take a \'d2-usage\'d3 switch as well. This is to aid the interactive user in de
termining what are the valid options and parameters for a given command. If the \'d2-usage\'d3 switch 
is used, the actual 
command w
ill NOT be executed, but a usage 
message w
ill simply be printed to 
stderr.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.1    }Open/close Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.1.1    }ftt_open [basename] [-readonly] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt_open library routine using 
\f10 \f6\i basename 
\i0\f10 as the input filename. 
\f10 \f6\i -readonly
\i0\f10  
will open the file for read only access. Without this flag, the device is opened for read/write access. 
The ftt file descriptor is stored in a global variable for all other accesses on this device by the test 
routines.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.1.2    }ftt_open_logical [basename] [-flavor <flavor>] <-driveid <driveid>> [
-r
eadonly] [-
statu
s <
error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt_open library routine using 
\f10 \f6\i basename
\i0\f10  as the input filename. 
\f10 \f6\i flavor
\i0\f10  indi
cates the operating system flavor to use. If not supplied, the test routine will use the current 
operating system flavor. 
\f10 \f6\i driveid
\i0\f10  specifies the drive type. 
\f10 \f6\i -readonly
\i0\f10  will open the file for read only 
access. Without this flag, the device is opened for read/write access. The ftt file descriptor is stored 
in a global variable for all other accesses on this device by the test routines.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.1.3    }ftt_open_dev [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.1.4    }ftt_close [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.1.5    }ftt_close_dev [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.2    }Read/write Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.1    }ftt_write_tblock [-nblocks <n>] [-bsize <nbytes>] [-delta <ndbytes>] [-alignmask 
<nalign>] [-delay <nsec>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 write 
\f10 \f6\i n
\i0\f10  (default = 1) test blocks of size 
\f10 \f6\i nbytes
\i0\f10  (default = 32768). If 
\f10 \f6\i ndbytes 
\i0\f10 is specified, the writes 
will be of random size between 
\f10 \f6\i nbytes
\i0\f10  and 
\f10 \f6\i nbytes + ndbytes
\i0\f10 . If 
\f10 \f6\i alignment
\i0\f10  is specified, random size 
records must will be adjusted to this byte alignment. Valid values for 
\f10 \f6\i nalign 
\i0\f10 are 0 (allows odd byte 
writes), 1 (allows odd word writes), and 3 (allows only longword multiples). If 
\f10 \f6\i delay
\i0\f10  is specified, 
a random delay of 0 to 
\f10 \f6\i nsec
\i0\f10  will occur between writes. The first lon
gw
ord in the test block is the 
number of bytes in the block, the second is the block number, the third is the filename. All remain
ing bytes are filled with ascending bytes starting with (file number + block number) % 256.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.2    }ftt_verify_tblock [-nblocks <n>] [-delay <nsec>] [-oddbyte] [-filemark] [-status 
<error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 read and verify 
\f10 \f6\i n
\i0\f10  (default = 1) test blocks If delay is specified, a random delay of 0 to 
\f10 \f6\i nsec
\i0\f10  will 
occur between reads. If the 
\f10 \f6\i -oddbyte
\i0\f10  switch is used, an odd number of bytes will be used for the 
input buffer. 
\f10 \f6\i -filemark
\i0\f10  indicates that the record should be a filemark.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.3    }ftt_dump [-nblocks n] [-filename <filename>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 read 
\f10 \f6\i n
\i0\f10  blocks (defaults until end of tape) and then write them to stdout or f
\f10 \f6\i ilename
\i0\f10  if specified.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.4    }ftt_undump [-filename <filename>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 write until end of data from stdin or filename if specified.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.5    }ftt_writefm [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.6    }ftt_verify_vol_label [-timeout <nsecs>] [-type <type>] [-label <labelname>] [-
readonly] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. Infor
mation is 
written t
o stderr. This command will wait 
\f10 \f6\i nsecs
\i0\f10  for the drive to come online. The default 
value is 0. Valid 
\f10 \f6\i types 
\i0\f10 are:
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_ANSI_HEADER
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_FMB_HEADER
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_TAR_HEADER
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_CPIO_HEADER
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_UNKNOWN_HEADER
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_BLANK_HEADER
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }FTT_DONTCHECK_HEADER
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 If not specified, a type of FTT_ANSI_HEADER is assumed.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.2.7    }ftt_write_vol_label [-type <type>] [-label <labelname>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. The 
valid values for 
\f10 \f6\i type
\i0\f10  are the same as in ftt_verify_vol_label.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 If not specified, FTT_ANSI_HEADER is assumed.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.3    }Tape Positioning Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.1    }ftt_status [-timeout <nsecs>] [-status <error>]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor and 
prints the current drive status. The user can specify a timeout of 
\f10 \f6\i nsecs
\i0\f10 . If no timeout is specified, 
the default value is 0.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.2    }ftt_test_status [-<flag1> ... [-<flag>]] [-timeout <nsecs>] [-status <error>]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls ftt_status using the global variable for the ftt file descriptor. Each flag is tested to see if the 
condition is true. Valid values for 
\f10 \f6\i flag
\i0\f10  are: FTT_ABOT, FTT_AEOT, FTT_AEW, FTT_PROT, 
FTT_ONLINE, and FTT_BUSY. The user can specify a timeout of 
\f10 \f6\i nsecs
\i0\f10 . If no timeout is speci
fied, the default value is 0.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.3    }ftt_skip_to_double_fm [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async
\i0\f10  will issue the command 
asynchronously.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.4    }ftt_skip_fm <nfilemarks> [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async 
\i0\f10 will issue the command 
asynchronously.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.5    }ftt_skip_rec <nrecords> [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async
\i0\f10  will issue the command 
asynchronously.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.6    }ftt_rewind [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async
\i0\f10  will issue the command 
asynchronously.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.7    }ftt_retension [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async 
\i0\f10 will issue the command 
asynchronously
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.8    }ftt_erase [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async
\i0\f10  will issue the command 
asynchronously.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.9    }ftt_unload [-async] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor where 
\f10 \f6\i async
\i0\f10  will issue the command 
asynchronously.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.10    }ftt_get_position [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. The 
current file and block number is written to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.3.11    }ftt_verify_position <fileno> <blockno>
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 verifies that the position specified by fileno and blockno match those returned by ftt_get_position.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.4    }Asynchronous Support Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.4.1    }ftt_wait [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.4.2    }ftt_check [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.5    }Get/set Mode Commands and Other Commands That Care About 
Filenames
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.1    }ftt_list_all [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. The 
list of device node pathnames is written to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.2    }ftt_chall <uid> <gid> <mode> [-status error] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. The 
user name is specified in 
\f10 \f6\i uid
\i0\f10 , the group name in 
\f10 \f6\i gid
\i0\f10 , and the mode in 
\f10 \f6\i mode
\i0\f10 .
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.3    }ftt_verify_exist 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 verifies that all of the filenames listed by ftt_list_all really do exist.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.4    }ftt_avail_mode <density> <mode> [-blocksize <b>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. The 
density and mode must be specified in 
\f10 \f6\i density
\i0\f10  and 
\f10 \f6\i mode
\i0\f10  respectively. If the blocksize is not spec
ified, variable block will be assumed. The device node is printed to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.5    }ftt_get_mode [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the ftt_get_mode library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.6    }ftt_set_mode <density> <mode> [-blocksize <b>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the ftt_set_mode library routine using the global variable for the ftt file descriptor. If no block
size is specified, variable block mode is assumed.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.7    }ftt_get_mode_dev [device_name] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. Node 
information is written to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.8    }ftt_set_mode_dev <devname> [-blocksize <b>] [-force] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. If no 
blocksize is specified, variable block mode is assumed. 
\f10 \f6\i -force 
\i0\f10 will turn the force flag on. It is off 
by default.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.9    }ftt_verify_modes 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 verifies all modes of the device. This routines will loop through all modes of the device. It will set 
the mode, write, verify the mode is what we think it should be, rewind, and then verify the data.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.10    }ftt_get_basename [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.5.11    }ftt_describe_dev [device_name] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.6    }Statistic Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.6.1    }ftt_get_stats [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. Infor
mation is written to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.6.2    }ftt_extract_stats <statistic> [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. Infor
mation is written to stderr. Valid values for 
\f10 \f6\i statistic 
\i0\f10 are from the list described earlier in this 
document (e.g., FTT_PRODUCT_ID, FTT_VENDOR_ID, FTT_DENSITY, 
etc.)
.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.6.3    }ftt_init_stats [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.6.4    }ftt_update_stats [-part_display] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. The 
accumulated t
otals are written to stderr. 
\f10 \f6\i -part_display
\i0\f10  will only display the statistics that are 
counters.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.6.5    }ftt_dump_stats [-filename <filename>] [-status <error>] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. It will 
dump the stats to filename is specified, otherwise stderr.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.7    }Error Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.7.1    }ftt_eprintf <string> [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.7.2    }ftt_get_error [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 calls the corresponding ftt library routine using the global variable for the ftt file descriptor. Infor
mation is written to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.7.3    }ftt_max_error [<maxerror>] 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Set/show the current maximum number of errors before ftt_test will abort.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.1.8    }Miscellaneous Commands
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.8.1    }ftt_date [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 output current date to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.8.2    }ftt_echo [string] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 print 
\f10 \f6\i string
\i0\f10  to stderr.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.1.8.3    }ftt_debug [level] [-test] [-usage]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Set/show the current debug level for the ftt library as well as the test routines. The debug level of 
the library will be set to 
\f10 \f6\i level
\i0\f10 . If 
\f10 \f6\i -test
\i0\f10  is specified, it will set the debug level for just the test routines. 
If level is not specified, the current debug level for both the library and the test routines are 
displayed.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Debug levels for the ftt library are:
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }0 = no debug prints
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }1 = print \'d2Entering routine ...\'d3 in each routine
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }2 = miscellaneous areguments \'d2got this far\'d3 prints
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }3 = debug prints on each pass through loops, etc. More debug prints than you can shake a 
stick at.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Debug levels for the test routines are:
\par
\pard\plain\s17\f10\fs24\ulnone\cf1 \qj\fi-360\li720\sb80\sa80\sl280\tx720 {\f2\b \'a5\tab }1 = display commands entered by user
.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {12.2    }f
tt_test Examples
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.2.1    }Interactive Example:
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This example will rewind a tape specified on the open command itself: 
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 $FTT_DIR/bin/ftt_test
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \f0 \f11\b ftt_test>
\b0\f0  ftt_open /dev/rmt/tps2d4
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \f0 \f11\b ftt_test>
\b0\f0  ftt_rewind
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \f0 \f11\b ftt_test>
\b0\f0  ftt_close
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.2.2    }Shell Script Example:
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This is an example ksh script that will rewind a tape. The device name can be specified as the first 
argument to the script, or from the environment 
variable F
TT_TAPE.
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #!/bin/ksh
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #==========================
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 # This will rewind the tape
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 # =========================
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 # Get the tape device by looking in $1. 
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 # If that\'d5s not set, try FTT_TAPE. 
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 # If that\'d5s not set either, then exit.
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 export FTT_TAPE
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 FTT_TAPE=$\{1:-$\{FTT_TAPE:-\'d3\'d3\}\}
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 FTT_TAPE=$\{FTT_TAPE:?\'d3No device specified\'d3\}
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 #========================================== 
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 $FTT_DIR/bin/ftt_test << EOD
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_open
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_rewind
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 ftt_close
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 EOD
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.2.3    }Redirection Example:
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This example will rewind a tape drive based on an ftt_test script. This device is specified as a switch 
to the ftt_test command itself.
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 cat my.ftt
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_open
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_rewind
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 \tab ftt_close
\par
\pard\plain\s67\f0\fs20\ulnone\cf1 \f0 \li1440\sl240\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200 $FTT_DIR/bin/ftt_test -f /dev/rmt/tps2d4 <my.ftt
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {12.3    }ftt_test scripts
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 A series of test scripts are also
 p
rovided to verify the ftt library as well as verify the behavior of a 
particular drive. Since the ftt_test program is very simple in nature (e.g., no flow control support, 
no variable support), the test scripts themselves will be ksh scripts. There are both small building 
block tests that will verify a particular aspect of the library as well as all inclusive tests that verify 
the 
entire p
ackage.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 All tests can either rely on the device name being 
specified i
n the environment variable FTT_TAPE 
or passed in as argument 0 on the command line.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.3.1    }Building block scripts
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.1    }align [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This test will write a bunch of records, rewind, and then verify. It will do this for block sizes that 
are of longword multiples, word multiples, and byte multiples.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.2    }async [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will verify the asynchronous capability in ftt. It assumes that a test tape is inserted that 
has been written with the \'d2write\'d3 test. It will then skip to the double file mark and then
 d
isplay a 
time stamp around an 
asynchronously i
ssued rewind. 
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This output will need to be also checked manually to verify that the change in time is small. It will 
then check ftt_wait. An asynchronous command will also be issued that is expected to fai
l i
n order 
to verify that ftt_wait will return a failure. 
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.3    }close [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This test will verify that a close command will leave the tape in a known position so that when it\'d5s 
opened again, the user knows where he is.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.4    }delay [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will test write a bunch of blocks and reading a bunch of blocks with a random delay 
between i/o operations. This tends to uncover strange behavior with devices and device drivers. It 
is a lengthy test and may take a few hours to run.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.5    }erase [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will write a volume label, erase the tape, and then verify that the volume label is blan
k.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.6    }full [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will write to end of tape to verify appropriate errors reporting. It will take FOREVER 
to run.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.7    }label [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will write all of the various label types and verify them
.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.8    }m
ode [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will test the various ftt_mode routines. It will be a nested loop which for all densities, 
all compressions, and all block sizes (variable and two different fixed block sizes) will check if the 
mode is available. If so, it will rewind the device, set the mode, write some data, verify the mode, 
rewind, and finally verify the data.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.9    }notape [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will unload the tape and then verify that 
the c
orrect error is returned when trying to ac
cess the drive.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.10    }position [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will verify all the positioning commands using the a tape written by write.ftt. It will ver
ify spacing both records and filemarks both forwards and backwards. It will verify that the correct 
error code is returned if the operation can\'d5t be performed. It will check that ftt_status returns the 
correct positioning information and that ftt_skip_to_double_fm works.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.11    }read_only [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This test
 v
erifies that all ftt_write functions will return an error if the drive is opened as read only. 
It should also verify that ftt_status determines that it\'d5s a read only drive.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.12    }root [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script
 n
eeds to run as root to work successfully. It does all of the operations that require root 
privileges. Currently this is on ftt_chall.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.13    }stats [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script will verify the statistics information. The output of the script will need to be checked 
manually. It will do a few writes and display the delta stats and then do a few reads and display the 
delta stats.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.14    }verify [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script verifies a tape written with write.ftt. It verifies that the volume label, the number of 
blocks, the contents of the blocks themselves, the number of file marks, and th
at t
he tape is blank 
at the end.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.15    }write [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script writes a test tape beginning with an 
ANSI l
abel. It will write a few files with a few thou
sand blocks. The tape written by the script can be used by other scripts for additional testing. This 
test shoul
d l
eave the tape with only two filemarks at the end.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.1.16    }random [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This is a special script that is actually generated by a c program. The c program will generate this 
ftt script to write a random number of files of random block size. It then randomly picks a position, 
skips to it, and verifies a random number of blocks.
\par
\pard\plain\s29\f11\fs28\b\ulnone\cf1 \sb280\sa140\keepn\sl-320 {12.3.2    }All inclusive tests
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 A few test scripts are provided as a convenience that call the fundamental building scripts men
tioned in the previous section. There are
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.2.1    }ftt_fast [-a] [-u] [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This script tests all of the reasonable quick tests to verify that the ftt library is behaving the way 
that it should. It may take on the order of an hour or two to complete. If -a is specified, the alignment 
tests are performed as well. Note that this may cause SCSI resets. If the -u switch is 
specified,
 the 
unload tests are performed at the end. Note that the tape will have to be reloaded before any other 
tests can be run.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.2.2    }ftt_slow [-a] [-u] [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This tests is all inclusive test suite for the ftt routines. It will call ftt_fast to perform all of the rea
sonable quick tests. In addition, it will test of the slow routines (e.g., erase, write to end of tape). It 
may take several hours to run.
\par
\pard\plain\s31\f11\fs24\b\ulnone\cf1 \sb240\sa120\keepn\sl-280 {12.3.2.3    }ftt_exercise [device]
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 This test is provided as a convenience for the user who wants to exercise the device to make sure 
that it is ok. For example, if a drive is replaced, the user would want to verify it with this script.
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {13\tab }ftt_suid
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {13.1    }Command invocation
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The 
\f10 \f11\b ftt_suid
\b0\f10  program which comes with the 
\f10 \f11\b ftt
\b0\f10  distribution is a program which runs to allow var
ious functions which must be run as root on various platforms to occur. It us generally invoked by 
the library, but can be invoked from the command line with the following options:
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-3600\li3600\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b ftt_suid
\b0\f10 \f8\b\i  
\b0\i0\f10 \f6\i opts 
\i0\f10 \f11\b -c
\b0\f10  
\f10 \f6\i basename 
\i0\f10 -- clear error statistics on the drive
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b ftt_suid
\b0\f10 \f6\i  opts 
\i0\f10 \f11\b -s
\b0\f10 \f6\i  basename
\i0\f10  --print statistics for the drive
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b ftt_suid 
\b0\f10 \f6\i opts
\i0\f10 \f11\b  -b 
\b0\f10 \f6\i n basename
\i0\f10  -- set blocksize to 
\f10 \f11\b n 
\b0\f10 for the drive
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b ftt_suid 
\b0\f10 \f6\i opts 
\i0\f10 \f11\b -C
\b0\f10  
\f10 \f6\i n basename
\i0\f10  -- set compression on (
\f10 \f11\b n 
\b0\f10 == 1) or off (
\f10 \f11\b n 
\b0\f10 == 0)
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b ftt_suid 
\b0\f10 \f6\i opts
\i0\f10  
\f10 \f11\b -d
\b0\f10  
\f10 \f6\i n basename
\i0\f10  -- set density to 
\f10 \f11\b n
\b0\f10 .
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Only one of the above forms may be used per command invocation.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 In each of the above 
\f10 \f6\i opts
\i0\f10  may be 
\f10 \f11\b -w
\b0\f10  to open the drive for writing, (which really only makes a dif
ference for getting statistics on 8200\'d5s) and/or 
\f10 \f11\b -x
\b0\f10  which turns on 
\f10 \f11\b ftt 
\b0\f10 debugging. The command 
performs the minimum number of 
\f10 \f11\b ftt
\b0\f10  calls to perform the task, as well as 
\f10 \f11\b ftt_open
\b0\f10 , and 
\f10 \f11\b ftt_close
\b0\f10 . 
These are all operations which require superuser priveledge on one or more systems. Currently the 
only platform where 
\f10 \f11\b ftt_suid
\b0\f10  does not need to be setuid root at all is on IRIX systems from Silicon 
Graphics.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 In all cases, after performing the requested operation, the values returned by 
\f10 \f11\b ftt_get_error()
\b0\f10  are 
printed to file descriptor 0.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 Note that for the 
\f10 \f11\b ftt
\b0\f10  suite to work properly on those systems which require 
\f10 \f11\b ftt_suid
\b0\f10  to be setuid to 
root, the 
\f10 \f11\b ftt_suid
\b0\f10  executable must be in your command search path when the library is run, and 
installed with the correct permissions.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {13.2    }Example of use
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 To get the current statistics from drive 
\f10 \f11\b /dev/rmt0
\b0\f10  the command:
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 ftt_suid -s /dev/rmt0
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 would yeild the output
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 FTT_VENDOR_ID is EXABYTE
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 FTT_PRODUCT_ID is EXB-8200
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 FTT_FIRMWARE is 2600
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 FTT_CLEANING_BIT is 0
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \f2\b \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 ...
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 FTT_SENSE_KEY is 0
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 FTT_TRANS_SENSE_KEY is NO_SENSE
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 - is -
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 0
\par
\pard\plain\s20\f0\fs20\ulnone\cf1 \li360\sl240\tx839\tx1320\tx1800\tx2279\tx2760\tx3240\tx3719\tx4200\tx4680\tx5159\tx5640\tx6120\tx6599\tx7080\tx7560\tx8039\tx8520\tx9000 Ok
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 showing the statistics, then the error code and error string. In this case, the error counters on the 
Exabyte 8200 would be interpreted as read errors, since 
\f10 \f11\b -w
\b0\f10  was not specified.
\par

\page
\pard\plain\s27\f11\fs36\b\ulnone\cf1 \fi-720\li720\sb360\sa180\keepn\sl-419\tx720 {14\tab }System Configuration Issues
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 \f10 \f11\b ftt
\b0\f10  makes very few assumptions about system configuration, however they are listed below, by plat
form. ftt attempts to continue and operate as best it can even when these options are not met, 
however it may be unable to determine tape drive type, etc. if these conditions are not met.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {14.1    }AIX issues
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The major assumption for 
\f10 \f11\b AIX
\b0\f10  systems is that the 
\f10 \f11\b ftt_suid
\b0\f10  executable is properly installed. If this 
is not done, we will be unable to set density and compresssion, or get statistics.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {14.2    }IRIX issues
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 The major assumption under 
\f10 \f11\b IRIX
\b0\f10  is that the devices under 
\f10 \f11\b /dev/scsi 
\b0\f10 exist, those entries under 
\f10 \f11\b /
dev/scsi 
\b0\f10 which correspond to tapedrives are writable by tape drive users, and that the
\f10 \f6\i  ds
\i0\f10  module is 
built into the kernel to allow SCSI pass-through.
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 On 
\f10 \f11\b IRIX
\b0\f10  we cannot currently distinguish between Exabyte 8500\'d5s and 8505\'d5s, or between 
DLT4000\'d5s and DLT2000\'d5s, since the 
\f10 \f11\b hinv
\b0\f10  command lists them identically.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {14.3    }OSF1 / DEC UNIX issues
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 There are a couple of assumptions hidden in the 
\f10 \f11\b DEC UNIX (OSF1)
\b0\f10  port, because the 
\f10 \f11\b uerf
\b0\f10  com
mand is used to determine what tape drives are on the system from the boot messages
\f10 \super 1
\f10 . 
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b /usr/adm/binary.errlog
\b0\f10  is readable
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }\b0\f10 \f11\b uerf -r 300 -R
\b0\f10  will list the tape devices on the system as part of the boot messages, and in that 
message the device type and firmware level appear on the line 
\f10 \f6\i after
\i0\f10  the 
\f10 \f11\b tz
\b0\f10 \f8\b\i n
\b0\i0\f10  line, followed by a 
close parenthesis. This is true in versions 3.2C and later.
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }Tape devices 
\b0\f10 \f11\b /dev/rmt
\b0\f10 \f8\b\i n
\b0\i0\f10  are created in the order listed by the boot messages as output by the 
\f10 \f11\b uerf
\b0\f10  command, above. This is the order the system usually creates them in, but if device nodes 
have been added by hand, etc. this may cause problems.
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }The 
\b0\f10 \f11\b ftt_suid
\b0\f10  executable is installed setuid root. Even though it would work to tell 
\f10 \f11\b ftt
\b0\f10  that it 
did 
\f10 \f6\i not
\i0\f10  need to be setuid root to operate on 
\f10 \f11\b /dev/cam
\b0\f10 , and to make 
\f10 \f11\b /dev/cam
\b0\f10  world writable, 
this would raise nasty security issues, since this would also allow users direct pass-through 
access to all SCSI devices on the system.
\par
\pard\plain\s28\f11\fs32\b\ulnone\cf1 \sb320\sa160\keepn\sl-380 {14.4    }Solaris Issues
\par
\pard\plain\s7\f10\fs24\ulnone\cf1 \qj\sb120\sa120\sl280 There are a couple of assumptions hidden in the 
\f10 \f11\b Solaris
\b0\f10  port, underlying the fact that we use 
\f10 \f11\b dmesg
\b0\f10  
to discover what tape drives are on the system.
\f10 \super 1
\f10 \par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }The 
\b0\f10 \f11\b st
\b0\f10  driver is configured to force-load, so that tape drives are listed at boot.
\par
\pard\plain\s16\f10\fs24\ulnone\cf1 \qj\fi-360\li360\sb80\sa80\sl280\tx360 {\f2\b \'a5\tab }Tape devices 
\b0\f10 \f11\b /dev/rmt
\b0\f10 \f8\b\i n
\b0\i0\f10  in order correspond to the sequence tape devices are listed by 
\f10 \f11\b dmesg.
\par
\pard\plain\s246\f10\fs20\ulnone\cf1 \qj\fi-360\li720\sb200\sa80\sl240\tx720 {1.\tab }It is hoped that in the future a better solution to this problem will be found
\par
}
