<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
  <head>
    <meta http-equiv="Content-Type" content=
    "text/html; charset=iso-8859-1">
    <meta name="GENERATOR" content=
    "Mozilla/4.08 [en] (X11; I; Linux 2.0.35 i686) [Netscape]">
    <title>
      Fermi Tape Tools (ftt) Library User's Guide
    </title>
  </head>
  <body>
    <center>
      <h1>
        Fermi Tape Tools (ftt) Library User's Guide
      </h1>
    </center>
    <center>
      Chuck Debaun, <b>Marc W. Mengel</b><br>
      Operating Systems Support Department 
      <p>
        Marilyn Schweitzer<br>
        High Performance and Parallel Computing Department
      </p>
      <p>
        <b>Dorota Genser</b>, Gene Oleynik, <b>Margaret
        Votava</b><br>
        Online Systems Department<br>
        Fermilab Computing Division
      </p>
    </center>
    <center>
      <h2>
        Abstract
      </h2>
    </center>
    <blockquote>
      <blockquote>
        The Fermi Tape Tools library is a C subroutine package that
        provides consistent, platform-independant tapeI/O for a
        variety of tape drives&nbsp; on a variety of platforms
        .&nbsp; It provides basic tape input and output, support
        for obtaining and tracking available tape statistics, and
        various informationnal and support routines for tools which
        need to allocate and control tape usage. 
        <p>
          This users guide will provide an overview of teh ftt
          library calls, take the reader through the process of
          writing a simple ftt based tape copy program, and also
          provide a complete call reference of the routines
          provided for tape input, output, and information
        </p>
      </blockquote>
    </blockquote>
    <!--NewPage-->
    <!--NewPage-->
    <h2>
      Getting Started
    </h2>
    <h3>
      Installation
    </h3>
    The <b>ftt</b> product is distributed as a Fermilab <b>ups</b>
    product, and should be installed as such, as root if possible.
    There is an <b>INSTALL</b> file in the product giving details
    of non-<b>ups</b> installation. Important notes on
    prerequisites for various platforms are in Chapter 14 of this
    document. 
    <h3>
      Basic Concepts
    </h3>
    The <b>ftt</b> library is used by creating a <b>descriptor</b>
    for each tape drive being used and making various <b>ftt</b>
    calls using that descriptor. The <b>descriptor</b> itself
    contains information about what system <b>devices</b> are
    associated with the tape drive, what densities and formats are
    available, etc. To get a <b>descriptor</b> for a particular
    tape drive, you need to know the <b>basename</b> of the drive,
    which is basically a common substring of the various system
    devices associated with the tape drive. Another important data
    structure is the <b>ftt_stat_buf</b> which is used to hold tape
    drive statistics obtained from the tape drive. These types, as
    well as all of the function prototypes, preprocessor
    definitions, etc. are found in the <b>ftt.h</b> header file. 
    <h3>
      Starting and Finishing
    </h3>
    The <b>ftt</b> library can be used either to do tape input and
    output, to manage tape drives, to get information about tape
    devices, or all of the above. All of these activities start
    with a call to <b>ftt_open</b> to get an <b>ftt</b> descriptor.
    
<pre>
#include &lt;ftt.h&gt;
ftt_descriptor d;
d = ftt_open("/dev/rmt0", FTT_RDONLY);
/* do some stuff here */
ftt_close(d);
</pre>
    There are several itemuser_guide_maintext1.mifs that should be
    mentioned here.: 
    <ul>
      <li>
        The header file ftt.h is included. This file contains the
        various preprocessor symbols and function declarations for
        users of the <b>ftt</b> library.
      </li>
      <li>
        We declare the descriptor variable with a type named <b>
        ftt_descriptor</b>.
      </li>
      <li>
        We pass in a read-only/read-write flag to the open call.
      </li>
      <li>
        ftt_close frees up all the memory associated with the <b>
        descriptor</b> and closes any open system devices
        associated with the drive.
      </li>
    </ul>
    <p>
      <br>
      If your program needs to deal with multiple tape drives, it
      can call <b>ftt_open</b> multiple times, to get a unique <b>
      descriptor</b> for each drive. It should then issue an <b>
      ftt_close</b> on each descriptor it got from <b>ftt_open</b>
      before exiting
    </p>
    <h3>
      Doing Input and Output
    </h3>
    Once you have a <b>descriptor</b>, very often you want to read
    data from the associated drive, or write data to it. The <b>
    ftt</b> library calls to read and write data look very much
    like the UNIX system calls <b>read</b> and <b>write</b> and are
    called (you guessed it) <b>ftt_read</b> and <b>ftt_write</b>.
    Both take as arguments the <b>descriptor</b> for the tape drive
    involved, a character pointer to the data buffer, and the
    number of bytes requested to be read or written. Both return
    the number of bytes actually transferred, or -1 to indicate an
    error. The calls look like: 
<pre>
length = ftt_read(d, buffer, buffer_length);
</pre>
    or; 
<pre>
length = ftt_write(d, buffer, data_length);
</pre>
    <!--NewPage-->
    <h2>
      Finding out what went wrong
    </h2>
    If your <b>ftt</b> calls return an error (a value of -1 for <b>
    ftt_read</b> or <b>ftt_write</b> or a value of 0 from <b>
    ftt_open</b> for example), you may want to know specifically
    what went wrong. To find out the specific error condition, you
    can use the routine called <b>ftt_get_error</b> which gives you
    an error string and (optionally) an error number. If you simply
    want to tell the user what went wrong, you can do something as
    simple as: 
<pre>
fprintf(stderr, "%s\n", ftt_get_error(0));
</pre>
    which will print the error string on standard error. If your
    program wants to attempt to do something to recover from
    errors, you will need to pass a pointer to an integer into the
    first argument of <b>ftt_get_error</b> which will give you back
    an error number. Then you can attempt to take appropriate
    action based on the error. This looks like: 
<pre>
char *p;
int n;
...
p = ftt_get_error(&amp;n);
if (n == FTT_ENOTAPE) {
&nbsp;&nbsp;&nbsp; request_tape_mount();
}
</pre>
    The error numbers you get from <b>ftt_get_error</b> will be one
    of the following: 
    <center>
      TABLE 1. ftt error codes
    </center>
    <table border>
      <tr align="LEFT">
        <td align="LEFT">
          ftt_errno
        </td>
        <td align="LEFT">
          Description
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_SUCCESS
        </td>
        <td align="LEFT">
          no error has occurred
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EPARTIALSTAT
        </td>
        <td align="LEFT">
          unable to obtain some or all of the information requested
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EUNRECOVERED
        </td>
        <td align="LEFT">
          previous error was unrecoverable, tape can only be
          unloaded/rewound (to protect data)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOTAPE
        </td>
        <td align="LEFT">
          there is no tape in the drive
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOTSUPPORTED
        </td>
        <td align="LEFT">
          Unsupported device
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EPERM
        </td>
        <td align="LEFT">
          you do not have permission to perform the specified
          operation on the device.
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EFAULT
        </td>
        <td align="LEFT">
          you gave a buffer address range whose access yields a
          memory fault
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOSPC
        </td>
        <td align="LEFT">
          A write attempted to cross end of media
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOENT
        </td>
        <td align="LEFT">
          User attempted to set density to a nonexistent one
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EIO
        </td>
        <td align="LEFT">
          Physical read or write error.0
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EBLKSIZE
        </td>
        <td align="LEFT">
          Attempt to write/read unsupported block size s
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOEXEC
        </td>
        <td align="LEFT">
          Attempt to run setuid executable for security bypass
          failed -- not executable
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EBLANK
        </td>
        <td align="LEFT">
          Encountered blank tape (i.e. passed logical EOT)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EBUSY
        </td>
        <td align="LEFT">
          Asynchronous I/O is going on this device, or another
          process has it open
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENODEV
        </td>
        <td align="LEFT">
          System does not have drive configured
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENXIO
        </td>
        <td align="LEFT">
          Tried to contact a nonexistent process
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENFILE
        </td>
        <td align="LEFT">
          No system file descriptors available
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EROFS
        </td>
        <td align="LEFT">
          Tape is write protected
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EPIPE
        </td>
        <td align="LEFT">
          Setuid bypass died
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ERANGE
        </td>
        <td align="LEFT">
          Record too large for buffer
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOMEM
        </td>
        <td align="LEFT">
          Unable to allocate memory required to perform call
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOTTAPE
        </td>
        <td align="LEFT">
          What we thought was a tape device was not.
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_2SMALL
        </td>
        <td align="LEFT">
          The block size issued is smaller then the device can
          handle
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ERWFS
        </td>
        <td align="LEFT">
          Tape is not write protected (and should be)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EWRONGVOL
        </td>
        <td align="LEFT">
          Wrong volume label on tape for verification
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EWRONGVOLTYP
        </td>
        <td align="LEFT">
          Wrong type of label on tape for verification
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ELEADER
        </td>
        <td align="LEFT">
          hit tape leader while skipping backwards
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EFILEMARK
        </td>
        <td align="LEFT">
          hit file mark while skipping records
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ELOST
        </td>
        <td align="LEFT">
          The tape postion is unknown
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ENOTBOT
        </td>
        <td align="LEFT">
          The tape is not at BOT
        </td>
      </tr>
    </table>
    <p>
      Your code can compare the error number (<b>n</b> in our
      example) to the values in this table to decide what went
      wrong in the preceding <b>ftt</b> library call.<br>
      <!--NewPage-->
    </p>
    <h2>
      Opening/closing Device
    </h2>
    In general, to access a device, the user need simply call <b>
    ftt_open()</b>. He can then perform normal tape operations
    (e.g., read, write, rewind). <b>ftt_open()</b> doesn't actually
    open this device with the unix device driver. It simply
    creates/initializes the <b>ftt</b> file descriptor. Once the
    descriptor is created, the user can explicitly open a thread to
    the device driver with <b>ftt_open_dev()</b>, although this is
    not necessary. All <b>ftt</b> routines will internally call <b>
    ftt_open_dev()</b> if the device has not yet been opened. 
    <p>
      A utility routine, <b>ftt_open_logical()</b>, is provided to
      create an <b>ftt</b> descriptor for a possibly fictitious
      device. It provides the opportunity to see what the various
      device names would be for specific modes/densities on a
      different operating system platform. The average user would
      not use this routine to open the device, but would use <b>
      ftt_open()</b> instead.
    </p>
    <p>
      The pair of close routines, <b>ftt_close()</b> and
      f<b>tt_close_dev()</b>, are similar in function to the pair
      of open routines, f<b>tt_open()</b> and <b>
      ftt_open_dev()</b>. In general, the user need simply call <b>
      ftt_close()</b> when finished with the device. This routine
      will internally call <b>ftt_close_dev()</b> if needed. <b>
      ftt_close_dev()</b> will ensure that the proper number of
      filemarks have been written at the end of tape (if writing)
      and that the tape is correctly positioned. <b>ftt_close()</b>
      will free the <b>ftt</b> file descriptor.
    </p>
    <p>
      It's important to note that some <b>ftt</b> routines will
      internally call <b>ftt_close_dev()</b>, which may write
      filemarks, if they need to close the normal unix device
      driver and open the raw scsi device. The documentation for
      the individual subroutines will indicate if a specific
      routine exhibits this behavior.
    </p>
    <p>
      Note that several f<b>tt_open_dev()</b> and
      f<b>tt_close_dev()</b> pairs can be called within a single
      <b>ftt_open()</b> and <b>ftt_close()</b> pair.
    </p>
    <h3>
      ftt_descriptor <b>ftt_open</b>(char <b>*basename, int</b>
      rdonly)
    </h3>
    opens a <i>basename</i> for a device and returns a <i>
    descriptor,</i> which can be used to perform other operations
    on the device. The <i>basename</i> argument can also be a full
    device name for a tape device, and will internally be trimmed
    to a basename. 
    <p>
      The <i>rdonly</i> argument indicates<br>
      &nbsp;
    </p>
    <p>
      <br>
    </p>
    <center>
      <p>
        TABLE 2. rdonly flag values
      </p>
    </center>
    <table border>
      <tr align="LEFT">
        <td align="LEFT">
          Value
        </td>
        <td align="LEFT">
          Description
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_RDONLY
        </td>
        <td align="LEFT">
          Device will not be written on
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_RDWR
        </td>
        <td align="LEFT">
          Device is read and writable.
        </td>
      </tr>
    </table>
    <p>
      Note that FTT_RDONLY does not check that the device is
      physically write protected, nor does FTT_RDWR check that is
      not physically write protected; a call to <b>ftt_status</b>
      is required to obtain that information.
    </p>
    <p>
      This routine performs no positioning of the device.
    </p>
    <p>
      Note that <b>ftt_open</b> and <b>ftt_close</b> do not need to
      be called to switch between reading and writing, to cross
      filemarks, etc. The ftt software will perform operating
      system opens and closes as needed to allow those transitions.
    </p>
    <p>
      ftt_open does not perform any operations on the tape drive or
      tape devices, it simply does bookkeeping to prepare for such
      operations.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
d = ftt_open("/dev/rmt/tps2d4", FTT_RDWR);
</pre>
    <h3>
      ftt_descriptor <b>ftt_open_logical</b> (char
      *<b>basename,</b> char *<b>os,</b> char *<b>driveid,</b> int
      <b>rdonly)</b>
    </h3>
    Create a (possibly mythical) ftt_descriptor for a device of
    type <i>driveid</i> on operating system <i>os</i>, using base
    device name <i>basename</i>, with <i>rdonly</i> as in <b>
    ftt_open</b>. This call will be used internally to construct a
    descriptor, but can also be used in combination with other <b>
    ftt</b> calls to see what the name of the high density EXB-8500
    tape device would be on IRIX from an IBM system. Performing any
    actual tape-io from this descriptor will probably fail unless
    the <i>os</i> and <i>driveid</i> and <i>basename</i> are valid
    for the current system. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
d = ftt_open_logical("/dev/rmt/tps2d4", "IRIX", "EXB-8500", FTT_RDWR);
</pre>
    <h3>
      int <b>ftt_open_dev (</b>ftt_descriptor <b>d)</b>
    </h3>
    Explicitly perform a UNIX open of the device for the currently
    selected density, etc. Routines which need the device open to
    work will call <b>ftt_open_dev</b> if they need to. 
    <p>
      If the density and mode have not been set by <b>
      ftt_set_mode(), ftt_set_mode_dev(),</b> etc., the default
      density and compression mode of the highest density the
      device supports and no compression will be used.
    </p>
    <p>
      The routine may sets appropriate modes and/or flags on the
      underlying device to allow other ftt operations to proceed
      properly.
    </p>
    <p>
      ftt_open_dev performs antecessor operations to set the device
      density, etc. and actually performs an operating system open
      on the device. No tape motion is performed.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_open_dev(d);
</pre>
    <h3>
      int <b>ftt_close (</b>ftt_descriptor <b>d)</b>
    </h3>
    The <b>ftt_close</b> entry releases a descriptor, indicating
    that no further operations will be performed on that
    descriptor. If a device has been opened not closed, an <b>
    ftt_close_dev</b> will be performed. 
    <p>
      ftt_close will invoke <b>ftt_close_dev</b> if needed, but
      performs no other tape or device operations.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_close(d);
</pre>
    <h3>
      int <b>ftt_close_dev(</b>ftt_descriptor <b>d)</b>
    </h3>
    This call closes the system device which was opened by <b>
    ftt_open_dev</b>, after ensuring proper double file mark
    termination of written data. To ensure this, if writes have
    been successfully performed since the last rewind or other tape
    motion, it writes two filemarks and backspaces over them before
    closing the device. Note that this means that if you are
    writing, perform an <b>ftt_close_dev</b> followed by an <b>
    ftt_open_dev</b>, and continue writing, you will overwrite the
    filemarks that <b>ftt_close_dev</b> wrote. 
    <p>
      Note that <b>ftt_close_dev</b> can fail, due to insufficient
      room to write tape filemarks, etc.
    </p>
    <p>
      ftt_close_dev performs a close on the operating system
      device. It will only perform tape motion (writing filemarks
      and backspacing) if the preceding operation was a write or
      write filemark. No other operations or tape motions are
      performed.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_close_dev(d);
</pre>
    4 
    <p>
      Reading/Writing
    </p>
    <p>
      All of these routines return -1 on failure, for which more
      information can be obtained as described in the section on
      <i>Finding out what went wrong.</i>
    </p>
    <p>
      4.1 int <b>ftt_read (</b>ftt_descriptor <b>d, char *</b>buf,
      int length)
    </p>
    <p>
      If called with the tape positioned before a data block, the
      <b>ftt_read</b> entry reads a block of length at most <i>
      length</i> from the tape into buffer <i>buf</i>, and returns
      the length of the block actually read. If the next block on
      the tape will not fit into the buffer, or if any other error
      occurs, -1 will be returned
    </p>
    <p>
      If called with the tape positioned before an end-of-file
      mark, 0 is returned, and the position is moved to just after
      the end-of-file mark.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
char data[32768]
int status;
status = ftt_read(d,data,32768);
</pre>
    <h3>
      int <b>ftt_write (</b>ftt_descriptor <b>d, char *buf, int</b>
      length)
    </h3>
    The ftt_write entry transfers as much as possible of the block
    in buffer <i>buf</i> of <i>length</i> to the tape, and returns
    the length written, unless an error occurs, in which case -1 is
    returned. The tape is positioned after the written block. 
    <p>
      In the case of an unrecoverable error, an error number of
      FTT_UNRECOVERED will be returned for this call, and all
      subsequent calls made until one of <b>ftt_rewind,
      ftt_unload,</b> <b>ftt_close_dev,</b> or <b>ftt_close</b> is
      called.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
char data[32768]
int status;
status = ftt_write(d,data,32768);
</pre>
    4.3 int <b>ftt_writefm (</b>ftt_descriptor <b>d)</b> 
    <p>
      The ftt_writefm entry writes a single filemark to the tape.
      After the call, the tape position is after the written
      filemark.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_writefm(d);
</pre>
    <h3>
      int <b>ftt_write2fm</b> (ftt_descriptor <b>d)</b>
    </h3>
    The ftt_write2fm call writes 2 filemarks to the tape. After the
    call, the tape position is after the second filemark so
    written. After making this call, <b>ftt</b> "forgets" that it
    has been writing, since the guarantee that there is a double
    file mark at the end of tape has been established. 
    <p>
      4.5 ftt_retry (ftt_descriptor <b>d</b>, int <b>tries,</b>
      (*<b>op</b>) (ftt_descriptor, char *, int), char *<b>buf</b>,
      int <b>len</b>);
    </p>
    <p>
      The <b>ftt_retry</b> call calls the routine passed in as <b>
      op</b>, with arguments <b>d, buf,</b> and <b>len</b>, and if
      the call fails, retries it up to <b>tries</b> more times.
      Before retrying, <b>ftt_retry</b> will skip backwards to the
      nearest filemark, then skip forward to just after the last
      successfully written block, and retry the operation. The
      recovery sequence is correspondingly sluggish on some tape
      drives.
    </p>
    <p>
      The <b>op</b> passed in should be either <b>ftt_read</b> or
      <b>ftt_write</b>.
    </p>
    <p>
      Note that if retrying <b>ftt_write</b> calls, the reverse
      skip will attempt to write 2 filemarks, making the recovery
      even slower.
    </p>
    <p>
      This call will fail if:
    </p>
    <p>
      * any of the file or record skips fail
    </p>
    <p>
      * the number of retires is exceeded without a successful
      write
    </p>
    <p>
      The return code will be the result of the last operation,
      either <b>ftt_skip_fm, ftt_skip_rec,</b> or the return code
      from the passed in <b>op</b>.
    </p>
    <p>
      Example:
    </p>
    <p>
      char buf[2048]
    </p>
    <p>
      res = ftt_retry(d, 5, ftt_read, buf, 2048);
    </p>
    <p>
      will make up to a total of 6 read calls, interspersed with
      file and record skips.<br>
      <!--NewPage-->
    </p>
    <h2>
      Moving around on the tape
    </h2>
    Tape drives allow you to do more then just read and write, they
    also allow you to move around the tape, and perform other
    operations. The <b>ftt</b> library contains several calls for
    tape motion. 
    <p>
      All of these routines return -1 on failure, for which more
      information can be obtained as described in the section on
      <i>Finding out what went wrong.</i>
    </p>
    <h3>
      int ftt_skip_fm (ftt_descriptor d, int count)
    </h3>
    skips forwards to just after a filemark, or backwards to just
    before a filemark. <i>count</i> indicates the number of
    filemarks to skip. <i>count</i> should be negative to skip
    backwards. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_skip_fm(d, 3);
</pre>
    to skip forward 3 filemarks, or: 
<pre>
status = ftt_skip_fm(d, -2);
</pre>
    to skip backwards 2 filemarks. 
    <p>
      Note that skipping backwards will write two filemarks and
      skip back over them first if the preceding operation was an
      <b>ftt_write</b> or <b>ftt_writefm</b> call.<br>
      &nbsp;
    </p>
    <h3>
      int ftt_skip_rec (ftt_descriptor d, int count)
    </h3>
    <p>
      <br>
      skips forward just past records, or backwards just before
      records. <i>count</i> indicates the number of records to
      skip. <i>count</i> should be negative to skip backwards.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_skip_rec(d, 3);
</pre>
    to skip forward 3 records, or: 
<pre>
status = ftt_skip_rec(d, -2);
</pre>
    to skip backwards 2 records. 
    <p>
      Note that skipping backwards will write two filemarks and
      skip back over them first if the preceding operation was an
      <b>ftt_write</b> or <b>ftt_writefm</b> call.
    </p>
    <h3>
      int ftt_skip_to_double_fm (ftt_descriptor d)
    </h3>
    skips forward until it finds two filemarks in a row, and
    positions the tape between the two filemarks. This is often
    useful for appending to unlabeled tapes. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_skip_to_double_fm(d);
</pre>
    <h3>
      int ftt_rewind (ftt_descriptor d)
    </h3>
    skips backwards to the beginning of tape. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_rewind(d);
</pre>
    <h3>
      int <b>ftt_retension (</b>ftt_descriptor <b>d)</b>
    </h3>
    retensions and rewinds tape. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_rewind(d);
</pre>
    <h3>
      int ftt_unload (ftt_descriptor d)
    </h3>
    ejects the tape from the tape drive (if possible). 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_unload(d);
</pre>
    <h3>
      int ftt_erase (ftt_descriptor d)
    </h3>
    erases and rewinds the tape in the tape drive (if possible). 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_erase(d);
</pre>
    <!--NewPage-->
    <h2>
      Densities, Compression, and other Modes
    </h2>
    The various tape drives generally read and write at a
    particular <b>density</b> (which refers to the amount of data
    per length or area of tape), and often have some densities they
    can read and write, some they can only read, etc. In addition
    drives can use <b>compression</b> to write less data on the
    tape. Also, many operating systems provide devices with various
    software-generated modes, such as having the drive rewound when
    the system device is closed, or retensioned when it is opened.
    The <b>ftt</b> library provides several calls for dealing with
    these various sorts of mode settings. 
    <p>
      All of these routines normally return a character pointer to
      a string containing the name of whatever system device will
      be used to perform I/O in this mode. The routines all return
      0 if anything goes wrong, see the section <i>Finding out what
      went wrong</i> for a discussion of errors.
    </p>
    <h3>
      char *ftt_set_mode (ftt_descriptor <b>d,</b> int <b>
      density,</b> int<b>cmp,</b> int <b>blocksize)</b>
    </h3>
    lets you pick a specific density number in <i>density</i>, turn
    compression on or off in <i>cmp</i>, and set variable blocking,
    or a given fixed blocksize in <i>blocksize</i>. This mainly has
    effect for writing tapes, since most drives will automatically
    switch densities when reading to match the density at which the
    tape was written. <i>blocksize</i> is specified in bytes, with
    a <i>blocksize</i> of zero indicating variable block mode. The
    routine returns the name of the system device it will use for
    operations at that density, etc. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
char *name;
ftt_descriptor d;
int density;
int cmp = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* compression on */
int blocksize = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variable block */
name = ftt_set_mode(d, density, cmp, blocksize);
</pre>
    <h3>
      char *ftt_get_mode (ftt_descriptor <b>d,</b> int
      *<b>density,</b> int<b>*cmp,</b> int <b>*blocksize)</b>
    </h3>
    tells you what density in <i>density</i>, compression in <i>
    cmp</i>, and blocksize in blocksize were last set by <b>
    ftt_get_mode</b>. This is mainly useful to find out what
    defaults were set, which should be the highest density,
    uncompressed format for the drive you are using. You pass in
    pointers to the integers you want back, so that the routine can
    return multiple values. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
char *name;
ftt_descriptor d;
int density;
int cmp;
int blocksize;
name = ftt_get_mode(d, &amp;density, &amp;cmp, &amp;blocksize);
</pre>
    <h3>
      char *ftt_avail_mode (ftt_descriptor <b>d,</b> int <b>
      density,</b> int<b>cmp,</b> int <b>fixed)</b>
    </h3>
    tells you whether a call to <b>ftt_set_mode</b> with a given
    set of arguments should succeed, although it only checks
    whether the last argument is zero or nonzero, to indicate fixed
    blocksize or variable, respectively. It similarly returns the
    system device name that would be used when doing input/output
    at that density, etc. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
char *name;
ftt_descriptor d;
int density;
int cmp = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* compression on */
int fixed = FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variable block */
name = ftt_avail_mode(d, density, cmp, fixed);
</pre>
    <h3>
      char <b>*ftt_density_to_name (</b>ftt_descriptor <b>d,</b>
      int <b>density)</b>
    </h3>
    Translates an integer density number to a descriptive string or
    name. 
    <h3>
      int <b>ftt_name_to_density (</b>ftt_descriptor <b>d,</b> char
      *<b>name)</b>
    </h3>
    Translates a name to an integer density number. The name can be
    any prefix of a density string which would be returned by <b>
    ftt_density_to_name()</b> for that device. 
    <h3>
      int <b>ftt_get_max_blocksize (</b>ftt_descriptor <b>d)</b>
    </h3>
    Returns the largest blocksize usable on this drive type and
    platform, suitable for getting a block size to allocate for a
    read/write or copy buffer. 
    <h3>
      int <b>ftt_set_data_direction(</b>ftt_descriptor <b>d</b>,
      int <b>n)</b>
    </h3>
    This sets the "data direction" flag, which is used on drives
    like Exabyte 8200's that do not provide real read and write
    counters, to decide whether i/o estimates based on remaining
    tape counters should be treated as read or write counts. Making
    this call is important if collecting tape statistics for tape
    I/O done by another process. <br>
    <!--NewPage--> 
    <h2>
      Dealing with System Device Names
    </h2>
    The various operating systems have multiple device names which
    are associated with the same tape drive. For example, the IRIX
    operating system currently has 38 device nodes for a single
    8500 tape drive. 
    <h3>
      char **<b>ftt_list_all (</b>ftt_descriptor <b>d)</b>
    </h3>
    returns a pointer to a static list of device pathnames related
    to this drive. 
    <p>
      ftt_list_all performs no tape operations. It returns the list
      of devices we think should be present, which is determined
      when <b>ftt_open_logical</b> is called.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
char **all_names;
ftt_descriptor d;
all_names = ftt_list_all(d);
</pre>
    <h3>
      int <b>ftt_chall (</b>ftt_descriptor <b>d,</b> int <b>
      uid,</b> int <b>gid,</b> int <b>mode)</b>
    </h3>
    All character special devices relating to the file named by
    descriptor have their ownership changed to the pass-ed in uid,
    gid. and are set to the given mode. This call will only succeed
    if called with the appropriate permissions, it will not be
    handled by a setuid executable. 
    <p>
      ftt_chall performs no tape operations, it merely changes
      permissions on the devices in <b>/dev</b>.
    </p>
    <h3>
      int ftt_get_mode_dev(ftt_descriptor <b>d,</b> char
      *<b>devname,</b> int *<b>density,</b> int <b>*cmp,</b> int
      *<b>fixed,</b> int *<b>rewind)</b>
    </h3>
    Returns the density in <i>density</i>, compression in <i>
    cmp</i>, fixed block flag, <i>fixed</i>, and rewind/retension
    status in <i>rewind</i> for the device <i>devname</i>. 
    <p>
      The <i>rewind</i> value returned will have a value of <b>
      FTT_RWOC, FTT_RTOO</b>, or bitwise combinations of these
      values, to indicate ReWind On Close and ReTension On Open,
      respectively.
    </p>
    <p>
      A <i>fixed</i> value of 0 indicates variable blocking, a <i>
      fixed</i> of 1 indicates fixed block operation, <b>but does
      not provide the current blocksize.</b>
    </p>
    <p>
      ftt_get_mode_dev performs no tape operations.
    </p>
    <p>
      Example:
    </p>
<pre>
&nbsp;#include "ftt.h"
int status;
ftt_descriptor d;
char *devname = "/dev/my_favorite_device";
int density;
int cmp;
int fixed;
int rewind
status = ftt_get_mode_dev(d, devname, &amp;density, &amp;cmp, &amp;fixed, &amp;rewind);
</pre>
    <h3>
      int ftt_set_mode_dev (ftt_descriptor <b>d,</b> char * <b>
      devname,</b> int <b>force)</b>
    </h3>
    Sets the compression, density, etc. to match that of the device
    name passed in. The argument must be a name associated with the
    device opened by <b>ftt_open</b>. 
    <p>
      The <i>force</i> flag (if set to one) forces the exact device
      name specified to be used, allowing access to devices which
      are otherwise unsupported.
    </p>
    <p>
      ftt_set_mode_dev performs no tape operations, it merely sets
      flags, etc. which will be used by <b>ftt_open_dev.</b>
    </p>
    <p>
      Example:
    </p>
<pre>
&nbsp;#include "ftt.h"
int status;
ftt_descriptor d;
char *devname = "/dev/my_favorite_device";
int force = FALSE;
status = ftt_set_mode_dev (d, devname, force);
</pre>
    <h3>
      int ftt_describe_dev(ftt_descriptor <b>d,</b> char
      *<b>devname,</b> FILE *pf<b>)</b>
    </h3>
    prints a description of the given device indicated in <i>
    devname</i>, listing the density, compression options, rewind
    modes, etc. on the file <i>pf</i>. It returns the number of
    bytes written on the file. This routine performs no tape
    operations. 
    <p>
      Example:
    </p>
<pre>
#include &lt;stdio.h&gt;
#include "ftt.h"
int status;
ftt_descriptor d;
char *devname = "/dev/my_favorite_device";
status = ftt_describe_dev (d, devname, stdout);
</pre>
    <h3>
      char *ftt_get_basename(ftt_descriptor <b>d)</b>
    </h3>
    returns the basename for the device; thereby the basename for a
    tape device can be found by doing an <b>ftt_open</b> followed
    by an <b>ftt_get_basename.</b> 
    <p>
      ftt_get_basename performs no tape operations.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
char *basename;
ftt_descriptor d;
basename = ftt_get_basename(d);
</pre>
    <h3>
      int <b>ftt_list_supported</b> (FILE *<b>pf)</b>
    </h3>
    Prints a description of the device types and operating systems
    that ftt officially supports on the file descriptor <b>pf</b>.
    No ftt descriptors need to be open to make this call. 
    <!--NewPage-->
    <h2>
      Tape Statistics
    </h2>
    Tape drives (especially newer ones) maintain a wealth of
    information about how much data they have written, how many
    errors they encountered, etc. The following table lists the
    various statistics that ftt keeps track of and what type of
    statistic it is: string, numeric, counter, or flag. Note that
    all drives do not support all statistics. 
    <center>
      <p>
        TABLE 3. ftt statistics
      </p>
    </center>
    <table border>
      <tr align="LEFT">
        <td align="LEFT">
          stat
        </td>
        <td align="LEFT">
          Description
        </td>
        <td align="LEFT">
          Notes
        </td>
        <td align="LEFT">
          Origin
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_VENDOR_ID
        </td>
        <td align="LEFT">
          vendor id data
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Drive:SCSI Inquiry
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_PRODUCT_ID
        </td>
        <td align="LEFT">
          product id
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Drive:SCSI Inquiry
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_FIRMWARE
        </td>
        <td align="LEFT">
          firmware rev level
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Drive:SCSI Inquiry
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_SERIAL_NUM
        </td>
        <td align="LEFT">
          Device serial number
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Drive:SCSI2 Inquiry
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_CLEANING_BIT
        </td>
        <td align="LEFT">
          Device needs cleaning
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_READ_COUNT
        </td>
        <td align="LEFT">
          Decimal number of KBread since rewind/reset
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense (EXB specific) <b>or</b> SCSI2 Log
          Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_WRITE_COUNT
        </td>
        <td align="LEFT">
          Decimal number of KB written since rewind/reset
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          (see above)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_READ_ERRORS
        </td>
        <td align="LEFT">
          Read errors - drive corrected
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          (see above)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_WRITE_ERRORS
        </td>
        <td align="LEFT">
          Write errors - drive corrected
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          (see above)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_READ_COMP
        </td>
        <td align="LEFT">
          Compression factor for reads
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI2 Log Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_WRITE_COMP
        </td>
        <td align="LEFT">
          Compression factor for writes
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI2 Log Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_FILE_NUMBER
        </td>
        <td align="LEFT">
          File number from BOT
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Ftt: d-&gt;current_file
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_BLOCK_NUMBER
        </td>
        <td align="LEFT">
          Block number in current file
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Ftt: d-&gt;current_block
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_BOT
        </td>
        <td align="LEFT">
          at beginning of tape
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Ftt: bookkeeping (above), <b>or</b> SCSI Request Sense,
          <b>or</b> SCSI Read Position
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_READY
        </td>
        <td align="LEFT">
          Device ready status
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense <b>or</b> SCSI Test Unit Ready
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_WRITE_PROT
        </td>
        <td align="LEFT">
          Device write protect status
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI Mode Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_FMK
        </td>
        <td align="LEFT">
          At filemark
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_EOM
        </td>
        <td align="LEFT">
          At end of media (early warning)
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_PEOT
        </td>
        <td align="LEFT">
          At physical end of tape (really at end)
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense (EXB-Specific)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_MEDIA_TYPE
        </td>
        <td align="LEFT">
          Media type
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI ModeSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_BLOCK_SIZE
        </td>
        <td align="LEFT">
          Tape block size
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI Mode Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_BLOCK_TOTAL
        </td>
        <td align="LEFT">
          Tape length in KB
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI Mode Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TRANS_DENSITY
        </td>
        <td align="LEFT">
          Translated density ala ftt_get_mode
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Ftt: table and FTT_DENSITY
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TRANS_COMPRESS
        </td>
        <td align="LEFT">
          Translated compression ala ftt_get_mode
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          (see above) <b>and</b> SCSI2 Mode Sense page 0x10
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_REMAIN_TAPE
        </td>
        <td align="LEFT">
          Remaining KB of tape
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_USER_READ
        </td>
        <td align="LEFT">
          KB read since open/ unload
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt: d-&gt;readkb
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_USER_WRITE
        </td>
        <td align="LEFT">
          KB written since open/ unload
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt: d-&gt;writekb
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_CONTROLLER
        </td>
        <td align="LEFT">
          Controller type
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Ftt: table
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_DENSITY
        </td>
        <td align="LEFT">
          Tape density
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive:SCSI Mode Sense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ILI
        </td>
        <td align="LEFT">
          Invalid Length Indicator
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_SCSI_ASC
        </td>
        <td align="LEFT">
          Additional Sense Code
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_SCSI_ASCQ
        </td>
        <td align="LEFT">
          Additional Sense Code Qualifier
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_PF
        </td>
        <td align="LEFT">
          Power Failed!
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense (EXB specific)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_CLEANDED_BIT
        </td>
        <td align="LEFT">
          Cleaning performed per FTT_CLEANING_BITt
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TRACK_RETRY
        </td>
        <td align="LEFT">
          Track retry errors
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive:SCSI ReqSense (EXB 8x05 specific)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_UNDERRUN
        </td>
        <td align="LEFT">
          stop/start counter from
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          (see above)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_MOTION_HOURS
        </td>
        <td align="LEFT">
          hours tape drive is in motion
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Drive SCSI ReqSense (DLT specific)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_POWER_HOURS
        </td>
        <td align="LEFT">
          Number of hours device has been on
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Drive:SCSI ReqSense (DLT specific)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TUR_STATUS
        </td>
        <td align="LEFT">
          Status
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive:ScsiTestUnit Ready
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_COUNT_ORIGIN
        </td>
        <td align="LEFT">
          Origin of read/write kb
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Ftt
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_N_READS
        </td>
        <td align="LEFT">
          Number of read calls
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt: d-&gt;nreads
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_N_WRITES
        </td>
        <td align="LEFT">
          Number of write and writefm calls
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt: d-&gt;nwrites
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TNP
        </td>
        <td align="LEFT">
          Tape Not Present bit
        </td>
        <td align="LEFT">
          flag
        </td>
        <td align="LEFT">
          Drive: SCSI ReqSense (EXB specific)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_SENSE_KEY
        </td>
        <td align="LEFT">
          Sense Key
        </td>
        <td align="LEFT">
          numeric
        </td>
        <td align="LEFT">
          Drive:SCSI ReqSense
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TRANS_SENSE_KEY
        </td>
        <td align="LEFT">
          Above translated to strings
        </td>
        <td align="LEFT">
          string
        </td>
        <td align="LEFT">
          Ftt:
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_RETRIES
        </td>
        <td align="LEFT">
          total ftt_retry() repeats
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt:
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_FAIL_RETRIES
        </td>
        <td align="LEFT">
          total ftt_retry() failures
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_RESETS
        </td>
        <td align="LEFT">
          Unexpected BOT discoveries
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_HARD_ERRORS
        </td>
        <td align="LEFT">
          Counter of recovered errors
        </td>
        <td align="LEFT">
          counter
        </td>
        <td align="LEFT">
          Ftt
        </td>
      </tr>
    </table>
    <h3>
      ftt_stat_buf <b>ftt_alloc_stat (void)</b>
    </h3>
    allocates a statistic buffer for use with the other ftt
    statistics routines. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_stat_buf stbuff;
stbuff = ftt_alloc_stat();
</pre>
    <h3>
      int <b>ftt_free_stat(</b>ftt_stat_buf <b>stbuff)</b>
    </h3>
    frees a statistic buffer indicated by <i>stbuff</i>. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_stat_buf stbuff;
status = ftt_free_stat(stbuff);
</pre>
    <h3>
      int <b>ftt_get_stats(ftt_descriptor</b> d, ftt_stat_buf
      stbuff)
    </h3>
    extracts current statistics for tape usage, including data
    written, data read, write errors, read errors, etc. and packs
    it into an ftt_stat_buf structure, <i>stbuff</i>. Note that
    because on some platforms we must close and reopen devices to
    implement this call, ftt_get_stats will always put filemarks on
    your tape if you have been writing (see <b>ftt_close_dev</b>). 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_stat_buf stbuff;
stbuff = ftt_alloc_stat();
status = ftt_get_stats(d,stbuff);
</pre>
    <h3>
      char *<b>ftt_extract_stats (</b>ftt_stat_buf <b>b,</b> int
      <b>stat)</b>
    </h3>
    extracts a string describing a named piece of tape data,
    indicated by stat. Acceptable values for stat are listed in
    Table 2. The routine will return a null pointer (0) if a given
    statistic is not available in the status block. 
    <p>
      ftt_extract_stats performs no tape operations.
    </p>
    <p>
      Example:
    </p>
<pre>
#include &lt;stdio.h&gt;
#include "ftt.h"
char *value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* value of extracted stat */
ftt_stat_buf stbuff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* statistics buffer */
int status, ftt_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status of ftt calls */
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */
</pre>
<pre>
stbuff = ftt_alloc_stat();
status = ftt_get_stats(d,stbuff);
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}
value = ftt_extract_stats(stbuff,FTT_MOTION_HOURS);
ftt_free_stat(stbuff);
</pre>
    <h3>
      void <b>ftt_sub_stats (</b>ftt_stat_buf <b>b1</b>,
      ftt_stat_buf <b>b2</b>, ftt_stat_buf <b>res)</b>
    </h3>
    subtracts numeric values in the stat buffer <i>b1</i> from the
    values in <i>b2</i>and the result is put in <i>res</i>, to keep
    running totals, and/or compute deltas. String values are taken
    from <i>b1</i>, unless the entry in <i>b1</i> is null and the
    one in <i>b2</i> is not. Flag values are taken from <i>b1</i>. 
    <p>
      Note that media type and compression rates, while technically
      numeric, are not treated as such by these routines, since
      subtracting them is meaningless.
    </p>
    <p>
      ftt_sub_stats performs no tape operations.
    </p>
    <p>
      Example:
    </p>
<pre>
#include &lt;stdio.h&gt;
#include "ftt.h"
int status, ftt_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status of ftt calls */
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */
ftt_stat_buf b1,b2,res;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* statistics buffers */
&nbsp;
b1 = ftt_alloc_stat();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get buffers */
b2 = ftt_alloc_stat();
res = ftt_alloc_stat();
status = ftt_get_stats(d,b1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get tape statistics */
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}
</pre>
<pre>
/* do some tape i/o here */
</pre>
<pre>
status = ftt_get_stats(d,b2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get tape statistics again */
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}
ftt_sub_stats(b1, b2, res);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get deltas and store in res */
</pre>
<pre>
ftt_free_stat(b1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* free buffers */
ftt_free_stat(b2);
ftt_free_stat (res);
</pre>
    <h3>
      void <b>ftt_add_stats (</b>ftt_stat_buf <b>b1</b>,
      ftt_stat_buf <b>b2</b>, ftt_stat_buf <b>res)</b>
    </h3>
    adds numeric values in the stat buffer <i>b1</i> to the values
    in <i>b2</i> and the result is put in <i>res</i>, to keep
    running totals, and/or compute deltas. String values are taken
    from <i>b1</i>, unless the entry in <i>b1</i> is null and the
    one in <i>b2</i> is not. Flag values are taken from <i>b1</i>. 
    <p>
      Note that media type and compression rates, while technically
      numeric, are not treated as such by these routines, since
      adding them is meaningless.
    </p>
    <p>
      ftt_add_stats performs no tape operations.
    </p>
    <p>
      Example: see ftt_sub_stats example.
    </p>
    <p>
      8.7 ftt_stat_buf *<b>ftt_init_stats (</b>ftt_descriptor <b>
      d)</b>
    </p>
    <p>
      returns pair of statistics buffers. The first is initialized
      with zeros and the second with current statistics for the
      drive.
    </p>
    <p>
      This routine performs a <b>ftt_get_stats</b> which in turn
      calls <b>ftt_close_dev</b> which will write file marks if the
      preceding operation was a write or write file mark.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_stat_buf *bp;
ftt_descriptor d;
bp = ftt_init_stats(d);
</pre>
    <h3>
      int <b>ftt_update_stats (</b>ftt_descriptor <b>d,</b>
      ftt_stat_buf *<b>bp)</b>
    </h3>
    updates the status pair <i>bp</i>, keeping running totals in
    <i>bp[0]</i> and latest statistics in <i>bp[1]</i>.This routine
    performs a <b>ftt_get_stats</b> which in turn calls <b>
    ftt_close_dev</b> which will write file marks if the preceding
    operation was a write or write file mark. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
ftt_stat_buf *bp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status buffer pair */
ftt_descriptor d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ftt file descriptor */
int status, ftt_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status of ftt calls */
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */
</pre>
<pre>
bp = ftt_init_stats(d);
/* do some tape i/o here */
status = ftt_update_stats(d,bp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update statistics again */
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}
</pre>
    <h3>
      int <b>ftt_dump_stats (</b>ftt_stat_buf <b>b,</b> FILE
      *<b>pf)</b>
    </h3>
    prints important statistics from the statistics buffer <i>b</i>
    on file descriptor <i>pf</i><b>. ftt_dump_stats</b> performs no
    tape I/O. It returns the number of bytes written on the file. 
    <p>
      Example:
    </p>
<pre>
#include &lt;stdio.h&gt;
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_stat_buf stbuff;
stbuff = ftt_alloc_stat();
status = ftt_get_stats(d,stbuff);
status = ftt_dump_stats (stbuff, stderr);
ftt_free_stat(stbuff);
</pre>
    <!--NewPage-->
    <h2>
      Mulitple Partition Tapes
    </h2>
    <h3>
      ftt_partbuf&nbsp; ftt_alloc_parts()
    </h3>
    This routine creates a buffer which holds a tape partitiion
    table. 
    <h3>
      void&nbsp; ftt_free_parts(ftt_partbuf p)
    </h3>
    This routine frees the memory associated with a tape partition
    buffer. 
    <h3>
      int&nbsp; ftt_extract_nparts(ftt_partbuf p)
    </h3>
    This routine gets the current total number of partitions from a
    partition buffer 
    <h3>
      int&nbsp; ftt_extract_maxparts(ftt_partbuf p)
    </h3>
    This routine gets the maximum allowable partitions from a
    partition buffer. 
    <h3>
      long&nbsp; ftt_extract_part_size(ftt_partbuf p,int n)
    </h3>
    This routine gets the size of the <b>n</b>th partition from a
    partition buffer. 
    <h3>
      int&nbsp; ftt_set_nparts(ftt_partbuf p,int n)
    </h3>
    This routine sets the current number of partitions in a
    partition buffer. 
    <h3>
      int&nbsp; ftt_set_part_size(ftt_partbuf p,int n,long sz)
    </h3>
    This routine sets the partition size of the <b>n</b>th
    partition. 
    <h3>
      int ftt_get_partitions(ftt_descriptor d,ftt_partbuf p)
    </h3>
    This fills a partition buffer with the current partition
    information of a drive. 
    <h3>
      int ftt_write_partitions(ftt_descriptor d,ftt_partbuf p)
    </h3>
    This takes a partition buffer, and attempts to partition the
    tape in the drive to match.&nbsp;&nbsp; Note that drives will
    generally adjust the size of partition 0 to be whatever space
    is left on the tape, regardless what size is currently set in
    the buffer. 
    <h3>
      int ftt_cur_part(ftt_descriptor d)
    </h3>
    This returns the current partition number of the location of
    the tape in the drive . 
    <h3>
      int ftt_skip_part(ftt_descriptor d,int nparts)
    </h3>
    This skips forward (or backward if nparts is negative) nparts
    partitions, to the beginning of the partition. 
    <h3>
      int ftt_locate_part(ftt_descriptor d, int blockno, int part)
    </h3>
    This skips to a particular lowlevel block number inside an
    absolute partition number.&nbsp; This lets you return to an
    arbitrary tape location obtained as a partition from
    ftt_cur_part(), and a block number from (ftt_get_stats(fd,buf),
    ftt_extract_stat(buf,FTT_BLOCK_LOC)). 
    <h3>
      void ftt_dump_partitions(ftt_partbuf parttab, FILE *pf)
    </h3>
    This prints a text listing of a partition buffer on file
    descriptor pf. 
    <h3>
      void ftt_undump_partitions(ftt_partbuf p, FILE *pf)
    </h3>
    This reads a text listing of a partition buffer from file
    descriptor pf into the partition buffer. 
    <h3>
      int ftt_set_mount_partition(ftt_descriptor d, int partno)
    </h3>
    This attempts to set what partition number the drive will skip
    to when a new tape is mounted in the drive. 
    <h2>
      Status Routines
    </h2>
    <h3>
      int <b>ftt_status(</b>ftt_descriptor <b>d,</b> int <b>
      timeout)</b>
    </h3>
    returns a flags word with the following bits set: 
    <center>
      <p>
        TABLE 4. ftt_status flag bits
      </p>
    </center>
    <table border>
      <tr align="LEFT">
        <td align="LEFT">
          Bit setting
        </td>
        <td align="LEFT">
          Description
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ABOT
        </td>
        <td align="LEFT">
          At beginning of tape
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_AEOT
        </td>
        <td align="LEFT">
          At Physical end of tape
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_AEW
        </td>
        <td align="LEFT">
          At Early Warning mark near EOT
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_PROT
        </td>
        <td align="LEFT">
          Write Protected tape
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ONLINE
        </td>
        <td align="LEFT">
          A tape is loaded and online
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_BUSY
        </td>
        <td align="LEFT">
          The tape is rewinding, unloading, etc. and not
          responding.
        </td>
      </tr>
    </table>
    <p>
      indicating the current tape position. This routine shall
      block up to <i>timeout</i> seconds if there is a tape in the
      drive, waiting for the tape to come online, or to become not
      busy. If we cannot determine the presence of a tape, we will
      simply block until the timeout expires.
    </p>
    <p>
      An external setuid executable will be run to obtain this data
      if necessary (e.g. AIX), which means that file marks will be
      written if the last operation was a <b>ftt_write</b> or <b>
      ftt_writefm,</b> (see <b>ftt_close_dev</b>()). Therefore,
      calling <b>ftt_status</b> after every write should be
      avoided.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;&nbsp;
status = ftt_status (d, 0);
</pre>
    <h3>
      int <b>ftt_get_position(</b>ftt_descriptor <b>d,</b> int
      *<b>file,</b> int *<b>block)</b>
    </h3>
    returns the current <i>file</i> and <i>block</i> position on
    the tape. It ails if no tape is loaded, or the position is
    unknown (i.e. the tape was just opened, has never been rewound
    and is not at BOT.) Note that both <i>file</i> and <i>block</i>
    are zero at BOT, the count is the number of file marks we are
    past BOT and the number of blocks past the last filemark, where
    BOT is treated as the 0-th filemark. 
    <p>
      ftt_get_position performs no tape operations, it merely
      reports bookkeeping information.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
int fileno, blockno
status = ftt_get_position (d, &amp;fileno, &amp;blockno);
</pre>
    <h3>
      char *<b>ftt_get_error (</b>int *<b>pn)</b>
    </h3>
    returns a pointer to a string describing the result of the last
    call. If <i>pn</i> is not null, it is treated as an integer
    pointer and the current error number is stored there. 
    <p>
      ftt_get_error performs no tape operations. Any mode sense
      data reported was obtained by the routine reporting the
      error.
    </p>
    <p>
      Example:
    </p>
<pre>
#include &lt;stdio.h&gt;
#include "ftt.h"
int error;
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */
</pre>
<pre>
estring = ftt_get_error(&amp;ftt_status);
fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp; ftt_ascii_error[error],estring);
</pre>
    <!--NewPage-->
    <h2>
      Volume verification
    </h2>
    <h3>
      int <b>ftt_write_vol_label (</b>ftt_descriptor <b>d,</b> int
      <b>type,</b> char * <b>vollabel)</b>
    </h3>
    rewinds the tape, formats a label specified in <i>vollabel</i>
    into a buffer, and writes the label on the tape, then writes
    two filemarks and backs over one by doing an <b>
    ftt_close_dev</b> and forward skipping one filemark.<i>type</i>
    can be any of the types specified in <b>ftt_guess_label</b>
    (except FTT_DONTCHECK)<b>.</b> 
    <p>
      This routine performs numerous tape operations.
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_write_vol_label(d, FTT_ANSI_HEADER,"mydog");
</pre>
    <h3>
      int <b>ftt_verify_vol_label (</b>ftt_descriptor <b>d,</b> int
      <b>type,</b> char *<b>vollabel,</b> int <b>timeout,</b> int
      <b>rdonly)</b>
    </h3>
    rewinds the tape, uses <b>ftt_status</b> to check if the tape
    is write protected, reads the first block, uses <b>
    ftt_guess_label</b> to check that the label is the indicated
    type and volume label specified in <i>
    vollabel</i>.<i>timeout</i> is the timeout for the status check
    for write protect status, in seconds. <i>type</i> can be any of
    the types specified in <b>ftt_guess_label.</b> <i>rdonly</i>
    <b>is a boolean flag to indicate if the device should be opened
    readonly.</b> 
    <p>
      The tape is left positioned after the volume label.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_verify_vol_label(d, FTT_ANSI_HEADER,"mydog",0,TRUE);
</pre>
    <h3>
      int <b>ftt_guess_label (</b>char *<b>buf,</b> int <b>
      length,</b> char **<b>vol,</b> int **<b>vlen)</b>
    </h3>
    examines a buffer in <i>buf</i> (ostensibly returned by
    ftt_read) with a length of <i>length</i>, and attempts to guess
    what sort of tape format this is, assuming this is the first
    block of the tape. It returns a value of the following type: 
    <center>
      <p>
        TABLE 5. ftt_guess_label label types
      </p>
    </center>
    <table border>
      <tr align="LEFT">
        <td align="LEFT">
          Value
        </td>
        <td align="LEFT">
          Description
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_ANSI_HEADER
        </td>
        <td align="LEFT">
          An ANSI X3.27 standard tape
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_FMB_HEADER
        </td>
        <td align="LEFT">
          An FMB tape
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_TAR_HEADER
        </td>
        <td align="LEFT">
          A tar tape (POSIX nnn)
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_CPIO_HEADER
        </td>
        <td align="LEFT">
          A Cpio -c format tape
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_UNKNOWN_HEADER
        </td>
        <td align="LEFT">
          No known label type
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_BLANK_HEADER
        </td>
        <td align="LEFT">
          Verifies length is -1 and last error was FTT_BLANK
        </td>
      </tr>
      <tr align="LEFT">
        <td align="LEFT">
          FTT_DONTCHECK_HEADER
        </td>
        <td align="LEFT">
          Only used by ftt_verify_vol_label()
        </td>
      </tr>
    </table>
    <p>
      The <i>vol</i> and <i>vlen</i> arguments are taken to be the
      address of a character pointer and of an integer, and will be
      filled in with the address and length of the volume name in
      the tape header, if any.
    </p>
    <p>
      ftt_guess_label performs no tape operations.
    </p>
    <p>
      In most cases, the user could use <b>ftt_verify_vol_label</b>
      directly, which internally makes a <b>ftt_guess_label
      call</b>.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int type;
char *databuf;
int buflen;
char *vollabel;
int vollen;
type = ftt_guess_label(databuf, buflen, vollabel, vollen);
</pre>
    <h3>
      int <b>ftt_format_label (</b>char *<b>buf,</b> int <b>
      length,</b> char *<b>vol,</b> int <b>vlen,</b> int <b>
      type)</b>
    </h3>
    This function will format a label pointed to by string <i>
    vol</i> and of given length (<i>vlen</i>) into a buffer
    (<i>buf</i>) of given length (<i>length</i>) which will return
    the same volume label and type in later calls to <b>
    ftt_guess_label</b>. Users can then write this label at the
    beginning of tape with <b>ftt_write</b>. In most cases, the
    user would call <b>ftt_write_label</b> directly. <i>type</i>
    can be any of the types specified in <b>ftt_guess_label</b>
    (except FTT_DONTCHECK_HEADER). It returns the length of the
    filled in volume header block. 
    <p>
      ftt_format_label performs no tape operations.
    </p>
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int length;
char *databuf;
int buflen;
length = ftt_format_label(databuf, buflen, "mydog",

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen ("mydog"), FTT_ANSI_HEADER);
</pre>
    11 
    <p>
      Issuing Commands Asynchronously
    </p>
    <p>
      By default, all <b>ftt</b> commands are issued synchronously.
      There are several commands, however, that a user may wish to
      issue asynchronously, e.g. f<b>tt_rewind()</b>. With the
      exception of <b>ftt_open()</b> and <b>ftt_close()</b>
      themselves, all <b>ftt</b> commands can optionally be
      asynchronous.
    </p>
    <p>
      When a user decides to issue a command asynchronously, he
      should issue an <b>ftt_fork()</b> command. The child then
      does the desired commands and returns the status vi <b>
      ftt_report()</b>. The parent process can continue doing
      whatever it wants and then rendezvous with the child via <b>
      ftt_wait()</b>. It can also periodically check if the child
      process has completed via <b>ftt_check()</b>;
    </p>
    <p>
      It is important to note that only one asynchronous operation
      at a time may be active on a given file descriptor.
    </p>
    <h3>
      int <b>ftt_fork (</b>ftt_descriptor <b>d)</b>
    </h3>
    Creates an asynchronous process for performing ftt calls, which
    should report status via <b>ftt_report()</b> which will in turn
    be collected via <b>ftt_wait()</b>. Returns a process ID in the
    parent process, a 0 in the child process, and -1 in the case of
    failure. The call is generally used as follows: 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
char *switch (ftt_fork(d)){
case 0: /* child */
&nbsp;&nbsp;&nbsp; ftt_skip_fm(d,2);
&nbsp;&nbsp;&nbsp; ftt_rewind(d);
&nbsp;&nbsp;&nbsp; ftt_report(d);
default: /* parent */
&nbsp;&nbsp;&nbsp; do_stuff_during_rewind();
&nbsp;&nbsp;&nbsp; ftt_wait(d);
&nbsp;&nbsp;&nbsp; break
case -1: /* error */
&nbsp;&nbsp;&nbsp; pc = ftt_get_error(&amp;err);
&nbsp;&nbsp;&nbsp; fprintf(stderr,pc);
&nbsp;&nbsp;&nbsp; exit(0);
}
</pre>
    <h3>
      void <b>ftt_report (</b>ftt_descriptor <b>d)</b>
    </h3>
    Collects up the status from the last <b>ftt</b> call, reports
    it to the parent process, so that it will be collected by <b>
    ftt_wait()</b>, and exits. 
    <h3>
      int <b>ftt_wait (</b>ftt_descriptor <b>d)</b>
    </h3>
    Waits for a pending asynchronous operation to report its status
    with <b>ftt_report()</b>, and sets the error string and error
    code for ftt_get_error to the result of the completed
    operation. 
    <p>
      ftt_wait performs no tape operations of its own.
    </p>
    <h3>
      int <b>ftt_check (</b>ftt_descriptor <b>d)</b>
    </h3>
    The ftt_check routine succeeds if the asynchronous operation
    occurring on the device has completed, otherwise it returns a
    busy device error. 
    <p>
      ftt_check performs no tape operations.
    </p>
    <p>
      12
    </p>
    <p>
      Expert Commands
    </p>
    <p>
      As much as <b>ftt</b> would like hide protect the user from
      implementation specifics, there are times that the expert
      user would REALLY like to something detailed. Most of the
      routines were born when trying to recover data from tapes
      that are overwritten (see the Appendix at the end of this
      user's guide). As a result, <b>ftt</b> provides a few
      routines to facilitate some of these functions for the
      knowledgeable user. It is not recommended that the novice
      user issue these commands.
    </p>
    <h3>
      int ftt_clear_unrecovered (ftt_descriptor d)
    </h3>
    clear the <b>ftt</b> internal unrecovered flag. If certain
    operations fail (e.g. ftt_skip) the tape is left in an unknown
    position. To protect the user from writing reading/writing in
    this area, subsequent i/o calls require the user to first
    reposition to a known location, i.e., the beginning of tape.
    ftt_clear_unrecoverd clears this internal <b>ftt</b> flag and
    will therefore allow additional i/o calls without rewinding.
    This is useful in conjunction with ftt_locate. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_clear_unrecovered (d);
</pre>
    <h3>
      int <b>ftt_all_scsi (</b>ftt_descriptor <b>d)</b>
    </h3>
    all <b>ftt</b> commands will bypass the standard vendor device
    driver and will go through the raw scsi device driver.
    Normally, commands like read and write are not issued in raw
    scsi mode. This is useful when trying to access all of the
    request sense information for read and write commands (by
    setting the ftt_debug level so this information will be
    displayed). It is also useful if the vendor supplied device
    driver is buggy. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_all_scsi(d);
</pre>
    <h3>
      int ftt_locate (ftt_descriptor d, int blockno)
    </h3>
    issues the SCSI locate command to position the tape to the
    specified logical block. 
    <p>
      Example:
    </p>
<pre>
#include "ftt.h"
int status;
int blockno;
ftt_descriptor d;
status = ftt_locate(d,blockno);
</pre>
    13 
    <p>
      Linking an Executable
    </p>
    <p>
      Linking your code with the <b>ftt</b> library should be
      accomplished by adding the following link options to your
      <tt>Makefile</tt> or other build script:
    </p>
    <p>
      -L$(FTT_DIR)/lib -lftt 'cat $(FTT_DIR)/lib/libs'
    </p>
    <p>
      where the last portion in backquotes places the contents of
      the file <tt>libs</tt> in the <b>ftt</b> library directory on
      the link command line. This will include any
      platform-specific libraries needed on the current platform in
      the link without you having to know what they are, or tailor
      your build scripts to different platforms. For example, a
      complete makefile for a program using <b>ftt</b> would look
      like:
    </p>
    <p>
      INC = -I$(FTT_DIR)/include
    </p>
    <p>
      LIB = -L$(FTT_DIR)/lib -lftt 'cat $(FTT_DIR)/lib/libs'
    </p>
    <p>
      CFLAGS = $(INC)
    </p>
    <p>
      LDFLAGS = $(LIB)
    </p>
    <p>
      EXAMPLES = tapecopy
    </p>
    <p>
      all: $(EXAMPLES)
    </p>
    <p>
      tapecopy: tapecopy.c
    </p>
    <p>
      $(CC) $(CFLAGS) -o tapecopy tapecopy.c $(LIB)<br>
      <!--NewPage-->
    </p>
    <h2>
      ftt_test
    </h2>
    An binary is provided with ftt to verify that the test routines
    themselves work as intended as well as that an individual drive
    is behaving normally. ftt_test is a command line parser. It is
    very unsophisticated in that it doesn't support any flow
    control whatsoever: it simply executes one line at time. It can
    be run interactively, through a shell script, or by redirecting
    stdin. 
    <p>
      ftt_test can only have one drive open at a time. The drive
      name is specified in one of the following fashions, in
      descending order of priority:
    </p>
    <p>
      * on the ftt_open call itself (e.g., ftt_open
      /dev/rmt/tps2d4)
    </p>
    <p>
      * on the invocation line (e.g., ftt_test -f /dev/rmt/tps2d4)
    </p>
    <p>
      * from the environment variable FTT_TAPE (e.g. setenv
      FTT_TAPE /dev/rmt/tps2d4).
    </p>
    <h3>
      ftt_test Commands
    </h3>
    For testing purposes, it is desirable to issue commands that
    will generate a certain expected error. To avoid a lot of
    unnecessary clutter, this expected error messages to stderr can
    be suppressed. Each command can take a "-status [FTT_ERROR]"
    option which indicates the expected error for that command. An
    error message will be written to stderr only if this error code
    is not returned. The list of valid values for FTT_ERROR are all
    of the error returns listed earlier in this document (e.g.,
    FTT_EIO, FTT_ENOENT, FTT_ENOTAPE). 
    <p>
      All commands optionally take a "-usage" switch as well. This
      is to aid the interactive user in determining what are the
      valid options and parameters for a given command. If the
      "-usage" switch is used, the actual command will NOT be
      executed, but a usage message will simply be printed to
      stderr.
    </p>
    <h4>
      Open/close Commands
    </h4>
    ftt_open [basename] [-readonly] [-status &lt;error&gt;]
    [-usage] 
    <p>
      calls the corresponding ftt_open library routine using <i>
      basename</i> as the input filename. <i>-readonly</i> will
      open the file for read only access. Without this flag, the
      device is opened for read/write access. The ftt file
      descriptor is stored in a global variable for all other
      accesses on this device by the test routines.
    </p>
    <p>
      ftt_open_logical [basename] [-flavor &lt;flavor&gt;]
      &lt;-driveid &lt;driveid&gt;&gt; [-readonly] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt_open library routine using <i>
      basename</i> as the input filename. <i>flavor</i> indicates
      the operating system flavor to use. If not supplied, the test
      routine will use the current operating system flavor. <i>
      driveid</i> specifies the drive type. <i>-readonly</i> will
      open the file for read only access. Without this flag, the
      device is opened for read/write access. The ftt file
      descriptor is stored in a global variable for all other
      accesses on this device by the test routines.
    </p>
    <p>
      ftt_open_dev [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_close [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_close_dev [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <h4>
      Read/write Commands
    </h4>
    ftt_write_tblock [-nblocks &lt;n&gt;] [-bsize &lt;nbytes&gt;]
    [-delta &lt;ndbytes&gt;] [-alignmask &lt;nalign&gt;] [-delay
    &lt;nsec&gt;] [-status &lt;error&gt;] [-usage] 
    <p>
      write <i>n</i> (default = 1) test blocks of size <i>
      nbytes</i> (default = 32768). If <i>ndbytes</i> is specified,
      the writes will be of random size between <i>nbytes</i> and
      <i>nbytes + ndbytes</i>. If <i>alignment</i> is specified,
      random size records must will be adjusted to this byte
      alignment. Valid values for <i>nalign</i> are 0 (allows odd
      byte writes), 1 (allows odd word writes), and 3 (allows only
      longword multiples). If <i>delay</i> is specified, a random
      delay of 0 to <i>nsec</i> will occur between writes. The
      first longword in the test block is the number of bytes in
      the block, the second is the block number, the third is the
      filename. All remaining bytes are filled with ascending bytes
      starting with (file number + block number)% 256.
    </p>
    <p>
      ftt_verify_tblock [-nblocks &lt;n&gt;] [-delay &lt;nsec&gt;]
      [-oddbyte] [-filemark] [-status &lt;error&gt;] [-maxbytes
      &lt;readsize&gt;] [-usage]
    </p>
    <p>
      read and verify <i>n</i> (default = 1) test blocks If delay
      is specified, a random delay of 0 to <i>nsec</i> will occur
      between reads. If the <i>-oddbyte</i> switch is used, an odd
      number of bytes will be used for the input buffer. <i>
      -filemark</i> indicates that the record should be a filemark.
      <i>readsize</i> will indicate the maximum number of bytes to
      read. This value cannot be greater than 64kbytes.
    </p>
    <p>
      ftt_dump [-nblocks n] [-filename &lt;filename&gt;] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      read <i>n</i> blocks (defaults until end of tape) and then
      write them to stdout or f<i>ilename</i> if specified.
    </p>
    <p>
      ftt_undump [-filename &lt;filename&gt;] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      write until end of data from stdin or filename if specified.
    </p>
    <p>
      ftt_writefm [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_write2fm [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_verify_vol_label [-timeout &lt;nsecs&gt;] [-type
      &lt;type&gt;] [-label &lt;labelname&gt;] [-readonly] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. Information is written
      to stderr. This command will wait <i>nsecs</i> for the drive
      to come online. The default value is 0. Valid <i>types</i>
      are:
    </p>
    <p>
      * FTT_ANSI_HEADER
    </p>
    <p>
      * FTT_FMB_HEADER
    </p>
    <p>
      * FTT_TAR_HEADER
    </p>
    <p>
      * FTT_CPIO_HEADER
    </p>
    <p>
      * FTT_UNKNOWN_HEADER
    </p>
    <p>
      * FTT_BLANK_HEADER
    </p>
    <p>
      * FTT_DONTCHECK_HEADER
    </p>
    <p>
      If not specified, a type of FTT_ANSI_HEADER is assumed.
    </p>
    <p>
      ftt_write_vol_label [-type &lt;type&gt;] [-label
      &lt;labelname&gt;] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. The valid values for
      <i>type</i> are the same as in ftt_verify_vol_label.
    </p>
    <p>
      If not specified, FTT_ANSI_HEADER is assumed.
    </p>
    <h4>
      Tape Positioning Commands
    </h4>
    ftt_status [-timeout &lt;nsecs&gt;] [-status &lt;error&gt;] 
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor and prints the current
      drive status. The user can specify a timeout of <i>nsecs</i>.
      If no timeout is specified, the default value is 0.
    </p>
    <p>
      ftt_test_status [-&lt;flag1&gt;... [-&lt;flag&gt;]] [-timeout
      &lt;nsecs&gt;] [-status &lt;error&gt;]
    </p>
    <p>
      calls ftt_status using the global variable for the ftt file
      descriptor. Each flag is tested to see if the condition is
      true. Valid values for <i>flag</i> are: FTT_ABOT, FTT_AEOT,
      FTT_AEW, FTT_PROT, FTT_ONLINE, and FTT_BUSY. The user can
      specify a timeout of <i>nsecs</i>. If no timeout is
      specified, the default value is 0.
    </p>
    <p>
      ftt_skip_to_double_fm [-async] [-status &lt;error&gt;]
      [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously.
    </p>
    <p>
      ftt_skip_fm &lt;nfilemarks&gt; [-async] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously.
    </p>
    <p>
      ftt_skip_rec &lt;nrecords&gt; [-async] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously.
    </p>
    <p>
      ftt_rewind [-async] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously.
    </p>
    <p>
      ftt_retension [-async] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously
    </p>
    <p>
      ftt_erase [-async] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously.
    </p>
    <p>
      ftt_unload [-async] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor where <i>async</i> will
      issue the command asynchronously.
    </p>
    <p>
      ftt_get_position [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. The current file and
      block number is written to stderr.
    </p>
    <p>
      ftt_verify_position &lt;fileno&gt; &lt;blockno&gt;
    </p>
    <p>
      verifies that the position specified by fileno and blockno
      match those returned by ftt_get_position.
    </p>
    <h4>
      Asynchronous Support Commands
    </h4>
    ftt_wait [-status &lt;error&gt;] [-usage] 
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_check [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <h4>
      Get/set Mode Commands and Other Commands That Care About
      Filenames
    </h4>
    ftt_list_all [-status &lt;error&gt;] [-usage] 
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. The list of device node
      pathnames is written to stderr.
    </p>
    <p>
      ftt_chall &lt;uid&gt; &lt;gid&gt; &lt;mode&gt; [-status
      error] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. The user name is
      specified in <i>uid</i>, the group name in <i>gid</i>, and
      the mode in <i>mode</i>.
    </p>
    <p>
      ftt_verify_exist
    </p>
    <p>
      verifies that all of the filenames listed by ftt_list_all
      really do exist.
    </p>
    <p>
      ftt_avail_mode &lt;density&gt; &lt;mode&gt; [-blocksize
      &lt;b&gt;] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. The density and mode
      must be specified in <i>density</i> and <i>mode</i>
      respectively. If the blocksize is not specified, variable
      block will be assumed. The device node is printed to stderr.
    </p>
    <p>
      ftt_get_mode [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the ftt_get_mode library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_set_mode &lt;density&gt; &lt;mode&gt; [-blocksize
      &lt;b&gt;] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the ftt_set_mode library routine using the global
      variable for the ftt file descriptor. If no blocksize is
      specified, variable block mode is assumed.
    </p>
    <p>
      ftt_get_mode_dev [device_name] [-status &lt;error&gt;]
      [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. Node information is
      written to stderr.
    </p>
    <p>
      ftt_set_mode_dev &lt;devname&gt; [-blocksize &lt;b&gt;]
      [-force] [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. If no blocksize is
      specified, variable block mode is assumed. <i>-force</i> will
      turn the force flag on. It is off by default.
    </p>
    <p>
      ftt_verify_modes
    </p>
    <p>
      verifies all modes of the device. This routines will loop
      through all modes of the device. It will set the mode, write,
      verify the mode is what we think it should be, rewind, and
      then verify the data.
    </p>
    <p>
      ftt_get_basename [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_describe_dev [device_name] [-status &lt;error&gt;]
      [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <h4>
      Statistics Commands
    </h4>
    ftt_get_stats [-status &lt;error&gt;] [-usage] 
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. Information is written
      to stderr.
    </p>
    <p>
      ftt_extract_stats &lt;statistic&gt; [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. Information is written
      to stderr. Valid values for <i>statistic</i> are from the
      list described earlier in this document (e.g.,
      FTT_PRODUCT_ID, FTT_VENDOR_ID, FTT_DENSITY, etc.).
    </p>
    <p>
      ftt_init_stats [-status &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_update_stats [-errors][-part_display] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. The accumulated totals
      are written to stderr. <i>-part_display</i> will only display
      the statistics that are counters, while <i>-errors</i> will
      display the read/write counts, errors, and percent error
      rates.
    </p>
    <p>
      ftt_dump_stats [-filename &lt;filename&gt;] [-status
      &lt;error&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. It will dump the stats
      to <i>filename</i> if specified, otherwise stderr.
    </p>
    <p>
      ftt_list_supported [-filename &lt;filename&gt;] [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine. It will dump the
      stats to <i>filename</i> if specified, otherwise stderr.
    </p>
    <h4>
      Error Commands
    </h4>
    ftt_eprintf &lt;string&gt; [-usage] 
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_get_error [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. Information is written
      to stderr.
    </p>
    <p>
      ftt_max_error [&lt;maxerror&gt;]
    </p>
    <p>
      Set/show the current maximum number of errors before ftt_test
      will abort.
    </p>
    <h4>
      Expert Commands
    </h4>
    These commands are not meant for the novice user, but we have
    found them invaluable in salvaging overwritten tapes. Refer to
    the appendix on how to do this recovery. 
    <p>
      ftt_clear_unrecovered [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_all_scsi [-usage]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor.
    </p>
    <p>
      ftt_locate &lt;blockno&gt; [-usage] [-status &lt;error&gt;]
    </p>
    <p>
      calls the corresponding ftt library routine using the global
      variable for the ftt file descriptor. It will locate the tape
      to the logical block number specified by <i>blockno.</i>
    </p>
    <h4>
      Miscellaneous Commands
    </h4>
    ftt_date [-usage] 
    <p>
      output current date to stderr.
    </p>
    <p>
      ftt_echo [string] [-usage]
    </p>
    <p>
      print <i>string</i> to stderr.
    </p>
    <p>
      ftt_debug [level] [-test] [-usage]
    </p>
    <p>
      Set/show the current debug level for the ftt library as well
      as the test routines. The debug level of the library will be
      set to <i>level</i>. If <i>-test</i> is specified, it will
      set the debug level for just the test routines. If level is
      not specified, the current debug level for both the library
      and the test routines are displayed.
    </p>
    <p>
      Debug levels for the ftt library are:
    </p>
    <p>
      * 0 = no debug prints
    </p>
    <p>
      * 1 = print "Entering routine..." in each routine
    </p>
    <p>
      * 2 = miscellaneous arguments "got this far" prints
    </p>
    <p>
      * 3 = debug prints on each pass through loops, etc. More
      debug prints than you can shake a stick at.
    </p>
    <p>
      Debug levels for the test routines are:
    </p>
    <p>
      * 1 = display commands entered by user.
    </p>
    <h3>
      ftt_test Examples
    </h3>
    <h4>
      Interactive Example:
    </h4>
    This example will rewind a tape specified on the open command
    itself: 
<pre>
$FTT_DIR/bin/ftt_test
ftt_test&gt; ftt_open /dev/rmt/tps2d4
ftt_test&gt; ftt_rewind
ftt_test&gt; ftt_close
</pre>
    <h4>
      Shell Script Example:
    </h4>
    This is an example ksh script that will rewind a tape. The
    device name can be specified as the first argument to the
    script, or from the environment variable FTT_TAPE. 
<pre>
#!/bin/ksh
#==========================
# This will rewind the tape
# =========================
# Get the tape device by looking in $1.&nbsp;
# If that's not set, try FTT_TAPE.&nbsp;
# If that's not set either, then exit.
export FTT_TAPE
FTT_TAPE=${1:-${FTT_TAPE:-""}}
FTT_TAPE=${FTT_TAPE:?"No device specified"}
#==========================================&nbsp;
$FTT_DIR/bin/ftt_test &lt;&lt; EOD
ftt_open
ftt_rewind
ftt_close
EOD
</pre>
    <h4>
      Redirection Example:
    </h4>
    This example will rewind a tape drive based on an ftt_test
    script. This device is specified as a switch to the ftt_test
    command itself. 
<pre>
cat my.ftt
&nbsp;&nbsp;&nbsp; ftt_open
&nbsp;&nbsp;&nbsp; ftt_rewind
&nbsp;&nbsp;&nbsp; ftt_close
$FTT_DIR/bin/ftt_test -f /dev/rmt/tps2d4 &lt;my.ftt
</pre>
    <h3>
      ftt_test scripts
    </h3>
    A series of test scripts are also provided to verify the ftt
    library as well as verify the behavior of a particular drive.
    Since the ftt_test program is very simple in nature (e.g., no
    flow control support, no variable support), the test scripts
    themselves will be ksh scripts. There are both small building
    block tests that will verify a particular aspect of the library
    as well as all inclusive tests that verify the entire package. 
    <p>
      All tests can either rely on the device name being specified
      in the environment variable FTT_TAPE or passed in as argument
      0 on the command line.
    </p>
    <h4>
      Building block scripts
    </h4>
    Following scripts are set of the <b>ftt_test</b> commands that
    can be used as a redirect input. 
    <p>
      Name and location:&nbsp;<a name="fnB0" href="#fn0"></a><a
      name="fnB0" href="#fn0"></a><a href="#fn0" name=
      "fnB0">[1]</a>
    </p>
    <p>
      $FTT_DIR/ftt_test/scripts/<tt><u>&lt;script
      name&gt;</u>.dat<a name="fnB1" href="#fn1"></a><a name="fnB1"
      href="#fn1"></a></tt><a href="#fn1" name="fnB1">[2]</a>
    </p>
    <p>
      Usage:
    </p>
    <p>
      ftt_test -f <tt><u>&lt;drive_name&gt;</u> &lt;
      $FTT_DIR/ftt_test/script/<u>&lt;script_name&gt;</u>.dat</tt>
    </p>
    <p>
      or:
    </p>
    <p>
      ftt_run_test <tt><u>&lt;script_name&gt;</u> <u>
      &lt;drive_name&gt;</u></tt>
    </p>
    <p>
      2fm
    </p>
    <p>
      This test will test to make sure that two and only filemarks
      are written at the end of tape with the ftt_write2fm call. If
      two individual calls to ftt_writefm are called, four
      filemarks are actually written.
    </p>
    <p>
      align
    </p>
    <p>
      This test will write a bunch of records, rewind, and then
      verify. It will do this for block sizes that are of longword
      multiples, word multiples, and byte multiples.
    </p>
    <p>
      async
    </p>
    <p>
      This script will verify the asynchronous capability in ftt.
      It assumes that a test tape is inserted that has been written
      with the "write" test. It will then skip to the double file
      mark and then display a time stamp around an asynchronously
      issued rewind.
    </p>
    <p>
      This output will need to be also checked manually to verify
      that the change in time is small. It will then check
      ftt_wait. An asynchronous command will also be issued that is
      expected to fail in order to verify that ftt_wait will return
      a failure.
    </p>
    <p>
      close
    </p>
    <p>
      This test will verify that a close command will leave the
      tape in a known position so that when it's opened again, the
      user knows where he is.
    </p>
    <p>
      delay
    </p>
    <p>
      This script will test write a bunch of blocks and reading a
      bunch of blocks with a random delay between i/o operations.
      This tends to uncover strange behavior with devices and
      device drivers. It is a lengthy test and may take a few hours
      to run.
    </p>
    <p>
      describe<a name="fnB2" href="#fn2"></a><a name="fnB2" href= 
      "#fn2"></a><a href="#fn2" name="fnB2">[3]</a>
    </p>
    <p>
      Prints all device files corresponding to the one tape drive.
    </p>
    <p>
      erase
    </p>
    <p>
      This script will write a volume label, erase the tape, and
      then verify that the volume label is blank.
    </p>
    <p>
      full
    </p>
    <p>
      This script will write to end of tape to verify appropriate
      errors reporting. It will take FOREVER to run.
    </p>
    <p>
      label
    </p>
    <p>
      This script will write all of the various label types and
      verify them.
    </p>
    <p>
      mode
    </p>
    <p>
      This script will test the various ftt_mode routines. It will
      be a nested loop which for all densities, all compressions,
      and all block sizes (variable and two different fixed block
      sizes) will check if the mode is available. If so, it will
      rewind the device, set the mode, write some data, verify the
      mode, rewind, and finally verify the data.
    </p>
    <p>
      notape
    </p>
    <p>
      This script will unload the tape and then verify that the
      correct error is returned when trying to access the drive.
    </p>
    <p>
      position
    </p>
    <p>
      This script will verify all the positioning commands using
      the a tape written by write.ftt. It will verify spacing both
      records and filemarks both forwards and backwards. It will
      verify that the correct error code is returned if the
      operation can't be performed. It will check that ftt_status
      returns the correct positioning information and that
      ftt_skip_to_double_fm works.
    </p>
    <p>
      rate [-n nblocks] [-s blocksize] [device]<a name="fnB3" href= 
      "#fn3"></a><a name="fnB3" href="#fn3"></a><a href="#fn3"
      name="fnB3">[4]</a>
    </p>
    <p>
      This script will rewind the device, and then write the
      specified number of blocks with the specified block size. It
      will time the time for the data transfer and write this
      information to stdout. The default block size is 32768 and
      the default number of blocks to write is 1000.
    </p>
    <p>
      read_only
    </p>
    <p>
      This test verifies that all ftt_write functions will return
      an error if the drive is opened as read only. It should also
      verify that ftt_status determines that it's a read only
      drive.
    </p>
    <p>
      root
    </p>
    <p>
      This script needs to run as root to work successfully. It
      does all of the operations that require root privileges.
      Currently this is on ftt_chall.
    </p>
    <p>
      stats
    </p>
    <p>
      This script will verify the statistics information. The
      output of the script will need to be checked manually. It
      will do a few writes and display the delta stats and then do
      a few reads and display the delta stats.
    </p>
    <p>
      verify
    </p>
    <p>
      This script verifies a tape written with write.ftt. It
      verifies that the volume label, the number of blocks, the
      contents of the blocks themselves, the number of file marks,
      and that the tape is blank at the end. It also verifies that
      FTT_ERANGE is returned if the number of bytes to read is less
      than the number of bytes in the record.
    </p>
    <p>
      twrite
    </p>
    <p>
      This script writes a test tape beginning with an ANSI label.
      It will write a few files with a few thousand blocks. The
      tape written by the script can be used by other scripts for
      additional testing. This test should leave the tape with only
      two filemarks at the end.
    </p>
    <p>
      random
    </p>
    <p>
      This is a special script that is actually generated by a c
      program. The c program will generate this ftt script to write
      a random number of files of random block size. It then
      randomly picks a position, skips to it, and verifies a random
      number of blocks.
    </p>
    <h4>
      All inclusive tests
    </h4>
    A few test scripts are provided as a convenience that call the
    fundamental building scripts mentioned in the previous section.
    There are 
    <p>
      ftt_fast [-a] [-u] [device]
    </p>
    <p>
      This script tests all of the reasonable quick tests to verify
      that the ftt library is behaving the way that it should. It
      may take on the order of an hour or two to complete. If -a is
      specified, the alignment tests are performed as well. Note
      that this may cause SCSI resets. If the -u switch is
      specified, the unload tests are performed at the end. Note
      that the tape will have to be reloaded before any other tests
      can be run.
    </p>
    <p>
      ftt_slow [-a] [-u] [device]
    </p>
    <p>
      This tests is all inclusive test suite for the ftt routines.
      It will call ftt_fast to perform all of the reasonable quick
      tests. In addition, it will test of the slow routines (e.g.,
      erase, write to end of tape). It may take several hours to
      run.
    </p>
    <p>
      ftt_exercise [device]
    </p>
    <p>
      This test is provided as a convenience for the user who wants
      to exercise the device to make sure that it is ok. For
      example, if a drive is replaced, the user would want to
      verify it with this script.
    </p>
    <p>
      ftt_ansi_prelabel [device] [label]
    </p>
    <p>
      This script writes ansi label and rewinds tape.
    </p>
    <p>
      ftt_dump [drive]
    </p>
    <p>
      This will dump a tape - used in recovering overwritten data
      tapes (see See "ftt_dump/undump" on page 49.).
    </p>
    <p>
      Usage:
    </p>
    <p>
      ftt_dump <tt><u>&lt;input drive name&gt;</u> | ftt_test -f
      <u>&lt;output drive name&gt;</u></tt>
    </p>
    <p>
      ftt_run_test [script] [drive]
    </p>
    <p>
      This script is used to execute <b>ftt_test</b> with data file
      located in <tt>$FTT_DIR/ftt_test/scripts</tt> directory.
    </p>
    <p>
      Usage:
    </p>
    <p>
      ftt_run_test [script] [drive]
    </p>
    <p>
      is evaluated to:
    </p>
    <p>
      ftt_test -f [drive] &lt;
      $FTT_DIR/ftt_test/scripts/[script].dat<a name="fnB4" href= 
      "#fn4"></a><a name="fnB4" href="#fn4"></a><a href="#fn4"
      name="fnB4">[5]</a>
    </p>
    <p>
      ftt_multitest [-s -p] [script] [drive_1] [drive_2]....
    </p>
    <p>
      Runs the requested script to run sequentially (<b>-s</b>) or
      parallel (<b>-p</b>) on listed drives.
    </p>
    <p>
      15<br>
      <!--NewPage-->
    </p>
    <h2>
      ftt_suid
    </h2>
    <h3>
      Command invocation
    </h3>
    The <b>ftt_suid</b> program which comes with the <b>ftt</b>
    distribution is a program which runs to allow various functions
    which must be run as root on various platforms to occur. It us
    generally invoked by the library, but can be invoked from the
    command line with the following options: 
    <ul>
      <li>
        ftt_suid <i>opts</i> -c <i>basename</i> -- clear error
        statistics on the drive
      </li>
      <li>
        ftt_suid <i>opts</i> -s <i>basename</i> --print statistics
        for the drive
      </li>
      <li>
        ftt_suid <i>opts</i> -b <i>n basename</i> -- set blocksize
        to <b>n</b> for the drive
      </li>
      <li>
        ftt_suid <i>opts</i> -C <i>n basename</i> -- set
        compression on (<b>n</b> == 1) or off (<b>n</b> == 0)
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-d</b> <i>n basename</i> -- set
        density to <b>n</b>.
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-p</b> <i>basename</i> -- get/dump
        partition table.
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-u</b> <i>basename</i> -- undump/write 
        partition table.
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-l</b> <i>blk basename</i> -- locate
        tape to <b>blk</b>.
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-L</b> <i>blk prt basename</i> -- locate
        to <b>blk</b> in partition <b>prt</b>.
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-M</b> <i>prt basename</i> -- set
        mount partition to <b>prt</b>.
      </li>
      <li>
        ftt_suid <i>opts</i> <b>-A</b> <i>basename</i> -- format tape in AIT
        mode -- AIT drives only, after doing this you should be able to make 
	more than two partitions on a tape.
    </ul>
    Only one of the above forms may be used per command invocation.
    
    <p>
      In each of the above <i>opts</i> may be <b>-w</b> to open the
      drive for writing, (which really only makes a difference for
      getting statistics on 8200's) and/or <b>-x</b> which turns on
      <b>ftt</b> debugging. The command performs the minimum number
      of <b>ftt</b> calls to perform the task, as well as <b>
      ftt_open</b>, and <b>ftt_close</b>. These are all operations
      which require superuser privilege on one or more systems.
      Currently the only platform where <b>ftt_suid</b> does not
      need to be setuid root at all is on IRIX systems from Silicon
      Graphics.
    </p>
    <p>
      In all cases, after performing the requested operation, the
      values returned by <b>ftt_get_error()</b> are printed to file
      descriptor 0.
    </p>
    <p>
      Note that for the <b>ftt</b> suite to work properly on those
      systems which require <b>ftt_suid</b> to be setuid to root,
      the <b>ftt_suid</b> executable must be in your command search
      path when the library is run, and installed with the correct
      permissions.
    </p>
    <h3>
      Example of use
    </h3>
    To get the current statistics from drive <b>/dev/rmt0</b> the
    command: 
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_suid -s /dev/rmt0
</pre>
    would yield the output 
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_VENDOR_ID is EXABYTE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_PRODUCT_ID is EXB-8200
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_FIRMWARE is 2600
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_CLEANING_BIT is 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_SENSE_KEY is 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_TRANS_SENSE_KEY is NO_SENSE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - is -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok
</pre>
    showing the statistics, then the error code and error string.
    In this case, the error counters on the Exabyte 8200 would be
    interpreted as read errors, since <b>-w</b> was not specified.
    <br>
    <!--NewPage--> 
    <h2>
      Appendix A: System Configuration Issues
    </h2>
    ftt makes very few assumptions about system configuration,
    however they are listed below, by platform. ftt attempts to
    continue and operate as best it can even when these options are
    not met, however it may be unable to determine tape drive type,
    etc. if these conditions are not met. 
    <h3>
      AIX issues
    </h3>
    The major assumption for <b>AIX</b> systems is that the <b>
    ftt_suid</b> executable is installed setuid root. If this is
    not done, we will be unable to set density and/or compression,
    or get statistics. 
    <h3>
      IRIX issues
    </h3>
    The major assumption under <b>IRIX</b> is that the devices
    under <b>/dev/scsi</b> exist, those entries under <b>/
    dev/scsi</b> which correspond to tape drives are writable by
    tape drive users, and that the <i>ds</i> module is built into
    the kernel to allow SCSI pass-through. 
    <p>
      On <b>IRIX</b> we cannot currently distinguish between
      Exabyte 8500's and 8505's, or between DLT4000's and
      DLT2000's, since the <b>hinv</b> command lists them
      identically.
    </p>
    <p>
      For <b>IRIX</b> we also recommend the following system
      patches be installed:
    </p>
    <ul>
      <li>
        528 - scsi roll up patch for IRIX 5.3 It fixes no direct
        problems, but we think it's safer. Challenge and Onyx only.
      </li>
      <li>
        736 - AN ABOSOLUTE MUST. fixes erroneous request sense
        data. for wd9 3 machines only. It was formerly patch 308.
      </li>
      <li>
        742 - Added support for 8505XL on Challenge and Onyx
        machines
      </li>
      <li>
        763 - Patch to work around Exabyte bugs. This helps an odd
        case with 8200s that are starting to go belly up. If it
        failed during the "close" command when writing a filemark,
        the driver still tried to reposition the drive. There was
        goofy 8200 firmware that would get lost at this point, and
        in an attempt to recover, the driver would reset the bus.
      </li>
      <li>
        1283 - This fixes the ghost filemarks that we saw on dlt
        devices.
      </li>
    </ul>
    <h3>
      OSF1 / DEC UNIX issues
    </h3>
    The major assumption for <b>DEC UNIX (OSF1)</b> port is that
    the <b>ftt_suid</b> executable is installed setuid root,
    because the <b>scu</b> command is used to determine what tape
    drives are on the system. Even though it would work to tell <b>
    ftt</b> that it did <i>not</i> need to be setuid root to
    operate on <b>/dev/cam</b>, and to make <b>/dev/cam</b> world
    writable, this would raise nasty security issues, since this
    would also allow all users direct pass-through access to <i>
    all</i> SCSI devices on the system. 
    <p>
      Note that the software will work without the setuid binary as
      far as doing tape I/O, but the software will be unable to
      identify the drive type or do SCSI passthrough, so
      information about tape density names will be generic, and
      most statistics will be unavailable.
    </p>
    <h3>
      Solaris Issues
    </h3>
    There are a couple of assumptions hidden in the <b>Solaris</b>
    port, underlying the fact that we use <b>dmesg</b> to discover
    what tape drives are on the system.<sup>1</sup> 
    <ul>
      <li>
        The st driver is configured to force-load, so that tape
        drives are listed at boot. This consists of adding a line
        to the <b>/etc/system</b> file like:
      </li>
    </ul>
    forceload: /drv/st 
    <ul>
      <li>
        Tape devices /dev/rmt<i>n</i> in order correspond to the
        sequence tape devices are listed by <b>dmesg.</b>
      </li>
    </ul>
    1. It is hoped that in the future a better solution to this
    problem will be found 
    <h3>
      A.5 Windows NT
    </h3>
    This system is very different then any UNIX system with the way
    the tape device are handled. 
    <ul>
      <li>
        there is only one tape device like \\.\tape<b><i>n</i></b>
      </li>
      <li>
        the type of the tape is unknown
      </li>
      <li>
        there is no way to set density
      </li>
      <li>
        only a few drive statistics are provided
      </li>
    </ul>
    <h3>
      Linux
    </h3>
    <ul>
      <li>
        Linux currently (kernel version 2.0) has a maximum block
        size of 65536. This is because e kernel allocates tape
        buffers at boot time.
      </li>
      <li>
        Linux device names are allocated at boot time or added
        later with the "SCSI add-single-device" command (see
        chapter 4 of the "SCSI programming HOWTO"). The first drive
        discovered becomes /dev/st0; the second, /dev/st1; and etc.
        This means that device names are not permanently assigned
        to a tape drive. This scheme works if you only have one
        tape drive and ftt supports the /dev/st style names.
      </li>
      <li>
        Ftt also supports device names of the form
        /dev/rmt/tps[0-9]d[1-15][n] where 0-9 is the SCSI bus, 1-15
        is the SCSI id, and n specifies the no rewind device. The
        script <b>$FTT_DIR/etc/makescsidev.Linux</b> can make
        appropriate special files.
      </li>
    </ul>
    <h3>
      General Security issues
    </h3>
    On some platforms, it may not be possible to get the <b>
    ftt_suid</b> executable installed as with sufficient
    permissions. In those situations, you can: 
    <p>
      mv ftt_suid ftt_suid.real
    </p>
    <p>
      cp /bin/true ftt_suid
    </p>
    <p>
      in the <b>bin</b> directory of the ftt product, and you will
      not get errors about the setuid binary -- of course
      functionality will be missing, as described in the preceding
      sections.<br>
      <!--NewPage-->
    </p>
    <h2>
      Appendix B: Recovering Data from Overwritten 8mm Tapes
    </h2>
    <h3>
      Disclaimer
    </h3>
    This appendix is to document personal experience in recovering
    data from tapes that have been overwritten. It is not meant to
    guarantee that this capability will always be available both in
    software and hardware. 
    <h3>
      850x Recovery
    </h3>
    The actual problem was that a few valid data tapes were
    overwritten with an ANSI volume label at the beginning of the
    tape. The tapes in question were 8mm tapes written on an 850x
    drive in non-compressed, variable block mode. 
    <p>
      When data is written to an 850x drive, a special end of data
      mark (EOD) is written after the last data record. When the
      tapes were overwritten, they contained two EOD marks: one at
      the end of the original data, and one at the end of the
      volume label. We wanted to skip past this first EOD and into
      the original data. Exabyte drives do NOT allow you to skip
      past an EOD mark UNLESS the drive is configured to support a
      directory structure. This requires special firmware from
      Exabyte. Note that the 850x documentation implies that with
      directory structure support, you can only skip past one EOD
      mark. We never tried more than one.
    </p>
    <p>
      We loaded the special firmware into an 8505 drive and then
      loaded one of the overwritten tapes in this drive. We needed
      a few specialized commands in the ftt toolkit, so we added
      ftt_all_scsi<a name="fnB5" href="#fn5"></a><a name="fnB5"
      href="#fn5"></a><a href="#fn5" name="fnB5">[6]</a>,
      ftt_clear_unrecovered<a name="fnB6" href="#fn6"></a><a name= 
      "fnB6" href="#fn6"></a><a href="#fn6" name="fnB6">[7]</a>,
      and ftt_locate.
    </p>
    <p>
      Using the ftt_test program, we were able to use ftt_locate to
      position the tape to a specific logical block in the original
      data set: For example:
    </p>
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_open -readonly /dev/rmt/tps0d4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_rewind
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_locate 1000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command failed with FTT_EBLANK, expected FTT_SUCCESS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_locate 1200
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command failed with FTT_EIO, expected FTT_SUCCESS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_locate 1500
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_locate 1300
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_rewind
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test&gt; ftt_locate 1300
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test. ftt_close
</pre>
    <h3>
      Special Observations:
    </h3>
    <ul>
      <li>
        As a precautionary measure, be sure to write protect the
        tape!
      </li>
      <li>
        The actual logical block number is dependent on both the
        original block size and the amount of data that was
        overwritten. This is something that you find by trial and
        error.
      </li>
      <li>
        The logical block number is relative to the beginning of
        tape, ftt_locate 1200 followed by ftt_locate 1500 will
        position the tape to the 1500th block from the beginning of
        tape, not the 2700th.
      </li>
      <li>
        ftt_locate will fail with a mix of FTT_EIO and FTT_EBLANK
        errors until it can sync with the original data.
      </li>
      <li>
        Sometimes an ftt_locate command would appear to have
        worked, but the drive reset itself and rewound. This was
        particularly true when backspacing records. Be sure to keep
        an eye on the drive to see what's happening. You can always
        rewind and start again.
      </li>
      <li>
        As another precautionary measure, once you believe you have
        found the start of good data, rewind the tape and use a
        single ftt_locate to move there. We found that the drive
        would sometimes let you backspace with ftt_locate a little
        further than forward spacing.
      </li>
      <li>
        Sometimes, the ftt_locate command would report an FTT_EBUSY
        error. I never quite understood this, but if you wait a
        little while and try again, it worked. It's as if the raw
        scsi device driver was already in use.
      </li>
    </ul>
    Once the input tape has been position into the start of good
    data, the tape can be copied via your favorite copy process. We
    tried two ways, both of which worked: ftt_dump/undump and a
    simple c program. 
    <h4>
      ftt_dump/undump
    </h4>
    A ftt test program was written to dump the tape and this output
    was piped into the output tape: 
    <p>
      ftt_dump /<b>dev/rmt/tps0d4 | ftt_test /dev/rmt/tps0d5</b>
    </p>
    <h4>
      simple copy program
    </h4>
    ftt provides a VERY simple c program to do the copy. Note that
    it does nothing to select the mode of the output tape. It
    simply uses the default device, but it does rewind it first.
    The -i and -o switches define the input and output devices
    respectively. 
<pre>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_copy -i /dev/rmt/tps0d4 -o /dev/rmt/tps0d5
</pre>
    <h3>
      8200 Recovery
    </h3>
    Unlike newer Exabyte models, Exabyte 8200s do not write this
    EOD mark. We have recovered data from 8200s, but that was
    several years ago (1991?). One could skip to the first filemark
    in the original data set and copy from that point on. However,
    it was significantly more difficult to recover data from the
    first file. 
    <p>
      Jim Meadows (meadows@fnal.gov) and Margaret Votava
      (votava@fnal.gov) had a test stand setup for such recoveries.
      It consisted of an mvme133 in a VME crate running pSOS and a
      Ciprico Rimfire board as the VME-&gt;SCSI adaptor. A PC was
      connected to the terminal port of the drive with the
      overwritten data. Jim would be able to overwrite some memory
      location in the drive to convince the heads to spin forward
      to some arbitrary point. We then attempted to read. This was
      procedure was repeated until good data was found. The Fermi
      written rimfire routines were used to control the drives.
    </p>
    <h3>
      Other Exabyte Tapes
    </h3>
    According to Exabyte sales representatives, the techniques used
    to recover 850x tapes will be supported in newer models, e.g.
    the mammoth drives. This has not been tested at Fermi. 
    <h3>
      DLT 2000/4000
    </h3>
    At the time of this writing (March 1997), Quantum
    representatives claim that there is currently no way to recover
    overwritten data tapes. They are working on special firmware to
    support this, but it is not anticipated that this firmware will
    be available to the general public. <br>
    <!--NewPage--> 
    <p>
      <a name="fn0" href="#fnB0"></a><a name="fn0" href=
      "#fnB0"></a><a href="#fnB0" name="fn0">[1]</a> The name and
      usage was changed for version v2_0 to have the same behavior
      on UNIX and Windows NT
    </p>
    <p>
      <a name="fn1" href="#fnB1"></a><a name="fn1" href=
      "#fnB1"></a><a href="#fnB1" name="fn1">[2]</a> Scripts rate
      and describe are not ported to WIndows NT and they should
      executed directly or using ftt_run_test shell script
    </p>
    <p>
      <a name="fn2" href="#fnB2"></a><a name="fn2" href=
      "#fnB2"></a><a href="#fnB2" name="fn2">[3]</a> This shell
      script is not ported to Windows NT since the is only one tape
      drive device
    </p>
    <p>
      <a name="fn3" href="#fnB3"></a><a name="fn3" href=
      "#fnB3"></a><a href="#fnB3" name="fn3">[4]</a> This script
      wasn't ported to Windows NT
    </p>
    <p>
      <a name="fn4" href="#fnB4"></a><a name="fn4" href=
      "#fnB4"></a><a href="#fnB4" name="fn4">[5]</a> with the
      exemption of <b>describe</b> and <b>rate</b> scripts
    </p>
    <p>
      <a name="fn5" href="#fnB5"></a><a name="fn5" href=
      "#fnB5"></a><a href="#fnB5" name="fn5">[6]</a> Some device
      drivers (e.g., IRIX) won't even issue commands on the SCSI
      bus if it thinks they will fail. For example, if you read
      until end of tape, the driver remembers this and won't even
      issue future reads to the drive. We originally thought that
      we might need to read even though the device driver thought
      we shouldn't, so we added ftt_all_scsi. This will force all
      drive operations to use the raw SCSI device driver,
      guaranteeing that the command would actually be sent to the
      drive. As it turned out, we didn't need this feature.
    </p>
    <p>
      <a name="fn6" href="#fnB6"></a><a name="fn6" href=
      "#fnB6"></a><a href="#fnB6" name="fn6">[7]</a> If ftt is ever
      confused about tape position (e.g., a skip filemark command
      fails), then it sets an internal flag that prevents any
      future tape movement. We believed that while we were looking
      for good data in the recovery process, we might need this
      feature. It's not clear that it was really needed.
    </p>
  </body>
</html>

