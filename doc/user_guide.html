<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
   <META HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=iso-8859-1">
   <META NAME="GENERATOR" CONTENT="Mozilla/4.08 [en] (X11; I; Linux 2.0.35 i686) [Netscape]">
   <TITLE>      Fermi Tape Tools (ftt) Library User's Guide
    </TITLE>
</HEAD>
<BODY>

<CENTER>
<H1>
Fermi Tape Tools (ftt) Library User's Guide</H1></CENTER>

<CENTER>Chuck Debaun, <B>Marc W. Mengel</B>
<BR>Operating Systems Support Department
<P>Marilyn Schweitzer
<BR>High Performance and Parallel Computing Department
<P><B>Dorota Genser</B>, Gene Oleynik, <B>Margaret Votava</B>
<BR>Online Systems Department
<BR>Fermilab Computing Division</CENTER>

<CENTER>
<H2>
Abstract</H2></CENTER>

<BLOCKQUOTE>
<BLOCKQUOTE>The Fermi Tape Tools library is a C subroutine package that
provides consistent, platform-independant tapeI/O for a variety of tape
drives&nbsp; on a variety of platforms .&nbsp; It provides basic tape input
and output, support for obtaining and tracking available tape statistics,
and various informationnal and support routines for tools which need to
allocate and control tape usage.
<P>This users guide will provide an overview of teh ftt library calls,
take the reader through the process of writing a simple ftt based tape
copy program, and also provide a complete call reference of the routines
provided for tape input, output, and information</BLOCKQUOTE>
</BLOCKQUOTE>
<!--NewPage--><!--NewPage-->
<H2>
Getting Started</H2>

<H3>
Installation</H3>
The <B>ftt</B> product is distributed as a Fermilab <B>ups</B> product,
and should be installed as such, as root if possible. There is an <B>INSTALL</B>
file in the product giving details of non-<B>ups</B> installation. Important
notes on prerequisites for various platforms are in Chapter 14 of this
document.
<H3>
Basic Concepts</H3>
The <B>ftt</B> library is used by creating a <B>descriptor</B> for each
tape drive being used and making various <B>ftt</B> calls using that descriptor.
The <B>descriptor</B> itself contains information about what system <B>devices</B>
are associated with the tape drive, what densities and formats are available,
etc. To get a <B>descriptor</B> for a particular tape drive, you need to
know the <B>basename</B> of the drive, which is basically a common substring
of the various system devices associated with the tape drive. Another important
data structure is the <B>ftt_stat_buf</B> which is used to hold tape drive
statistics obtained from the tape drive. These types, as well as all of
the function prototypes, preprocessor definitions, etc. are found in the
<B>ftt.h</B> header file.
<H3>
Starting and Finishing</H3>
The <B>ftt</B> library can be used either to do tape input and output,
to manage tape drives, to get information about tape devices, or all of
the above. All of these activities start with a call to <B>ftt_open</B>
to get an <B>ftt</B> descriptor.
<PRE>#include &lt;ftt.h>
ftt_descriptor d;
d = ftt_open("/dev/rmt0", FTT_RDONLY);
/* do some stuff here */
ftt_close(d);</PRE>
There are several itemuser_guide_maintext1.mifs that should be mentioned
here.:
<UL>
<LI>
The header file ftt.h is included. This file contains the various preprocessor
symbols and function declarations for users of the <B>ftt</B> library.</LI>

<LI>
We declare the descriptor variable with a type named <B>ftt_descriptor</B>.</LI>

<LI>
We pass in a read-only/read-write flag to the open call.</LI>

<LI>
ftt_close frees up all the memory associated with the <B>descriptor</B>
and closes any open system devices associated with the drive.</LI>

<P><BR>If your program needs to deal with multiple tape drives, it can
call <B>ftt_open</B> multiple times, to get a unique <B>descriptor</B>
for each drive. It should then issue an <B>ftt_close</B> on each descriptor
it got from <B>ftt_open</B> before exiting
<H3>
Doing Input and Output</H3>
Once you have a <B>descriptor</B>, very often you want to read data from
the associated drive, or write data to it. The <B>ftt</B> library calls
to read and write data look very much like the UNIX system calls <B>read</B>
and <B>write</B> and are called (you guessed it) <B>ftt_read</B> and <B>ftt_write</B>.
Both take as arguments the <B>descriptor</B> for the tape drive involved,
a character pointer to the data buffer, and the number of bytes requested
to be read or written. Both return the number of bytes actually transferred,
or -1 to indicate an error. The calls look like:
<PRE>length = ftt_read(d, buffer, buffer_length);</PRE>
or;
<PRE>length = ftt_write(d, buffer, data_length);</PRE>
<!--NewPage-->
<H2>
Finding out what went wrong</H2>
If your <B>ftt</B> calls return an error (a value of -1 for <B>ftt_read</B>
or <B>ftt_write</B> or a value of 0 from <B>ftt_open</B> for example),
you may want to know specifically what went wrong. To find out the specific
error condition, you can use the routine called <B>ftt_get_error</B> which
gives you an error string and (optionally) an error number. If you simply
want to tell the user what went wrong, you can do something as simple as:
<PRE>fprintf(stderr, "%s\n", ftt_get_error(0));</PRE>
which will print the error string on standard error. If your program wants
to attempt to do something to recover from errors, you will need to pass
a pointer to an integer into the first argument of <B>ftt_get_error</B>
which will give you back an error number. Then you can attempt to take
appropriate action based on the error. This looks like:
<PRE>char *p;
int n;
...
p = ftt_get_error(&amp;n);
if (n == FTT_ENOTAPE) {
&nbsp;&nbsp;&nbsp; request_tape_mount();
}</PRE>
The error numbers you get from <B>ftt_get_error</B> will be one of the
following:
<CENTER>TABLE 1. ftt error codes</CENTER>

<TABLE BORDER >
<TR ALIGN=LEFT>
<TD ALIGN=LEFT>ftt_errno</TD>

<TD ALIGN=LEFT>Description</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_SUCCESS</TD>

<TD ALIGN=LEFT>no error has occurred</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EPARTIALSTAT</TD>

<TD ALIGN=LEFT>unable to obtain some or all of the information requested</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EUNRECOVERED</TD>

<TD ALIGN=LEFT>previous error was unrecoverable, tape can only be unloaded/rewound
(to protect data)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOTAPE</TD>

<TD ALIGN=LEFT>there is no tape in the drive</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOTSUPPORTED</TD>

<TD ALIGN=LEFT>Unsupported device</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EPERM</TD>

<TD ALIGN=LEFT>you do not have permission to perform the specified operation
on the device.</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EFAULT</TD>

<TD ALIGN=LEFT>you gave a buffer address range whose access yields a memory
fault</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOSPC</TD>

<TD ALIGN=LEFT>A write attempted to cross end of media</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOENT</TD>

<TD ALIGN=LEFT>User attempted to set density to a nonexistent one</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EIO</TD>

<TD ALIGN=LEFT>Physical read or write error.0</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EBLKSIZE</TD>

<TD ALIGN=LEFT>Attempt to write/read unsupported block size s</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOEXEC</TD>

<TD ALIGN=LEFT>Attempt to run setuid executable for security bypass failed
-- not executable</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EBLANK</TD>

<TD ALIGN=LEFT>Encountered blank tape (i.e. passed logical EOT)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EBUSY</TD>

<TD ALIGN=LEFT>Asynchronous I/O is going on this device, or another process
has it open</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENODEV</TD>

<TD ALIGN=LEFT>System does not have drive configured</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENXIO</TD>

<TD ALIGN=LEFT>Tried to contact a nonexistent process</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENFILE</TD>

<TD ALIGN=LEFT>No system file descriptors available</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EROFS</TD>

<TD ALIGN=LEFT>Tape is write protected</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EPIPE</TD>

<TD ALIGN=LEFT>Setuid bypass died</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ERANGE</TD>

<TD ALIGN=LEFT>Record too large for buffer</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOMEM</TD>

<TD ALIGN=LEFT>Unable to allocate memory required to perform call</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOTTAPE</TD>

<TD ALIGN=LEFT>What we thought was a tape device was not.</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_2SMALL</TD>

<TD ALIGN=LEFT>The block size issued is smaller then the device can handle</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ERWFS</TD>

<TD ALIGN=LEFT>Tape is not write protected (and should be)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EWRONGVOL</TD>

<TD ALIGN=LEFT>Wrong volume label on tape for verification</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EWRONGVOLTYP</TD>

<TD ALIGN=LEFT>Wrong type of label on tape for verification</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ELEADER</TD>

<TD ALIGN=LEFT>hit tape leader while skipping backwards</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EFILEMARK</TD>

<TD ALIGN=LEFT>hit file mark while skipping records</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ELOST</TD>

<TD ALIGN=LEFT>The tape postion is unknown</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ENOTBOT</TD>

<TD ALIGN=LEFT>The tape is not at BOT</TD>
</TR>
</TABLE>

<P>Your code can compare the error number (<B>n</B> in our example) to
the values in this table to decide what went wrong in the preceding <B>ftt</B>
library call.
<BR><!--NewPage-->
<H2>
Opening/closing Device</H2>
In general, to access a device, the user need simply call <B>ftt_open()</B>.
He can then perform normal tape operations (e.g., read, write, rewind).
<B>ftt_open()</B> doesn't actually open this device with the unix device
driver. It simply creates/initializes the <B>ftt</B> file descriptor. Once
the descriptor is created, the user can explicitly open a thread to the
device driver with <B>ftt_open_dev()</B>, although this is not necessary.
All <B>ftt</B> routines will internally call <B>ftt_open_dev()</B> if the
device has not yet been opened.
<P>A utility routine, <B>ftt_open_logical()</B>, is provided to create
an <B>ftt</B> descriptor for a possibly fictitious device. It provides
the opportunity to see what the various device names would be for specific
modes/densities on a different operating system platform. The average user
would not use this routine to open the device, but would use <B>ftt_open()</B>
instead.
<P>The pair of close routines, <B>ftt_close()</B> and f<B>tt_close_dev()</B>,
are similar in function to the pair of open routines, f<B>tt_open()</B>
and <B>ftt_open_dev()</B>. In general, the user need simply call <B>ftt_close()</B>
when finished with the device. This routine will internally call <B>ftt_close_dev()</B>
if needed. <B>ftt_close_dev()</B> will ensure that the proper number of
filemarks have been written at the end of tape (if writing) and that the
tape is correctly positioned. <B>ftt_close()</B> will free the <B>ftt</B>
file descriptor.
<P>It's important to note that some <B>ftt</B> routines will internally
call <B>ftt_close_dev()</B>, which may write filemarks, if they need to
close the normal unix device driver and open the raw scsi device. The documentation
for the individual subroutines will indicate if a specific routine exhibits
this behavior.
<P>Note that several f<B>tt_open_dev()</B> and f<B>tt_close_dev()</B> pairs
can be called within a single <B>ftt_open()</B> and <B>ftt_close()</B>
pair.
<H3>
ftt_descriptor <B>ftt_open</B>(char <B>*basename, int</B> rdonly)</H3>
opens a <I>basename</I> for a device and returns a <I>descriptor,</I> which
can be used to perform other operations on the device. The <I>basename</I>
argument can also be a full device name for a tape device, and will internally
be trimmed to a basename.
<P>The <I>rdonly</I> argument indicates
<CENTER>
<P>TABLE 2. rdonly flag values</CENTER>

<TABLE BORDER >
<TR ALIGN=LEFT>
<TD ALIGN=LEFT>Value</TD>

<TD ALIGN=LEFT>Description</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_RDONLY</TD>

<TD ALIGN=LEFT>Device will not be written on</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_RDWR</TD>

<TD ALIGN=LEFT>Device is read and writable.</TD>
</TR>
</TABLE>

<P>Note that FTT_RDONLY does not check that the device is physically write
protected, nor does FTT_RDWR check that is not physically write protected;
a call to <B>ftt_status</B> is required to obtain that information.
<P>This routine performs no positioning of the device.
<P>Note that <B>ftt_open</B> and <B>ftt_close</B> do not need to be called
to switch between reading and writing, to cross filemarks, etc. The ftt
software will perform operating system opens and closes as needed to allow
those transitions.
<P>ftt_open does not perform any operations on the tape drive or tape devices,
it simply does bookkeeping to prepare for such operations.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
d = ftt_open("/dev/rmt/tps2d4", FTT_RDWR);</PRE>

<H3>
ftt_descriptor <B>ftt_open_logical</B> (char *<B>basename,</B> char *<B>os,</B>
char *<B>driveid,</B> int <B>rdonly)</B></H3>
Create a (possibly mythical) ftt_descriptor for a device of type <I>driveid</I>
on operating system <I>os</I>, using base device name <I>basename</I>,
with <I>rdonly</I> as in <B>ftt_open</B>. This call will be used internally
to construct a descriptor, but can also be used in combination with other
<B>ftt</B> calls to see what the name of the high density EXB-8500 tape
device would be on IRIX from an IBM system. Performing any actual tape-io
from this descriptor will probably fail unless the <I>os</I> and <I>driveid</I>
and <I>basename</I> are valid for the current system.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
d = ftt_open_logical("/dev/rmt/tps2d4", "IRIX", "EXB-8500", FTT_RDWR);</PRE>

<H3>
int <B>ftt_open_dev (</B>ftt_descriptor <B>d)</B></H3>
Explicitly perform a UNIX open of the device for the currently selected
density, etc. Routines which need the device open to work will call <B>ftt_open_dev</B>
if they need to.
<P>If the density and mode have not been set by <B>ftt_set_mode(), ftt_set_mode_dev(),</B>
etc., the default density and compression mode of the highest density the
device supports and no compression will be used.
<P>The routine may sets appropriate modes and/or flags on the underlying
device to allow other ftt operations to proceed properly.
<P>ftt_open_dev performs antecessor operations to set the device density,
etc. and actually performs an operating system open on the device. No tape
motion is performed.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_open_dev(d);</PRE>

<H3>
int <B>ftt_close (</B>ftt_descriptor <B>d)</B></H3>
The <B>ftt_close</B> entry releases a descriptor, indicating that no further
operations will be performed on that descriptor. If a device has been opened
not closed, an <B>ftt_close_dev</B> will be performed.
<P>ftt_close will invoke <B>ftt_close_dev</B> if needed, but performs no
other tape or device operations.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_close(d);</PRE>

<H3>
int <B>ftt_close_dev(</B>ftt_descriptor <B>d)</B></H3>
This call closes the system device which was opened by <B>ftt_open_dev</B>,
after ensuring proper double file mark termination of written data. To
ensure this, if writes have been successfully performed since the last
rewind or other tape motion, it writes two filemarks and backspaces over
them before closing the device. Note that this means that if you are writing,
perform an <B>ftt_close_dev</B> followed by an <B>ftt_open_dev</B>, and
continue writing, you will overwrite the filemarks that <B>ftt_close_dev</B>
wrote.
<P>Note that <B>ftt_close_dev</B> can fail, due to insufficient room to
write tape filemarks, etc.
<P>ftt_close_dev performs a close on the operating system device. It will
only perform tape motion (writing filemarks and backspacing) if the preceding
operation was a write or write filemark. No other operations or tape motions
are performed.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_close_dev(d);</PRE>
4
<P>Reading/Writing
<P>All of these routines return -1 on failure, for which more information
can be obtained as described in the section on <I>Finding out what went
wrong.</I>
<P>4.1 int <B>ftt_read (</B>ftt_descriptor <B>d, char *</B>buf, int length)
<P>If called with the tape positioned before a data block, the <B>ftt_read</B>
entry reads a block of length at most <I>length</I> from the tape into
buffer <I>buf</I>, and returns the length of the block actually read. If
the next block on the tape will not fit into the buffer, or if any other
error occurs, -1 will be returned
<P>If called with the tape positioned before an end-of-file mark, 0 is
returned, and the position is moved to just after the end-of-file mark.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
char data[32768]
int status;
status = ftt_read(d,data,32768);</PRE>

<H3>
int <B>ftt_write (</B>ftt_descriptor <B>d, char *buf, int</B> length)</H3>
The ftt_write entry transfers as much as possible of the block in buffer
<I>buf</I> of <I>length</I> to the tape, and returns the length written,
unless an error occurs, in which case -1 is returned. The tape is positioned
after the written block.
<P>In the case of an unrecoverable error, an error number of FTT_UNRECOVERED
will be returned for this call, and all subsequent calls made until one
of <B>ftt_rewind, ftt_unload,</B> <B>ftt_close_dev,</B> or <B>ftt_close</B>
is called.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
char data[32768]
int status;
status = ftt_write(d,data,32768);</PRE>
4.3 int <B>ftt_writefm (</B>ftt_descriptor <B>d)</B>
<P>The ftt_writefm entry writes a single filemark to the tape. After the
call, the tape position is after the written filemark.
<P>Example:
<PRE>#include "ftt.h"
ftt_descriptor d;
int status;
status = ftt_writefm(d);</PRE>

<H3>
int <B>ftt_write2fm</B> (ftt_descriptor <B>d)</B></H3>
The ftt_write2fm call writes 2 filemarks to the tape. After the call, the
tape position is after the second filemark so written. After making this
call, <B>ftt</B> "forgets" that it has been writing, since the guarantee
that there is a double file mark at the end of tape has been established.
<P>4.5 ftt_retry (ftt_descriptor <B>d</B>, int <B>tries,</B> (*<B>op</B>)
(ftt_descriptor, char *, int), char *<B>buf</B>, int <B>len</B>);
<P>The <B>ftt_retry</B> call calls the routine passed in as <B>op</B>,
with arguments <B>d, buf,</B> and <B>len</B>, and if the call fails, retries
it up to <B>tries</B> more times. Before retrying, <B>ftt_retry</B> will
skip backwards to the nearest filemark, then skip forward to just after
the last successfully written block, and retry the operation. The recovery
sequence is correspondingly sluggish on some tape drives.
<P>The <B>op</B> passed in should be either <B>ftt_read</B> or <B>ftt_write</B>.
<P>Note that if retrying <B>ftt_write</B> calls, the reverse skip will
attempt to write 2 filemarks, making the recovery even slower.
<P>This call will fail if:
<P>* any of the file or record skips fail
<P>* the number of retires is exceeded without a successful write
<P>The return code will be the result of the last operation, either <B>ftt_skip_fm,
ftt_skip_rec,</B> or the return code from the passed in <B>op</B>.
<P>Example:
<P>char buf[2048]
<P>res = ftt_retry(d, 5, ftt_read, buf, 2048);
<P>will make up to a total of 6 read calls, interspersed with file and
record skips.
<P>5
<BR><!--NewPage-->
<H2>
Moving around on the tape</H2>
Tape drives allow you to do more then just read and write, they also allow
you to move around the tape, and perform other operations. The <B>ftt</B>
library contains several calls for tape motion.
<P>All of these routines return -1 on failure, for which more information
can be obtained as described in the section on <I>Finding out what went
wrong.</I>
<H3>
int ftt_skip_fm (ftt_descriptor d, int count)</H3>
skips forwards to just after a filemark, or backwards to just before a
filemark. <I>count</I> indicates the number of filemarks to skip. <I>count</I>
should be negative to skip backwards.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_skip_fm(d, 3);</PRE>
to skip forward 3 filemarks, or:
<PRE>status = ftt_skip_fm(d, -2);</PRE>
to skip backwards 2 filemarks.
<P>Note that skipping backwards will write two filemarks and skip back
over them first if the preceding operation was an <B>ftt_write</B> or <B>ftt_writefm</B>
call.
<P>5.2 int ftt_skip_rec (ftt_descriptor d, int count)
<P>skips forward just past records, or backwards just before records. <I>count</I>
indicates the number of records to skip. <I>count</I> should be negative
to skip backwards.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_skip_rec(d, 3);</PRE>
to skip forward 3 records, or:
<PRE>status = ftt_skip_rec(d, -2);</PRE>
to skip backwards 2 records.
<P>Note that skipping backwards will write two filemarks and skip back
over them first if the preceding operation was an <B>ftt_write</B> or <B>ftt_writefm</B>
call.
<H3>
int ftt_skip_to_double_fm (ftt_descriptor d)</H3>
skips forward until it finds two filemarks in a row, and positions the
tape between the two filemarks. This is often useful for appending to unlabeled
tapes.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_skip_to_double_fm(d);</PRE>

<H3>
int ftt_rewind (ftt_descriptor d)</H3>
skips backwards to the beginning of tape.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
ftt_rewind(d);</PRE>

<H3>
int <B>ftt_retension (</B>ftt_descriptor <B>d)</B></H3>
retensions and rewinds tape.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
ftt_rewind(d);</PRE>
5.6 int ftt_unload (ftt_descriptor d)
<P>ejects the tape from the tape drive (if possible).
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
ftt_unload(d);</PRE>

<H3>
int ftt_erase (ftt_descriptor d)</H3>
erases and rewinds the tape in the tape drive (if possible).
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
ftt_erase(d);</PRE>
<!--NewPage-->
<H2>
Densities, Compression, and other Modes</H2>
The various tape drives generally read and write at a particular <B>density</B>
(which refers to the amount of data per length or area of tape), and often
have some densities they can read and write, some they can only read, etc.
In addition drives can use <B>compression</B> to write less data on the
tape. Also, many operating systems provide devices with various software-generated
modes, such as having the drive rewound when the system device is closed,
or retensioned when it is opened. The <B>ftt</B> library provides several
calls for dealing with these various sorts of mode settings.
<P>All of these routines normally return a character pointer to a string
containing the name of whatever system device will be used to perform I/O
in this mode. The routines all return 0 if anything goes wrong, see the
section <I>Finding out what went wrong</I> for a discussion of errors.
<H3>
char *ftt_set_mode (ftt_descriptor <B>d,</B> int <B>density,</B> int<B>cmp,</B>
int <B>blocksize)</B></H3>
lets you pick a specific density number in <I>density</I>, turn compression
on or off in <I>cmp</I>, and set variable blocking, or a given fixed blocksize
in <I>blocksize</I>. This mainly has effect for writing tapes, since most
drives will automatically switch densities when reading to match the density
at which the tape was written. <I>blocksize</I> is specified in bytes,
with a <I>blocksize</I> of zero indicating variable block mode. The routine
returns the name of the system device it will use for operations at that
density, etc.
<P>Example:
<PRE>#include "ftt.h"
char *name;
ftt_descriptor d;
int density;
int cmp = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* compression on */
int blocksize = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variable block */
name = ftt_set_mode(d, density, cmp, blocksize);</PRE>

<H3>
char *ftt_get_mode (ftt_descriptor <B>d,</B> int *<B>density,</B> int<B>*cmp,</B>
int <B>*blocksize)</B></H3>
tells you what density in <I>density</I>, compression in <I>cmp</I>, and
blocksize in blocksize were last set by <B>ftt_get_mode</B>. This is mainly
useful to find out what defaults were set, which should be the highest
density, uncompressed format for the drive you are using. You pass in pointers
to the integers you want back, so that the routine can return multiple
values.
<P>Example:
<PRE>#include "ftt.h"
char *name;
ftt_descriptor d;
int density;
int cmp;
int blocksize;
name = ftt_get_mode(d, &amp;density, &amp;cmp, &amp;blocksize);</PRE>

<H3>
char *ftt_avail_mode (ftt_descriptor <B>d,</B> int <B>density,</B> int<B>cmp,</B>
int <B>fixed)</B></H3>
tells you whether a call to <B>ftt_set_mode</B> with a given set of arguments
should succeed, although it only checks whether the last argument is zero
or nonzero, to indicate fixed blocksize or variable, respectively. It similarly
returns the system device name that would be used when doing input/output
at that density, etc.
<P>Example:
<PRE>#include "ftt.h"
char *name;
ftt_descriptor d;
int density;
int cmp = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* compression on */
int fixed = FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* variable block */
name = ftt_avail_mode(d, density, cmp, fixed);</PRE>

<H3>
char <B>*ftt_density_to_name (</B>ftt_descriptor <B>d,</B> int <B>density)</B></H3>
Translates an integer density number to a descriptive string or name.
<H3>
int <B>ftt_name_to_density (</B>ftt_descriptor <B>d,</B> char *<B>name)</B></H3>
Translates a name to an integer density number. The name can be any prefix
of a density string which would be returned by <B>ftt_density_to_name()</B>
for that device.
<H3>
int <B>ftt_get_max_blocksize (</B>ftt_descriptor <B>d)</B></H3>
Returns the largest blocksize usable on this drive type and platform, suitable
for getting a block size to allocate for a read/write or copy buffer.
<H3>
int <B>ftt_set_data_direction(</B>ftt_descriptor <B>d</B>, int <B>n)</B></H3>
This sets the "data direction" flag, which is used on drives like Exabyte
8200's that do not provide real read and write counters, to decide whether
i/o estimates based on remaining tape counters should be treated as read
or write counts. Making this call is important if collecting tape statistics
for tape I/O done by another process.
<BR><!--NewPage-->
<H2>
Dealing with System Device Names</H2>
The various operating systems have multiple device names which are associated
with the same tape drive. For example, the IRIX operating system currently
has 38 device nodes for a single 8500 tape drive.
<H3>
char **<B>ftt_list_all (</B>ftt_descriptor <B>d)</B></H3>
returns a pointer to a static list of device pathnames related to this
drive.
<P>ftt_list_all performs no tape operations. It returns the list of devices
we think should be present, which is determined when <B>ftt_open_logical</B>
is called.
<P>Example:
<PRE>#include "ftt.h"
char **all_names;
ftt_descriptor d;
all_names = ftt_list_all(d);</PRE>

<H3>
int <B>ftt_chall (</B>ftt_descriptor <B>d,</B> int <B>uid,</B> int <B>gid,</B>
int <B>mode)</B></H3>
All character special devices relating to the file named by descriptor
have their ownership changed to the pass-ed in uid, gid. and are set to
the given mode. This call will only succeed if called with the appropriate
permissions, it will not be handled by a setuid executable.
<P>ftt_chall performs no tape operations, it merely changes permissions
on the devices in <B>/dev</B>.
<H3>
int ftt_get_mode_dev(ftt_descriptor <B>d,</B> char *<B>devname,</B> int
*<B>density,</B> int <B>*cmp,</B> int *<B>fixed,</B> int *<B>rewind)</B></H3>
Returns the density in <I>density</I>, compression in <I>cmp</I>, fixed
block flag, <I>fixed</I>, and rewind/retension status in <I>rewind</I>
for the device <I>devname</I>.
<P>The <I>rewind</I> value returned will have a value of <B>FTT_RWOC, FTT_RTOO</B>,
or bitwise combinations of these values, to indicate ReWind On Close and
ReTension On Open, respectively.
<P>A <I>fixed</I> value of 0 indicates variable blocking, a <I>fixed</I>
of 1 indicates fixed block operation, <B>but does not provide the current
blocksize.</B>
<P>ftt_get_mode_dev performs no tape operations.
<P>Example:
<PRE>&nbsp;#include "ftt.h"
int status;
ftt_descriptor d;
char *devname = "/dev/my_favorite_device";
int density;
int cmp;
int fixed;
int rewind
status = ftt_get_mode_dev(d, devname, &amp;density, &amp;cmp, &amp;fixed, &amp;rewind);</PRE>

<H3>
int ftt_set_mode_dev (ftt_descriptor <B>d,</B> char * <B>devname,</B> int
<B>force)</B></H3>
Sets the compression, density, etc. to match that of the device name passed
in. The argument must be a name associated with the device opened by <B>ftt_open</B>.
<P>The <I>force</I> flag (if set to one) forces the exact device name specified
to be used, allowing access to devices which are otherwise unsupported.
<P>ftt_set_mode_dev performs no tape operations, it merely sets flags,
etc. which will be used by <B>ftt_open_dev.</B>
<P>Example:
<PRE>&nbsp;#include "ftt.h"
int status;
ftt_descriptor d;
char *devname = "/dev/my_favorite_device";
int force = FALSE;
status = ftt_set_mode_dev (d, devname, force);</PRE>

<H3>
int ftt_describe_dev(ftt_descriptor <B>d,</B> char *<B>devname,</B> FILE
*pf<B>)</B></H3>
prints a description of the given device indicated in <I>devname</I>, listing
the density, compression options, rewind modes, etc. on the file <I>pf</I>.
It returns the number of bytes written on the file. This routine performs
no tape operations.
<P>Example:
<PRE>#include &lt;stdio.h>
#include "ftt.h"
int status;
ftt_descriptor d;
char *devname = "/dev/my_favorite_device";
status = ftt_describe_dev (d, devname, stdout);</PRE>

<H3>
char *ftt_get_basename(ftt_descriptor <B>d)</B></H3>
returns the basename for the device; thereby the basename for a tape device
can be found by doing an <B>ftt_open</B> followed by an <B>ftt_get_basename.</B>
<P>ftt_get_basename performs no tape operations.
<P>Example:
<PRE>#include "ftt.h"
char *basename;
ftt_descriptor d;
basename = ftt_get_basename(d);</PRE>

<H3>
int <B>ftt_list_supported</B> (FILE *<B>pf)</B></H3>
Prints a description of the device types and operating systems that ftt
officially supports on the file descriptor <B>pf</B>. No ftt descriptors
need to be open to make this call.
<BR><!--NewPage-->
<H2>
Tape Statistics</H2>
Tape drives (especially newer ones) maintain a wealth of information about
how much data they have written, how many errors they encountered, etc.
The following table lists the various statistics that ftt keeps track of
and what type of statistic it is: string, numeric, counter, or flag. Note
that all drives do not support all statistics.
<CENTER>
<P>TABLE 3. ftt statistics</CENTER>

<TABLE BORDER >
<TR ALIGN=LEFT>
<TD ALIGN=LEFT>stat</TD>

<TD ALIGN=LEFT>Description</TD>

<TD ALIGN=LEFT>Notes</TD>

<TD ALIGN=LEFT>Origin</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_VENDOR_ID</TD>

<TD ALIGN=LEFT>vendor id data</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Drive:SCSI Inquiry</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_PRODUCT_ID</TD>

<TD ALIGN=LEFT>product id</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Drive:SCSI Inquiry</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_FIRMWARE</TD>

<TD ALIGN=LEFT>firmware rev level</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Drive:SCSI Inquiry</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_SERIAL_NUM</TD>

<TD ALIGN=LEFT>Device serial number</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Drive:SCSI2 Inquiry</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_CLEANING_BIT</TD>

<TD ALIGN=LEFT>Device needs cleaning</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_READ_COUNT</TD>

<TD ALIGN=LEFT>Decimal number of KBread since rewind/reset</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense (EXB specific) <B>or</B> SCSI2 Log
Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_WRITE_COUNT</TD>

<TD ALIGN=LEFT>Decimal number of KB written since rewind/reset</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>(see above)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_READ_ERRORS</TD>

<TD ALIGN=LEFT>Read errors - drive corrected</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>(see above)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_WRITE_ERRORS</TD>

<TD ALIGN=LEFT>Write errors - drive corrected</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>(see above)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_READ_COMP</TD>

<TD ALIGN=LEFT>Compression factor for reads</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI2 Log Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_WRITE_COMP</TD>

<TD ALIGN=LEFT>Compression factor for writes</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI2 Log Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_FILE_NUMBER</TD>

<TD ALIGN=LEFT>File number from BOT</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Ftt: d->current_file</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_BLOCK_NUMBER</TD>

<TD ALIGN=LEFT>Block number in current file</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Ftt: d->current_block</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_BOT</TD>

<TD ALIGN=LEFT>at beginning of tape</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Ftt: bookkeeping (above), <B>or</B> SCSI Request Sense,
<B>or</B> SCSI Read Position</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_READY</TD>

<TD ALIGN=LEFT>Device ready status</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense <B>or</B> SCSI Test Unit Ready</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_WRITE_PROT</TD>

<TD ALIGN=LEFT>Device write protect status</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI Mode Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_FMK</TD>

<TD ALIGN=LEFT>At filemark</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_EOM</TD>

<TD ALIGN=LEFT>At end of media (early warning)</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_PEOT</TD>

<TD ALIGN=LEFT>At physical end of tape (really at end)</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense (EXB-Specific)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_MEDIA_TYPE</TD>

<TD ALIGN=LEFT>Media type</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI ModeSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_BLOCK_SIZE</TD>

<TD ALIGN=LEFT>Tape block size</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI Mode Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_BLOCK_TOTAL</TD>

<TD ALIGN=LEFT>Tape length in KB</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI Mode Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TRANS_DENSITY</TD>

<TD ALIGN=LEFT>Translated density ala ftt_get_mode</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Ftt: table and FTT_DENSITY</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TRANS_COMPRESS</TD>

<TD ALIGN=LEFT>Translated compression ala ftt_get_mode</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>(see above) <B>and</B> SCSI2 Mode Sense page 0x10</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_REMAIN_TAPE</TD>

<TD ALIGN=LEFT>Remaining KB of tape</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_USER_READ</TD>

<TD ALIGN=LEFT>KB read since open/ unload</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt: d->readkb</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_USER_WRITE</TD>

<TD ALIGN=LEFT>KB written since open/ unload</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt: d->writekb</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_CONTROLLER</TD>

<TD ALIGN=LEFT>Controller type</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Ftt: table</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_DENSITY</TD>

<TD ALIGN=LEFT>Tape density</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive:SCSI Mode Sense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ILI</TD>

<TD ALIGN=LEFT>Invalid Length Indicator</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_SCSI_ASC</TD>

<TD ALIGN=LEFT>Additional Sense Code</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_SCSI_ASCQ</TD>

<TD ALIGN=LEFT>Additional Sense Code Qualifier</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_PF</TD>

<TD ALIGN=LEFT>Power Failed!</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense (EXB specific)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_CLEANDED_BIT</TD>

<TD ALIGN=LEFT>Cleaning performed per FTT_CLEANING_BITt</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TRACK_RETRY</TD>

<TD ALIGN=LEFT>Track retry errors</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive:SCSI ReqSense (EXB 8x05 specific)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_UNDERRUN</TD>

<TD ALIGN=LEFT>stop/start counter from</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>(see above)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_MOTION_HOURS</TD>

<TD ALIGN=LEFT>hours tape drive is in motion</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Drive SCSI ReqSense (DLT specific)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_POWER_HOURS</TD>

<TD ALIGN=LEFT>Number of hours device has been on</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Drive:SCSI ReqSense (DLT specific)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TUR_STATUS</TD>

<TD ALIGN=LEFT>Status</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive:ScsiTestUnit Ready</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_COUNT_ORIGIN</TD>

<TD ALIGN=LEFT>Origin of read/write kb</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Ftt</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_N_READS</TD>

<TD ALIGN=LEFT>Number of read calls</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt: d->nreads</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_N_WRITES</TD>

<TD ALIGN=LEFT>Number of write and writefm calls</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt: d->nwrites</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TNP</TD>

<TD ALIGN=LEFT>Tape Not Present bit</TD>

<TD ALIGN=LEFT>flag</TD>

<TD ALIGN=LEFT>Drive: SCSI ReqSense (EXB specific)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_SENSE_KEY</TD>

<TD ALIGN=LEFT>Sense Key</TD>

<TD ALIGN=LEFT>numeric</TD>

<TD ALIGN=LEFT>Drive:SCSI ReqSense</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TRANS_SENSE_KEY</TD>

<TD ALIGN=LEFT>Above translated to strings</TD>

<TD ALIGN=LEFT>string</TD>

<TD ALIGN=LEFT>Ftt:</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_RETRIES</TD>

<TD ALIGN=LEFT>total ftt_retry() repeats</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt:</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_FAIL_RETRIES</TD>

<TD ALIGN=LEFT>total ftt_retry() failures</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_RESETS</TD>

<TD ALIGN=LEFT>Unexpected BOT discoveries</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_HARD_ERRORS</TD>

<TD ALIGN=LEFT>Counter of recovered errors</TD>

<TD ALIGN=LEFT>counter</TD>

<TD ALIGN=LEFT>Ftt</TD>
</TR>
</TABLE>

<H3>
ftt_stat_buf <B>ftt_alloc_stat (void)</B></H3>
allocates a statistic buffer for use with the other ftt statistics routines.
<P>Example:
<PRE>#include "ftt.h"
ftt_stat_buf stbuff;
stbuff = ftt_alloc_stat();</PRE>

<H3>
int <B>ftt_free_stat(</B>ftt_stat_buf <B>stbuff)</B></H3>
frees a statistic buffer indicated by <I>stbuff</I>.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_stat_buf stbuff;
status = ftt_free_stat(stbuff);</PRE>

<H3>
int <B>ftt_get_stats(ftt_descriptor</B> d, ftt_stat_buf stbuff)</H3>
extracts current statistics for tape usage, including data written, data
read, write errors, read errors, etc. and packs it into an ftt_stat_buf
structure, <I>stbuff</I>. Note that because on some platforms we must close
and reopen devices to implement this call, ftt_get_stats will always put
filemarks on your tape if you have been writing (see <B>ftt_close_dev</B>).
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
ftt_stat_buf stbuff;
stbuff = ftt_alloc_stat();
status = ftt_get_stats(d,stbuff);</PRE>

<H3>
char *<B>ftt_extract_stats (</B>ftt_stat_buf <B>b,</B> int <B>stat)</B></H3>
extracts a string describing a named piece of tape data, indicated by stat.
Acceptable values for stat are listed in Table 2. The routine will return
a null pointer (0) if a given statistic is not available in the status
block.
<P>ftt_extract_stats performs no tape operations.
<P>Example:
<PRE>#include &lt;stdio.h>
#include "ftt.h"
char *value;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* value of extracted stat */
ftt_stat_buf stbuff;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* statistics buffer */
int status, ftt_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status of ftt calls */
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */</PRE>

<PRE>stbuff = ftt_alloc_stat();
status = ftt_get_stats(d,stbuff);
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}
value = ftt_extract_stats(stbuff,FTT_MOTION_HOURS);
ftt_free_stat(stbuff);</PRE>

<H3>
void <B>ftt_sub_stats (</B>ftt_stat_buf <B>b1</B>, ftt_stat_buf <B>b2</B>,
ftt_stat_buf <B>res)</B></H3>
subtracts numeric values in the stat buffer <I>b1</I> from the values in
<I>b2</I>and the result is put in <I>res</I>, to keep running totals, and/or
compute deltas. String values are taken from <I>b1</I>, unless the entry
in <I>b1</I> is null and the one in <I>b2</I> is not. Flag values are taken
from <I>b1</I>.
<P>Note that media type and compression rates, while technically numeric,
are not treated as such by these routines, since subtracting them is meaningless.
<P>ftt_sub_stats performs no tape operations.
<P>Example:
<PRE>#include &lt;stdio.h>
#include "ftt.h"
int status, ftt_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status of ftt calls */
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */
ftt_stat_buf b1,b2,res;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* statistics buffers */
&nbsp;
b1 = ftt_alloc_stat();&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get buffers */
b2 = ftt_alloc_stat();
res = ftt_alloc_stat();
status = ftt_get_stats(d,b1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get tape statistics */
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}</PRE>

<PRE>/* do some tape i/o here */</PRE>

<PRE>status = ftt_get_stats(d,b2);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get tape statistics again */
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}
ftt_sub_stats(b1, b2, res);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* get deltas and store in res */</PRE>

<PRE>ftt_free_stat(b1);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* free buffers */
ftt_free_stat(b2);
ftt_free_stat (res);</PRE>

<H3>
void <B>ftt_add_stats (</B>ftt_stat_buf <B>b1</B>, ftt_stat_buf <B>b2</B>,
ftt_stat_buf <B>res)</B></H3>
adds numeric values in the stat buffer <I>b1</I> to the values in <I>b2</I>
and the result is put in <I>res</I>, to keep running totals, and/or compute
deltas. String values are taken from <I>b1</I>, unless the entry in <I>b1</I>
is null and the one in <I>b2</I> is not. Flag values are taken from <I>b1</I>.
<P>Note that media type and compression rates, while technically numeric,
are not treated as such by these routines, since adding them is meaningless.
<P>ftt_add_stats performs no tape operations.
<P>Example: see ftt_sub_stats example.
<P>8.7 ftt_stat_buf *<B>ftt_init_stats (</B>ftt_descriptor <B>d)</B>
<P>returns pair of statistics buffers. The first is initialized with zeros
and the second with current statistics for the drive.
<P>This routine performs a <B>ftt_get_stats</B> which in turn calls <B>ftt_close_dev</B>
which will write file marks if the preceding operation was a write or write
file mark.
<P>Example:
<PRE>#include "ftt.h"
ftt_stat_buf *bp;
ftt_descriptor d;
bp = ftt_init_stats(d);</PRE>

<H3>
int <B>ftt_update_stats (</B>ftt_descriptor <B>d,</B> ftt_stat_buf *<B>bp)</B></H3>
updates the status pair <I>bp</I>, keeping running totals in <I>bp[0]</I>
and latest statistics in <I>bp[1]</I>.This routine performs a <B>ftt_get_stats</B>
which in turn calls <B>ftt_close_dev</B> which will write file marks if
the preceding operation was a write or write file mark.
<P>Example:
<PRE>#include "ftt.h"
ftt_stat_buf *bp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status buffer pair */
ftt_descriptor d;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* ftt file descriptor */
int status, ftt_status;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* status of ftt calls */
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */</PRE>

<PRE>bp = ftt_init_stats(d);
/* do some tape i/o here */
status = ftt_update_stats(d,bp);&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* update statistics again */
if (status == -1)
&nbsp;&nbsp; {
&nbsp;&nbsp; estring = ftt_get_error(&amp;ftt_status);
&nbsp;&nbsp; fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_ascii_error[ftt_status],estring);
}</PRE>

<H3>
int <B>ftt_dump_stats (</B>ftt_stat_buf <B>b,</B> FILE *<B>pf)</B></H3>
prints important statistics from the statistics buffer <I>b</I> on file
descriptor <I>pf</I><B>. ftt_dump_stats</B> performs no tape I/O. It returns
the number of bytes written on the file.
<P>Example:
<PRE>#include &lt;stdio.h>
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_stat_buf stbuff;
stbuff = ftt_alloc_stat();
status = ftt_get_stats(d,stbuff);
status = ftt_dump_stats (stbuff, stderr);
ftt_free_stat(stbuff);</PRE>
<!--NewPage-->
<H2>
Status Routines</H2>

<H3>
int <B>ftt_status(</B>ftt_descriptor <B>d,</B> int <B>timeout)</B></H3>
returns a flags word with the following bits set:
<CENTER>
<P>TABLE 4. ftt_status flag bits</CENTER>

<TABLE BORDER >
<TR ALIGN=LEFT>
<TD ALIGN=LEFT>Bit setting</TD>

<TD ALIGN=LEFT>Description</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ABOT</TD>

<TD ALIGN=LEFT>At beginning of tape</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_AEOT</TD>

<TD ALIGN=LEFT>At Physical end of tape</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_AEW</TD>

<TD ALIGN=LEFT>At Early Warning mark near EOT</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_PROT</TD>

<TD ALIGN=LEFT>Write Protected tape</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ONLINE</TD>

<TD ALIGN=LEFT>A tape is loaded and online</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_BUSY</TD>

<TD ALIGN=LEFT>The tape is rewinding, unloading, etc. and not responding.</TD>
</TR>
</TABLE>

<P>indicating the current tape position. This routine shall block up to
<I>timeout</I> seconds if there is a tape in the drive, waiting for the
tape to come online, or to become not busy. If we cannot determine the
presence of a tape, we will simply block until the timeout expires.
<P>An external setuid executable will be run to obtain this data if necessary
(e.g. AIX), which means that file marks will be written if the last operation
was a <B>ftt_write</B> or <B>ftt_writefm,</B> (see <B>ftt_close_dev</B>()).
Therefore, calling <B>ftt_status</B> after every write should be avoided.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;&nbsp;
status = ftt_status (d, 0);</PRE>

<H3>
int <B>ftt_get_position(</B>ftt_descriptor <B>d,</B> int *<B>file,</B>
int *<B>block)</B></H3>
returns the current <I>file</I> and <I>block</I> position on the tape.
It ails if no tape is loaded, or the position is unknown (i.e. the tape
was just opened, has never been rewound and is not at BOT.) Note that both
<I>file</I> and <I>block</I> are zero at BOT, the count is the number of
file marks we are past BOT and the number of blocks past the last filemark,
where BOT is treated as the 0-th filemark.
<P>ftt_get_position performs no tape operations, it merely reports bookkeeping
information.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
int fileno, blockno
status = ftt_get_position (d, &amp;fileno, &amp;blockno);</PRE>

<H3>
char *<B>ftt_get_error (</B>int *<B>pn)</B></H3>
returns a pointer to a string describing the result of the last call. If
<I>pn</I> is not null, it is treated as an integer pointer and the current
error number is stored there.
<P>ftt_get_error performs no tape operations. Any mode sense data reported
was obtained by the routine reporting the error.
<P>Example:
<PRE>#include &lt;stdio.h>
#include "ftt.h"
int error;
char *estring;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* error string */</PRE>

<PRE>estring = ftt_get_error(&amp;ftt_status);
fprintf (stderr, "Error:%s Error String:%s \n",
&nbsp;&nbsp; ftt_ascii_error[error],estring);</PRE>
<!--NewPage-->
<H2>
Volume verification</H2>

<H3>
int <B>ftt_write_vol_label (</B>ftt_descriptor <B>d,</B> int <B>type,</B>
char * <B>vollabel)</B></H3>
rewinds the tape, formats a label specified in <I>vollabel</I> into a buffer,
and writes the label on the tape, then writes two filemarks and backs over
one by doing an <B>ftt_close_dev</B> and forward skipping one filemark.<I>type</I>
can be any of the types specified in <B>ftt_guess_label</B> (except FTT_DONTCHECK)<B>.</B>
<P>This routine performs numerous tape operations.
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_write_vol_label(d, FTT_ANSI_HEADER,"mydog");</PRE>

<H3>
int <B>ftt_verify_vol_label (</B>ftt_descriptor <B>d,</B> int <B>type,</B>
char *<B>vollabel,</B> int <B>timeout,</B> int <B>rdonly)</B></H3>
rewinds the tape, uses <B>ftt_status</B> to check if the tape is write
protected, reads the first block, uses <B>ftt_guess_label</B> to check
that the label is the indicated type and volume label specified in <I>vollabel</I>.<I>timeout</I>
is the timeout for the status check for write protect status, in seconds.
<I>type</I> can be any of the types specified in <B>ftt_guess_label.</B>
<I>rdonly</I> <B>is a boolean flag to indicate if the device should be
opened readonly.</B>
<P>The tape is left positioned after the volume label.
<P>Example:
<PRE>#include "ftt.h"
int status;
ftt_descriptor d;
status = ftt_verify_vol_label(d, FTT_ANSI_HEADER,"mydog",0,TRUE);</PRE>

<H3>
int <B>ftt_guess_label (</B>char *<B>buf,</B> int <B>length,</B> char **<B>vol,</B>
int **<B>vlen)</B></H3>
examines a buffer in <I>buf</I> (ostensibly returned by ftt_read) with
a length of <I>length</I>, and attempts to guess what sort of tape format
this is, assuming this is the first block of the tape. It returns a value
of the following type:
<CENTER>
<P>TABLE 5. ftt_guess_label label types</CENTER>

<TABLE BORDER >
<TR ALIGN=LEFT>
<TD ALIGN=LEFT>Value</TD>

<TD ALIGN=LEFT>Description</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_ANSI_HEADER</TD>

<TD ALIGN=LEFT>An ANSI X3.27 standard tape</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_FMB_HEADER</TD>

<TD ALIGN=LEFT>An FMB tape</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_TAR_HEADER</TD>

<TD ALIGN=LEFT>A tar tape (POSIX nnn)</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_CPIO_HEADER</TD>

<TD ALIGN=LEFT>A Cpio -c format tape</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_UNKNOWN_HEADER</TD>

<TD ALIGN=LEFT>No known label type</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_BLANK_HEADER</TD>

<TD ALIGN=LEFT>Verifies length is -1 and last error was FTT_BLANK</TD>
</TR>

<TR ALIGN=LEFT>
<TD ALIGN=LEFT>FTT_DONTCHECK_HEADER</TD>

<TD ALIGN=LEFT>Only used by ftt_verify_vol_label()</TD>
</TR>
</TABLE>

<P>The <I>vol</I> and <I>vlen</I> arguments are taken to be the address
of a character pointer and of an integer, and will be filled in with the
address and length of the volume name in the tape header, if any.
<P>ftt_guess_label performs no tape operations.
<P>In most cases, the user could use <B>ftt_verify_vol_label</B> directly,
which internally makes a <B>ftt_guess_label call</B>.
<P>Example:
<PRE>#include "ftt.h"
int type;
char *databuf;
int buflen;
char *vollabel;
int vollen;
type = ftt_guess_label(databuf, buflen, vollabel, vollen);</PRE>

<H3>
int <B>ftt_format_label (</B>char *<B>buf,</B> int <B>length,</B> char
*<B>vol,</B> int <B>vlen,</B> int <B>type)</B></H3>
This function will format a label pointed to by string <I>vol</I> and of
given length (<I>vlen</I>) into a buffer (<I>buf</I>) of given length (<I>length</I>)
which will return the same volume label and type in later calls to <B>ftt_guess_label</B>.
Users can then write this label at the beginning of tape with <B>ftt_write</B>.
In most cases, the user would call <B>ftt_write_label</B> directly. <I>type</I>
can be any of the types specified in <B>ftt_guess_label</B> (except FTT_DONTCHECK_HEADER).
It returns the length of the filled in volume header block.
<P>ftt_format_label performs no tape operations.
<P>Example:
<PRE>#include "ftt.h"
int length;
char *databuf;
int buflen;
length = ftt_format_label(databuf, buflen, "mydog",

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; strlen ("mydog"), FTT_ANSI_HEADER);</PRE>
11
<P>Issuing Commands Asynchronously
<P>By default, all <B>ftt</B> commands are issued synchronously. There
are several commands, however, that a user may wish to issue asynchronously,
e.g. f<B>tt_rewind()</B>. With the exception of <B>ftt_open()</B> and <B>ftt_close()</B>
themselves, all <B>ftt</B> commands can optionally be asynchronous.
<P>When a user decides to issue a command asynchronously, he should issue
an <B>ftt_fork()</B> command. The child then does the desired commands
and returns the status vi <B>ftt_report()</B>. The parent process can continue
doing whatever it wants and then rendezvous with the child via <B>ftt_wait()</B>.
It can also periodically check if the child process has completed via <B>ftt_check()</B>;
<P>It is important to note that only one asynchronous operation at a time
may be active on a given file descriptor.
<H3>
int <B>ftt_fork (</B>ftt_descriptor <B>d)</B></H3>
Creates an asynchronous process for performing ftt calls, which should
report status via <B>ftt_report()</B> which will in turn be collected via
<B>ftt_wait()</B>. Returns a process ID in the parent process, a 0 in the
child process, and -1 in the case of failure. The call is generally used
as follows:
<P>Example:
<PRE>#include "ftt.h"
char *switch (ftt_fork(d)){
case 0: /* child */
&nbsp;&nbsp;&nbsp; ftt_skip_fm(d,2);
&nbsp;&nbsp;&nbsp; ftt_rewind(d);
&nbsp;&nbsp;&nbsp; ftt_report(d);
default: /* parent */
&nbsp;&nbsp;&nbsp; do_stuff_during_rewind();
&nbsp;&nbsp;&nbsp; ftt_wait(d);
&nbsp;&nbsp;&nbsp; break
case -1: /* error */
&nbsp;&nbsp;&nbsp; pc = ftt_get_error(&amp;err);
&nbsp;&nbsp;&nbsp; fprintf(stderr,pc);
&nbsp;&nbsp;&nbsp; exit(0);
}</PRE>

<H3>
void <B>ftt_report (</B>ftt_descriptor <B>d)</B></H3>
Collects up the status from the last <B>ftt</B> call, reports it to the
parent process, so that it will be collected by <B>ftt_wait()</B>, and
exits.
<H3>
int <B>ftt_wait (</B>ftt_descriptor <B>d)</B></H3>
Waits for a pending asynchronous operation to report its status with <B>ftt_report()</B>,
and sets the error string and error code for ftt_get_error to the result
of the completed operation.
<P>ftt_wait performs no tape operations of its own.
<H3>
int <B>ftt_check (</B>ftt_descriptor <B>d)</B></H3>
The ftt_check routine succeeds if the asynchronous operation occurring
on the device has completed, otherwise it returns a busy device error.
<P>ftt_check performs no tape operations.
<P>12
<P>Expert Commands
<P>As much as <B>ftt</B> would like hide protect the user from implementation
specifics, there are times that the expert user would REALLY like to something
detailed. Most of the routines were born when trying to recover data from
tapes that are overwritten (see the Appendix at the end of this user's
guide). As a result, <B>ftt</B> provides a few routines to facilitate some
of these functions for the knowledgeable user. It is not recommended that
the novice user issue these commands.
<H3>
int ftt_clear_unrecovered (ftt_descriptor d)</H3>
clear the <B>ftt</B> internal unrecovered flag. If certain operations fail
(e.g. ftt_skip) the tape is left in an unknown position. To protect the
user from writing reading/writing in this area, subsequent i/o calls require
the user to first reposition to a known location, i.e., the beginning of
tape. ftt_clear_unrecoverd clears this internal <B>ftt</B> flag and will
therefore allow additional i/o calls without rewinding. This is useful
in conjunction with ftt_locate.
<P>Example:
<PRE>#include "ftt.h"
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_clear_unrecovered (d);</PRE>

<H3>
int <B>ftt_all_scsi (</B>ftt_descriptor <B>d)</B></H3>
all <B>ftt</B> commands will bypass the standard vendor device driver and
will go through the raw scsi device driver. Normally, commands like read
and write are not issued in raw scsi mode. This is useful when trying to
access all of the request sense information for read and write commands
(by setting the ftt_debug level so this information will be displayed).
It is also useful if the vendor supplied device driver is buggy.
<P>Example:
<PRE>#include "ftt.h"
#include "ftt.h"
int status;
ftt_descriptor d;
ftt_all_scsi(d);</PRE>

<H3>
int ftt_locate (ftt_descriptor d, int blockno)</H3>
issues the SCSI locate command to position the tape to the specified logical
block.
<P>Example:
<PRE>#include "ftt.h"
int status;
int blockno;
ftt_descriptor d;
status = ftt_locate(d,blockno);</PRE>
13
<P>Linking an Executable
<P>Linking your code with the <B>ftt</B> library should be accomplished
by adding the following link options to your <TT>Makefile</TT> or other
build script:
<P>-L$(FTT_DIR)/lib -lftt 'cat $(FTT_DIR)/lib/libs'
<P>where the last portion in backquotes places the contents of the file
<TT>libs</TT> in the <B>ftt</B> library directory on the link command line.
This will include any platform-specific libraries needed on the current
platform in the link without you having to know what they are, or tailor
your build scripts to different platforms. For example, a complete makefile
for a program using <B>ftt</B> would look like:
<P>INC = -I$(FTT_DIR)/include
<P>LIB = -L$(FTT_DIR)/lib -lftt 'cat $(FTT_DIR)/lib/libs'
<P>CFLAGS = $(INC)
<P>LDFLAGS = $(LIB)
<P>EXAMPLES = tapecopy
<P>all: $(EXAMPLES)
<P>tapecopy: tapecopy.c
<P>$(CC) $(CFLAGS) -o tapecopy tapecopy.c $(LIB)
<BR><!--NewPage-->
<H2>
ftt_test</H2>
An binary is provided with ftt to verify that the test routines themselves
work as intended as well as that an individual drive is behaving normally.
ftt_test is a command line parser. It is very unsophisticated in that it
doesn't support any flow control whatsoever: it simply executes one line
at time. It can be run interactively, through a shell script, or by redirecting
stdin.
<P>ftt_test can only have one drive open at a time. The drive name is specified
in one of the following fashions, in descending order of priority:
<P>* on the ftt_open call itself (e.g., ftt_open /dev/rmt/tps2d4)
<P>* on the invocation line (e.g., ftt_test -f /dev/rmt/tps2d4)
<P>* from the environment variable FTT_TAPE (e.g. setenv FTT_TAPE /dev/rmt/tps2d4).
<H3>
ftt_test Commands</H3>
For testing purposes, it is desirable to issue commands that will generate
a certain expected error. To avoid a lot of unnecessary clutter, this expected
error messages to stderr can be suppressed. Each command can take a "-status
[FTT_ERROR]" option which indicates the expected error for that command.
An error message will be written to stderr only if this error code is not
returned. The list of valid values for FTT_ERROR are all of the error returns
listed earlier in this document (e.g., FTT_EIO, FTT_ENOENT, FTT_ENOTAPE).
<P>All commands optionally take a "-usage" switch as well. This is to aid
the interactive user in determining what are the valid options and parameters
for a given command. If the "-usage" switch is used, the actual command
will NOT be executed, but a usage message will simply be printed to stderr.
<H4>
Open/close Commands</H4>
ftt_open [basename] [-readonly] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt_open library routine using <I>basename</I>
as the input filename. <I>-readonly</I> will open the file for read only
access. Without this flag, the device is opened for read/write access.
The ftt file descriptor is stored in a global variable for all other accesses
on this device by the test routines.
<P>ftt_open_logical [basename] [-flavor &lt;flavor>] &lt;-driveid &lt;driveid>>
[-readonly] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt_open library routine using <I>basename</I>
as the input filename. <I>flavor</I> indicates the operating system flavor
to use. If not supplied, the test routine will use the current operating
system flavor. <I>driveid</I> specifies the drive type. <I>-readonly</I>
will open the file for read only access. Without this flag, the device
is opened for read/write access. The ftt file descriptor is stored in a
global variable for all other accesses on this device by the test routines.
<P>ftt_open_dev [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_close [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_close_dev [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<H4>
Read/write Commands</H4>
ftt_write_tblock [-nblocks &lt;n>] [-bsize &lt;nbytes>] [-delta &lt;ndbytes>]
[-alignmask &lt;nalign>] [-delay &lt;nsec>] [-status &lt;error>] [-usage]
<P>write <I>n</I> (default = 1) test blocks of size <I>nbytes</I> (default
= 32768). If <I>ndbytes</I> is specified, the writes will be of random
size between <I>nbytes</I> and <I>nbytes + ndbytes</I>. If <I>alignment</I>
is specified, random size records must will be adjusted to this byte alignment.
Valid values for <I>nalign</I> are 0 (allows odd byte writes), 1 (allows
odd word writes), and 3 (allows only longword multiples). If <I>delay</I>
is specified, a random delay of 0 to <I>nsec</I> will occur between writes.
The first longword in the test block is the number of bytes in the block,
the second is the block number, the third is the filename. All remaining
bytes are filled with ascending bytes starting with (file number + block
number)% 256.
<P>ftt_verify_tblock [-nblocks &lt;n>] [-delay &lt;nsec>] [-oddbyte] [-filemark]
[-status &lt;error>] [-maxbytes &lt;readsize>] [-usage]
<P>read and verify <I>n</I> (default = 1) test blocks If delay is specified,
a random delay of 0 to <I>nsec</I> will occur between reads. If the <I>-oddbyte</I>
switch is used, an odd number of bytes will be used for the input buffer.
<I>-filemark</I> indicates that the record should be a filemark. <I>readsize</I>
will indicate the maximum number of bytes to read. This value cannot be
greater than 64kbytes.
<P>ftt_dump [-nblocks n] [-filename &lt;filename>] [-status &lt;error>]
[-usage]
<P>read <I>n</I> blocks (defaults until end of tape) and then write them
to stdout or f<I>ilename</I> if specified.
<P>ftt_undump [-filename &lt;filename>] [-status &lt;error>] [-usage]
<P>write until end of data from stdin or filename if specified.
<P>ftt_writefm [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_write2fm [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_verify_vol_label [-timeout &lt;nsecs>] [-type &lt;type>] [-label
&lt;labelname>] [-readonly] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. Information is written to stderr. This command
will wait <I>nsecs</I> for the drive to come online. The default value
is 0. Valid <I>types</I> are:
<P>* FTT_ANSI_HEADER
<P>* FTT_FMB_HEADER
<P>* FTT_TAR_HEADER
<P>* FTT_CPIO_HEADER
<P>* FTT_UNKNOWN_HEADER
<P>* FTT_BLANK_HEADER
<P>* FTT_DONTCHECK_HEADER
<P>If not specified, a type of FTT_ANSI_HEADER is assumed.
<P>ftt_write_vol_label [-type &lt;type>] [-label &lt;labelname>] [-status
&lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. The valid values for <I>type</I> are the same
as in ftt_verify_vol_label.
<P>If not specified, FTT_ANSI_HEADER is assumed.
<H4>
Tape Positioning Commands</H4>
ftt_status [-timeout &lt;nsecs>] [-status &lt;error>]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor and prints the current drive status. The user
can specify a timeout of <I>nsecs</I>. If no timeout is specified, the
default value is 0.
<P>ftt_test_status [-&lt;flag1>... [-&lt;flag>]] [-timeout &lt;nsecs>]
[-status &lt;error>]
<P>calls ftt_status using the global variable for the ftt file descriptor.
Each flag is tested to see if the condition is true. Valid values for <I>flag</I>
are: FTT_ABOT, FTT_AEOT, FTT_AEW, FTT_PROT, FTT_ONLINE, and FTT_BUSY. The
user can specify a timeout of <I>nsecs</I>. If no timeout is specified,
the default value is 0.
<P>ftt_skip_to_double_fm [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously.
<P>ftt_skip_fm &lt;nfilemarks> [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously.
<P>ftt_skip_rec &lt;nrecords> [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously.
<P>ftt_rewind [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously.
<P>ftt_retension [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously
<P>ftt_erase [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously.
<P>ftt_unload [-async] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor where <I>async</I> will issue the command asynchronously.
<P>ftt_get_position [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. The current file and block number is written
to stderr.
<P>ftt_verify_position &lt;fileno> &lt;blockno>
<P>verifies that the position specified by fileno and blockno match those
returned by ftt_get_position.
<H4>
Asynchronous Support Commands</H4>
ftt_wait [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_check [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<H4>
Get/set Mode Commands and Other Commands That Care About Filenames</H4>
ftt_list_all [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. The list of device node pathnames is written
to stderr.
<P>ftt_chall &lt;uid> &lt;gid> &lt;mode> [-status error] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. The user name is specified in <I>uid</I>,
the group name in <I>gid</I>, and the mode in <I>mode</I>.
<P>ftt_verify_exist
<P>verifies that all of the filenames listed by ftt_list_all really do
exist.
<P>ftt_avail_mode &lt;density> &lt;mode> [-blocksize &lt;b>] [-status &lt;error>]
[-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. The density and mode must be specified in
<I>density</I> and <I>mode</I> respectively. If the blocksize is not specified,
variable block will be assumed. The device node is printed to stderr.
<P>ftt_get_mode [-status &lt;error>] [-usage]
<P>calls the ftt_get_mode library routine using the global variable for
the ftt file descriptor.
<P>ftt_set_mode &lt;density> &lt;mode> [-blocksize &lt;b>] [-status &lt;error>]
[-usage]
<P>calls the ftt_set_mode library routine using the global variable for
the ftt file descriptor. If no blocksize is specified, variable block mode
is assumed.
<P>ftt_get_mode_dev [device_name] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. Node information is written to stderr.
<P>ftt_set_mode_dev &lt;devname> [-blocksize &lt;b>] [-force] [-status
&lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. If no blocksize is specified, variable block
mode is assumed. <I>-force</I> will turn the force flag on. It is off by
default.
<P>ftt_verify_modes
<P>verifies all modes of the device. This routines will loop through all
modes of the device. It will set the mode, write, verify the mode is what
we think it should be, rewind, and then verify the data.
<P>ftt_get_basename [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_describe_dev [device_name] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<H4>
Statistics Commands</H4>
ftt_get_stats [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. Information is written to stderr.
<P>ftt_extract_stats &lt;statistic> [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. Information is written to stderr. Valid values
for <I>statistic</I> are from the list described earlier in this document
(e.g., FTT_PRODUCT_ID, FTT_VENDOR_ID, FTT_DENSITY, etc.).
<P>ftt_init_stats [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_update_stats [-errors][-part_display] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. The accumulated totals are written to stderr.
<I>-part_display</I> will only display the statistics that are counters,
while <I>-errors</I> will display the read/write counts, errors, and percent
error rates.
<P>ftt_dump_stats [-filename &lt;filename>] [-status &lt;error>] [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. It will dump the stats to <I>filename</I>
if specified, otherwise stderr.
<P>ftt_list_supported [-filename &lt;filename>] [-usage]
<P>calls the corresponding ftt library routine. It will dump the stats
to <I>filename</I> if specified, otherwise stderr.
<H4>
Error Commands</H4>
ftt_eprintf &lt;string> [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_get_error [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. Information is written to stderr.
<P>ftt_max_error [&lt;maxerror>]
<P>Set/show the current maximum number of errors before ftt_test will abort.
<H4>
Expert Commands</H4>
These commands are not meant for the novice user, but we have found them
invaluable in salvaging overwritten tapes. Refer to the appendix on how
to do this recovery.
<P>ftt_clear_unrecovered [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_all_scsi [-usage]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor.
<P>ftt_locate &lt;blockno> [-usage] [-status &lt;error>]
<P>calls the corresponding ftt library routine using the global variable
for the ftt file descriptor. It will locate the tape to the logical block
number specified by <I>blockno.</I>
<H4>
Miscellaneous Commands</H4>
ftt_date [-usage]
<P>output current date to stderr.
<P>ftt_echo [string] [-usage]
<P>print <I>string</I> to stderr.
<P>ftt_debug [level] [-test] [-usage]
<P>Set/show the current debug level for the ftt library as well as the
test routines. The debug level of the library will be set to <I>level</I>.
If <I>-test</I> is specified, it will set the debug level for just the
test routines. If level is not specified, the current debug level for both
the library and the test routines are displayed.
<P>Debug levels for the ftt library are:
<P>* 0 = no debug prints
<P>* 1 = print "Entering routine..." in each routine
<P>* 2 = miscellaneous arguments "got this far" prints
<P>* 3 = debug prints on each pass through loops, etc. More debug prints
than you can shake a stick at.
<P>Debug levels for the test routines are:
<P>* 1 = display commands entered by user.
<H3>
ftt_test Examples</H3>

<H4>
Interactive Example:</H4>
This example will rewind a tape specified on the open command itself:
<PRE>$FTT_DIR/bin/ftt_test
ftt_test> ftt_open /dev/rmt/tps2d4
ftt_test> ftt_rewind
ftt_test> ftt_close</PRE>

<H4>
Shell Script Example:</H4>
This is an example ksh script that will rewind a tape. The device name
can be specified as the first argument to the script, or from the environment
variable FTT_TAPE.
<PRE>#!/bin/ksh
#==========================
# This will rewind the tape
# =========================
# Get the tape device by looking in $1.&nbsp;
# If that's not set, try FTT_TAPE.&nbsp;
# If that's not set either, then exit.
export FTT_TAPE
FTT_TAPE=${1:-${FTT_TAPE:-""}}
FTT_TAPE=${FTT_TAPE:?"No device specified"}
#==========================================&nbsp;
$FTT_DIR/bin/ftt_test &lt;&lt; EOD
ftt_open
ftt_rewind
ftt_close
EOD</PRE>

<H4>
Redirection Example:</H4>
This example will rewind a tape drive based on an ftt_test script. This
device is specified as a switch to the ftt_test command itself.
<PRE>cat my.ftt
&nbsp;&nbsp;&nbsp; ftt_open
&nbsp;&nbsp;&nbsp; ftt_rewind
&nbsp;&nbsp;&nbsp; ftt_close
$FTT_DIR/bin/ftt_test -f /dev/rmt/tps2d4 &lt;my.ftt</PRE>

<H3>
ftt_test scripts</H3>
A series of test scripts are also provided to verify the ftt library as
well as verify the behavior of a particular drive. Since the ftt_test program
is very simple in nature (e.g., no flow control support, no variable support),
the test scripts themselves will be ksh scripts. There are both small building
block tests that will verify a particular aspect of the library as well
as all inclusive tests that verify the entire package.
<P>All tests can either rely on the device name being specified in the
environment variable FTT_TAPE or passed in as argument 0 on the command
line.
<H4>
Building block scripts</H4>
Following scripts are set of the <B>ftt_test</B> commands that can be used
as a redirect input.
<P>Name and location:&nbsp;<A NAME="fnB0" href="#fn0"></A><A HREF="#fn0" name="fnB0">[1]</A>
<P>$FTT_DIR/ftt_test/scripts/<TT><U>&lt;script name></U>.dat<A NAME="fnB1" href="#fn1"></A></TT><A HREF="#fn1" name="fnB1">[2]</A>
<P>Usage:
<P>ftt_test -f <TT><U>&lt;drive_name></U> &lt; $FTT_DIR/ftt_test/script/<U>&lt;script_name></U>.dat</TT>
<P>or:
<P>ftt_run_test <TT><U>&lt;script_name></U> <U>&lt;drive_name></U></TT>
<P>2fm
<P>This test will test to make sure that two and only filemarks are written
at the end of tape with the ftt_write2fm call. If two individual calls
to ftt_writefm are called, four filemarks are actually written.
<P>align
<P>This test will write a bunch of records, rewind, and then verify. It
will do this for block sizes that are of longword multiples, word multiples,
and byte multiples.
<P>async
<P>This script will verify the asynchronous capability in ftt. It assumes
that a test tape is inserted that has been written with the "write" test.
It will then skip to the double file mark and then display a time stamp
around an asynchronously issued rewind.
<P>This output will need to be also checked manually to verify that the
change in time is small. It will then check ftt_wait. An asynchronous command
will also be issued that is expected to fail in order to verify that ftt_wait
will return a failure.
<P>close
<P>This test will verify that a close command will leave the tape in a
known position so that when it's opened again, the user knows where he
is.
<P>delay
<P>This script will test write a bunch of blocks and reading a bunch of
blocks with a random delay between i/o operations. This tends to uncover
strange behavior with devices and device drivers. It is a lengthy test
and may take a few hours to run.
<P>describe<A NAME="fnB2" href="#fn2"></A><A HREF="#fn2" name="fnB2">[3]</A>
<P>Prints all device files corresponding to the one tape drive.
<P>erase
<P>This script will write a volume label, erase the tape, and then verify
that the volume label is blank.
<P>full
<P>This script will write to end of tape to verify appropriate errors reporting.
It will take FOREVER to run.
<P>label
<P>This script will write all of the various label types and verify them.
<P>mode
<P>This script will test the various ftt_mode routines. It will be a nested
loop which for all densities, all compressions, and all block sizes (variable
and two different fixed block sizes) will check if the mode is available.
If so, it will rewind the device, set the mode, write some data, verify
the mode, rewind, and finally verify the data.
<P>notape
<P>This script will unload the tape and then verify that the correct error
is returned when trying to access the drive.
<P>position
<P>This script will verify all the positioning commands using the a tape
written by write.ftt. It will verify spacing both records and filemarks
both forwards and backwards. It will verify that the correct error code
is returned if the operation can't be performed. It will check that ftt_status
returns the correct positioning information and that ftt_skip_to_double_fm
works.
<P>rate [-n nblocks] [-s blocksize] [device]<A NAME="fnB3" href="#fn3"></A><A HREF="#fn3" name="fnB3">[4]</A>
<P>This script will rewind the device, and then write the specified number
of blocks with the specified block size. It will time the time for the
data transfer and write this information to stdout. The default block size
is 32768 and the default number of blocks to write is 1000.
<P>read_only
<P>This test verifies that all ftt_write functions will return an error
if the drive is opened as read only. It should also verify that ftt_status
determines that it's a read only drive.
<P>root
<P>This script needs to run as root to work successfully. It does all of
the operations that require root privileges. Currently this is on ftt_chall.
<P>stats
<P>This script will verify the statistics information. The output of the
script will need to be checked manually. It will do a few writes and display
the delta stats and then do a few reads and display the delta stats.
<P>verify
<P>This script verifies a tape written with write.ftt. It verifies that
the volume label, the number of blocks, the contents of the blocks themselves,
the number of file marks, and that the tape is blank at the end. It also
verifies that FTT_ERANGE is returned if the number of bytes to read is
less than the number of bytes in the record.
<P>twrite
<P>This script writes a test tape beginning with an ANSI label. It will
write a few files with a few thousand blocks. The tape written by the script
can be used by other scripts for additional testing. This test should leave
the tape with only two filemarks at the end.
<P>random
<P>This is a special script that is actually generated by a c program.
The c program will generate this ftt script to write a random number of
files of random block size. It then randomly picks a position, skips to
it, and verifies a random number of blocks.
<H4>
All inclusive tests</H4>
A few test scripts are provided as a convenience that call the fundamental
building scripts mentioned in the previous section. There are
<P>ftt_fast [-a] [-u] [device]
<P>This script tests all of the reasonable quick tests to verify that the
ftt library is behaving the way that it should. It may take on the order
of an hour or two to complete. If -a is specified, the alignment tests
are performed as well. Note that this may cause SCSI resets. If the -u
switch is specified, the unload tests are performed at the end. Note that
the tape will have to be reloaded before any other tests can be run.
<P>ftt_slow [-a] [-u] [device]
<P>This tests is all inclusive test suite for the ftt routines. It will
call ftt_fast to perform all of the reasonable quick tests. In addition,
it will test of the slow routines (e.g., erase, write to end of tape).
It may take several hours to run.
<P>ftt_exercise [device]
<P>This test is provided as a convenience for the user who wants to exercise
the device to make sure that it is ok. For example, if a drive is replaced,
the user would want to verify it with this script.
<P>ftt_ansi_prelabel [device] [label]
<P>This script writes ansi label and rewinds tape.
<P>ftt_dump [drive]
<P>This will dump a tape - used in recovering overwritten data tapes (see
See "ftt_dump/undump" on page 49.).
<P>Usage:
<P>ftt_dump <TT><U>&lt;input drive name></U> | ftt_test -f <U>&lt;output
drive name></U></TT>
<P>ftt_run_test [script] [drive]
<P>This script is used to execute <B>ftt_test</B> with data file located
in <TT>$FTT_DIR/ftt_test/scripts</TT> directory.
<P>Usage:
<P>ftt_run_test [script] [drive]
<P>is evaluated to:
<P>ftt_test -f [drive] &lt; $FTT_DIR/ftt_test/scripts/[script].dat<A NAME="fnB4" href="#fn4"></A><A HREF="#fn4" name="fnB4">[5]</A>
<P>ftt_multitest [-s -p] [script] [drive_1] [drive_2]....
<P>Runs the requested script to run sequentially (<B>-s</B>) or parallel
(<B>-p</B>) on listed drives.
<P>15
<BR><!--NewPage-->
<H2>
ftt_suid</H2>

<H3>
Command invocation</H3>
The <B>ftt_suid</B> program which comes with the <B>ftt</B> distribution
is a program which runs to allow various functions which must be run as
root on various platforms to occur. It us generally invoked by the library,
but can be invoked from the command line with the following options:
<UL>
<LI>
ftt_suid <I>opts</I> -c <I>basename</I> -- clear error statistics on the
drive</LI>

<LI>
ftt_suid <I>opts</I> -s <I>basename</I> --print statistics for the drive</LI>

<LI>
ftt_suid <I>opts</I> -b <I>n basename</I> -- set blocksize to <B>n</B>
for the drive</LI>

<LI>
ftt_suid <I>opts</I> -C <I>n basename</I> -- set compression on (<B>n</B>
== 1) or off (<B>n</B> == 0)</LI>

<LI>
ftt_suid <I>opts</I> <B>-d</B> <I>n basename</I> -- set density to <B>n</B>.</LI>
</UL>
Only one of the above forms may be used per command invocation.
<P>In each of the above <I>opts</I> may be <B>-w</B> to open the drive
for writing, (which really only makes a difference for getting statistics
on 8200's) and/or <B>-x</B> which turns on <B>ftt</B> debugging. The command
performs the minimum number of <B>ftt</B> calls to perform the task, as
well as <B>ftt_open</B>, and <B>ftt_close</B>. These are all operations
which require superuser privilege on one or more systems. Currently the
only platform where <B>ftt_suid</B> does not need to be setuid root at
all is on IRIX systems from Silicon Graphics.
<P>In all cases, after performing the requested operation, the values returned
by <B>ftt_get_error()</B> are printed to file descriptor 0.
<P>Note that for the <B>ftt</B> suite to work properly on those systems
which require <B>ftt_suid</B> to be setuid to root, the <B>ftt_suid</B>
executable must be in your command search path when the library is run,
and installed with the correct permissions.
<H3>
Example of use</H3>
To get the current statistics from drive <B>/dev/rmt0</B> the command:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_suid -s /dev/rmt0
</PRE>
would yield the output
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_VENDOR_ID is EXABYTE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_PRODUCT_ID is EXB-8200
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_FIRMWARE is 2600
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_CLEANING_BIT is 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_SENSE_KEY is 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; FTT_TRANS_SENSE_KEY is NO_SENSE
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; - is -
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 0
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Ok
</PRE>
showing the statistics, then the error code and error string. In this case,
the error counters on the Exabyte 8200 would be interpreted as read errors,
since <B>-w</B> was not specified.
<BR><!--NewPage-->
<H2>
Appendix A: System Configuration Issues</H2>
ftt makes very few assumptions about system configuration, however they
are listed below, by platform. ftt attempts to continue and operate as
best it can even when these options are not met, however it may be unable
to determine tape drive type, etc. if these conditions are not met.
<H3>
AIX issues</H3>
The major assumption for <B>AIX</B> systems is that the <B>ftt_suid</B>
executable is installed setuid root. If this is not done, we will be unable
to set density and/or compression, or get statistics.
<H3>
IRIX issues</H3>
The major assumption under <B>IRIX</B> is that the devices under <B>/dev/scsi</B>
exist, those entries under <B>/ dev/scsi</B> which correspond to tape drives
are writable by tape drive users, and that the <I>ds</I> module is built
into the kernel to allow SCSI pass-through.
<P>On <B>IRIX</B> we cannot currently distinguish between Exabyte 8500's
and 8505's, or between DLT4000's and DLT2000's, since the <B>hinv</B> command
lists them identically.
<P>For <B>IRIX</B> we also recommend the following system patches be installed:
<UL>
<LI>
528 - scsi roll up patch for IRIX 5.3 It fixes no direct problems, but
we think it's safer. Challenge and Onyx only.</LI>

<LI>
736 - AN ABOSOLUTE MUST. fixes erroneous request sense data. for wd9 3
machines only. It was formerly patch 308.</LI>

<LI>
742 - Added support for 8505XL on Challenge and Onyx machines</LI>

<LI>
763 - Patch to work around Exabyte bugs. This helps an odd case with 8200s
that are starting to go belly up. If it failed during the "close" command
when writing a filemark, the driver still tried to reposition the drive.
There was goofy 8200 firmware that would get lost at this point, and in
an attempt to recover, the driver would reset the bus.</LI>

<LI>
1283 - This fixes the ghost filemarks that we saw on dlt devices.</LI>
</UL>

<H3>
OSF1 / DEC UNIX issues</H3>
The major assumption for <B>DEC UNIX (OSF1)</B> port is that the <B>ftt_suid</B>
executable is installed setuid root, because the <B>scu</B> command is
used to determine what tape drives are on the system. Even though it would
work to tell <B>ftt</B> that it did <I>not</I> need to be setuid root to
operate on <B>/dev/cam</B>, and to make <B>/dev/cam</B> world writable,
this would raise nasty security issues, since this would also allow all
users direct pass-through access to <I>all</I> SCSI devices on the system.
<P>Note that the software will work without the setuid binary as far as
doing tape I/O, but the software will be unable to identify the drive type
or do SCSI passthrough, so information about tape density names will be
generic, and most statistics will be unavailable.
<H3>
Solaris Issues</H3>
There are a couple of assumptions hidden in the <B>Solaris</B> port, underlying
the fact that we use <B>dmesg</B> to discover what tape drives are on the
system.<SUP>1</SUP>
<UL>
<LI>
The st driver is configured to force-load, so that tape drives are listed
at boot. This consists of adding a line to the <B>/etc/system</B> file
like:</LI>
</UL>
forceload: /drv/st
<UL>
<LI>
Tape devices /dev/rmt<I>n</I> in order correspond to the sequence tape
devices are listed by <B>dmesg.</B></LI>
</UL>
1. It is hoped that in the future a better solution to this problem will
be found
<H3>
A.5 Windows NT</H3>
This system is very different then any UNIX system with the way the tape
device are handled.
<UL>
<LI>
there is only one tape device like \\.\tape<B><I>n</I></B></LI>

<LI>
the type of the tape is unknown</LI>

<LI>
there is no way to set density</LI>

<LI>
only a few drive statistics are provided</LI>
</UL>

<H3>
Linux</H3>

<UL>
<LI>
Linux currently (kernel version 2.0) has a maximum block size of 65536.
This is because e kernel allocates tape buffers at boot time.</LI>

<LI>
Linux device names are allocated at boot time or added later with the "SCSI
add-single-device" command (see chapter 4 of the "SCSI programming HOWTO").
The first drive discovered becomes /dev/st0; the second, /dev/st1; and
etc. This means that device names are not permanently assigned to a tape
drive. This scheme works if you only have one tape drive and ftt supports
the /dev/st style names.</LI>

<LI>
Ftt also supports device names of the form /dev/rmt/tps[0-9]d[1-15][n]
where 0-9 is the SCSI bus, 1-15 is the SCSI id, and n specifies the no
rewind device. The script <B>$FTT_DIR/etc/makescsidev.Linux</B> can make
appropriate special files.</LI>
</UL>

<H3>
General Security issues</H3>
On some platforms, it may not be possible to get the <B>ftt_suid</B> executable
installed as with sufficient permissions. In those situations, you can:
<P>mv ftt_suid ftt_suid.real
<P>cp /bin/true ftt_suid
<P>in the <B>bin</B> directory of the ftt product, and you will not get
errors about the setuid binary -- of course functionality will be missing,
as described in the preceding sections.
<BR><!--NewPage-->
<H2>
Appendix B: Recovering Data from Overwritten 8mm Tapes</H2>

<H3>
Disclaimer</H3>
This appendix is to document personal experience in recovering data from
tapes that have been overwritten. It is not meant to guarantee that this
capability will always be available both in software and hardware.
<H3>
850x Recovery</H3>
The actual problem was that a few valid data tapes were overwritten with
an ANSI volume label at the beginning of the tape. The tapes in question
were 8mm tapes written on an 850x drive in non-compressed, variable block
mode.
<P>When data is written to an 850x drive, a special end of data mark (EOD)
is written after the last data record. When the tapes were overwritten,
they contained two EOD marks: one at the end of the original data, and
one at the end of the volume label. We wanted to skip past this first EOD
and into the original data. Exabyte drives do NOT allow you to skip past
an EOD mark UNLESS the drive is configured to support a directory structure.
This requires special firmware from Exabyte. Note that the 850x documentation
implies that with directory structure support, you can only skip past one
EOD mark. We never tried more than one.
<P>We loaded the special firmware into an 8505 drive and then loaded one
of the overwritten tapes in this drive. We needed a few specialized commands
in the ftt toolkit, so we added ftt_all_scsi<A NAME="fnB5" href="#fn5"></A><A HREF="#fn5" name="fnB5">[6]</A>,
ftt_clear_unrecovered<A NAME="fnB6" href="#fn6"></A><A HREF="#fn6" name="fnB6">[7]</A>,
and ftt_locate.
<P>Using the ftt_test program, we were able to use ftt_locate to position
the tape to a specific logical block in the original data set: For example:
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_open -readonly /dev/rmt/tps0d4
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_rewind
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_locate 1000
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command failed with FTT_EBLANK, expected FTT_SUCCESS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_locate 1200
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; command failed with FTT_EIO, expected FTT_SUCCESS
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_locate 1500
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_locate 1300
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_rewind
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test> ftt_locate 1300
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_test. ftt_close
</PRE>

<H3>
Special Observations:</H3>

<UL>
<LI>
As a precautionary measure, be sure to write protect the tape!</LI>

<LI>
The actual logical block number is dependent on both the original block
size and the amount of data that was overwritten. This is something that
you find by trial and error.</LI>

<LI>
The logical block number is relative to the beginning of tape, ftt_locate
1200 followed by ftt_locate 1500 will position the tape to the 1500th block
from the beginning of tape, not the 2700th.</LI>

<LI>
ftt_locate will fail with a mix of FTT_EIO and FTT_EBLANK errors until
it can sync with the original data.</LI>

<LI>
Sometimes an ftt_locate command would appear to have worked, but the drive
reset itself and rewound. This was particularly true when backspacing records.
Be sure to keep an eye on the drive to see what's happening. You can always
rewind and start again.</LI>

<LI>
As another precautionary measure, once you believe you have found the start
of good data, rewind the tape and use a single ftt_locate to move there.
We found that the drive would sometimes let you backspace with ftt_locate
a little further than forward spacing.</LI>

<LI>
Sometimes, the ftt_locate command would report an FTT_EBUSY error. I never
quite understood this, but if you wait a little while and try again, it
worked. It's as if the raw scsi device driver was already in use.</LI>
</UL>
Once the input tape has been position into the start of good data, the
tape can be copied via your favorite copy process. We tried two ways, both
of which worked: ftt_dump/undump and a simple c program.
<H4>
ftt_dump/undump</H4>
A ftt test program was written to dump the tape and this output was piped
into the output tape:
<P>ftt_dump /<B>dev/rmt/tps0d4 | ftt_test /dev/rmt/tps0d5</B>
<H4>
simple copy program</H4>
ftt provides a VERY simple c program to do the copy. Note that it does
nothing to select the mode of the output tape. It simply uses the default
device, but it does rewind it first. The -i and -o switches define the
input and output devices respectively.
<PRE>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ftt_copy -i /dev/rmt/tps0d4 -o /dev/rmt/tps0d5
</PRE>

<H3>
8200 Recovery</H3>
Unlike newer Exabyte models, Exabyte 8200s do not write this EOD mark.
We have recovered data from 8200s, but that was several years ago (1991?).
One could skip to the first filemark in the original data set and copy
from that point on. However, it was significantly more difficult to recover
data from the first file.
<P>Jim Meadows (meadows@fnal.gov) and Margaret Votava (votava@fnal.gov)
had a test stand setup for such recoveries. It consisted of an mvme133
in a VME crate running pSOS and a Ciprico Rimfire board as the VME->SCSI
adaptor. A PC was connected to the terminal port of the drive with the
overwritten data. Jim would be able to overwrite some memory location in
the drive to convince the heads to spin forward to some arbitrary point.
We then attempted to read. This was procedure was repeated until good data
was found. The Fermi written rimfire routines were used to control the
drives.
<H3>
Other Exabyte Tapes</H3>
According to Exabyte sales representatives, the techniques used to recover
850x tapes will be supported in newer models, e.g. the mammoth drives.
This has not been tested at Fermi.
<H3>
DLT 2000/4000</H3>
At the time of this writing (March 1997), Quantum representatives claim
that there is currently no way to recover overwritten data tapes. They
are working on special firmware to support this, but it is not anticipated
that this firmware will be available to the general public.
<BR><!--NewPage-->
<P><A NAME="fn0" href="#fnB0"></A><A HREF="#fnB0" name="fn0">[1]</A> The
name and usage was changed for version v2_0 to have the same behavior on
UNIX and Windows NT
<P><A NAME="fn1" href="#fnB1"></A><A HREF="#fnB1" name="fn1">[2]</A> Scripts
rate and describe are not ported to WIndows NT and they should executed
directly or using ftt_run_test shell script
<P><A NAME="fn2" href="#fnB2"></A><A HREF="#fnB2" name="fn2">[3]</A> This
shell script is not ported to Windows NT since the is only one tape drive
device
<P><A NAME="fn3" href="#fnB3"></A><A HREF="#fnB3" name="fn3">[4]</A> This
script wasn't ported to Windows NT
<P><A NAME="fn4" href="#fnB4"></A><A HREF="#fnB4" name="fn4">[5]</A> with
the exemption of <B>describe</B> and <B>rate</B> scripts
<P><A NAME="fn5" href="#fnB5"></A><A HREF="#fnB5" name="fn5">[6]</A> Some
device drivers (e.g., IRIX) won't even issue commands on the SCSI bus if
it thinks they will fail. For example, if you read until end of tape, the
driver remembers this and won't even issue future reads to the drive. We
originally thought that we might need to read even though the device driver
thought we shouldn't, so we added ftt_all_scsi. This will force all drive
operations to use the raw SCSI device driver, guaranteeing that the command
would actually be sent to the drive. As it turned out, we didn't need this
feature.
<P><A NAME="fn6" href="#fnB6"></A><A HREF="#fnB6" name="fn6">[7]</A> If
ftt is ever confused about tape position (e.g., a skip filemark command
fails), then it sets an internal flag that prevents any future tape movement.
We believed that while we were looking for good data in the recovery process,
we might need this feature. It's not clear that it was really needed.</UL>

</BODY>
</HTML>
