#!/bin/sh
# bin/$RCSfile$  $Revision$

if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi
#set -u  # force better programming and ability to use check for not set
set +u  # I don't like this, but it is needed for the eval command at bottom

phelp()     { usage="
enstore pnfs is a tool to control, manipulate and query pnfs files.

Here are the user options:

   enstore pnfs tags   directory    lists the tags in the directory

   enstore pnfs library [value]           sets library tag to value (must have correct cwd)
   enstore pnfs file_family [value]       sets file family tag to value (must have correct cwd)
   enstore pnfs file_family_wrapper [value] sets file family wrapper tag to value (must have correct cwd)
   enstore pnfs file_family_width [value] sets library tag to value (must have correct cwd)

   enstore pnfs files volmap-tape   lists all the files on specified tape in volmap

   enstore pnfs xref   file         lists the cross-reference info about the file

   enstore pnfs enstore_state          lists whether enstore is still accepting transfers

End of enstore pnfs help description

"
              echo "$usage"; }

#internal routine only
p_error()   { echo ERROR, Usage: pnfs $1; exit 1; }

#internal routine only
p_cmd()     { echo "\"`dirname $1`/$2(`basename $1`)\"" ; }

#internal routine only
p_use()     { if [ -z "${2-}" ] ; then c=".(use)(1)"; else c=".(use)($2)"; fi
              p_cmd $1 $c ; }

pcat()      { if [ -z "${1-}" ] ; then p_error "cat filename [level]"; fi
              eval cat  `p_use $@` ; }

pxref()     { pcat $1 4 ; }

#internal routine only
pinfo_helper()  { choice=$1
                  c=0
                  echo "$xref" | while read x; do
                    c=`expr $c + 1`
                    if [ $c -gt 9 ] ; then echo "parse-error"; break; fi
                    if [ $c -eq $choice ] ; then echo $x; break; fi
                  done ; }



#internal routine only
# For routines that use an id, I either need to have my cwd in pnfs, or I
#  I need to specify a (fake) path that begins with /pnfs.  Look at mounted
#  file system and return 1st pnfs filesystem - this works for both cases
#  but, I should not use the /pnfs/fs admin root mounted from localhost
p_pnfs()    { df | grep -v localhost | grep  /pnfs/ | sed -e 's%.*/pnfs/%/pnfs/%' -e 's%$%/%' | cut -d"
" -f1; }


pfiles()    { if [ -z "${1-}" ] ; then p_error "files volume_path_in_volmap"; fi
              for i in $1/*; do
	        a=`pnfs cat $i 4`
		pnfsid=`echo $a | awk '{print $7}'`
		filename=`pnfs path $pnfsid`
                if [ $filename != "NO_SUCH_FILE" ]; then
                  ls -l $filename
                else
                  a=`ls -l $map_file`
                  echo $a $filename
                fi
              done; }


#internal routine only
p_tag()     { if [ -z "${2-}" ] ; then dir=`pwd`; else dir=$2; fi
              echo "\"$dir/.(tag)($1)\"" ; }


ptagcat()   { if [ -z "${1-}" ] ; then p_error "tagcat tag"; fi
              echo "$@"
              eval cat  `p_tag $@`; echo "" ; }

ptags()     { if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              for i in `cat "$dir/.(tags)(all)"`; do v=`eval cat '$dir/$i'`; echo $i " = " $v; done ; 
	      for i in `cat "$dir/.(tags)(all)"`; do ls -l $dir/$i; done ; }

ptagecho()  { if [ -z "${1-}" -o  -z "${2-}" ] ; then p_error "tagecho text tagname"; fi
              pt="$1"
              shift 1
              eval echo -n "$pt" \>\| `p_tag $@` ; }

plibrary()  { if [ -z "${1-}" ] ; then
                ptagcat library
              else
                ptagecho "$1" library
              fi; }

pfile_family()
            { if [ -z "${1-}" ] ; then
                ptagcat file_family
              else
                ptagecho "$1" file_family
              fi; }

pfile_family_wrapper()

            { default_wrapper=cpio_odc
	      wrappers=`eval echo "cpio_odc cpio_crc cpio_newc cpio_custom cpio_eurostore"`
	      if [ -z "${1-}" ] ; then
                ptagcat file_family_wrapper
              else
	        matched=0
	        for i in $wrappers; do if [ $1 = $i ]; then matched=1; break; fi; done;
		if [ $matched -ne 0 ]; then ptagecho "$1" file_family_wrapper
		else echo only $wrappers wrappers are allowed
		fi;
              fi; }

pfile_family_width()
            { if [ -z "${1-}" ] ; then
                ptagcat file_family_width
              else
                ptagecho "$1" file_family_width
              fi; }


penstore_state()  
            { disabled="`p_pnfs`.(config)(flags)/disabled" 
              if [ -r "$disabled" ] ; then
	        why=`cat "$disabled"`
		echo "Enstore disabled: $why"
                exit 1
              else
	        echo "Enstore enabled"
		exit 0
              fi; }


if [ -z "${1-}" ] ; then
  cmd="phelp"
else
  cmd=p$1
#    echo "KLG: ${1-}"
  shift
#    echo "KLG: ${1-},"
fi


#eval $cmd $@ # the eval command eats spaces in the positional arguments, so this doesn't work!
eval $cmd \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" \"$6\" \"$7\" \"$8\" \"$9\" # not happy with this, but it works
stat=$?
#if [ $stat -ne 0 ] ; then phelp; fi
exit $stat
