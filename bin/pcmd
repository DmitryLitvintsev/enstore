#!/bin/sh

if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi
#set -u  # force better programming and ability to use check for not set
set +u  # I don't like this, but it is needed for the eval command at bottom

phelp()     { usage="
pcmd is a tool to control, manipulate and query pnfs files.

Commonly used commands are:

   pcmd info   file         lists \"important\" info about the file
       note:  \"eval \`pcmd info file\`\" will set shell variables for the user

   pcmd tags   directory    lists the tags in the directory

   pcmd bfid   file         lists the bit file id of the file
   pcmd parked file         lists the last parked location of the file
   pcmd debug  file         lists the debug info about the file transfer
   pcmd xref   file         lists the cross-reference info about the file

   pcmd ls   file [layer]   does an ls on the named layer in the file

   pcmd {cat|more|less}          file layer     lists the layer of the file
   pcmd {tagcat|tagmore|tagless} tag  directory lists the tag in the directory


Don't use these unless you know what you are doing:

   pcmd echo text file layer   echos text to named layer of the file

   pcmd rm file layer          deletes (clears) named layer of the file

   pcmd cp unixfile file layer copies unix file to named layer of file

   pcmd size file size         sets the size of the file

   pcd tagecho text tagname    echos text to the named tag

   pcmd tagrm tag              removes the tag

   pcmd io file                sets io mode (can't clear it easily)

Don't use these unless you can interpret the results:

   pcmd id        file
   pcmd showid    id
   pcmd const     file
   pcmd nameof    id
   pcmd path      id
   pcmd parent    id
   pcmd counters  file
   pcmd counterN  dbnum (must have cwd in pnfs)
   pcmd cursor    file
   pcmd position  file
   pcmd database  file
   pcmd databaseN dbnum
"
              echo "$usage"; }

#internal routine only
p_cmd()     { echo "\"`dirname $1`/$2(`basename $1`)\"" ; }

#internal routine only
p_use()     { uj="Usage:  p_use filename [container number]"
              if [ -z "${1-}" ] ; then echo $uj; return; fi
              if [ -z "${2-}" ] ; then c=".(use)(1)"; else c=".(use)($2)"; fi
              p_cmd $1 $c ; }

pcat()      { eval cat  `p_use $@` ; }
pmore()     { eval more `p_use $@` ; }
pless()     { eval less `p_use $@` ; }

pbfid()     { pcat $1 1 ; }
pparked()   { pcat $1 2 ; }
pdebug()    { pcat $1 3 ; }
pxref()     { pcat $1 4 ; }

#internal routine only
pinfo_helper()  { choice=$1
                  c=0
                  echo "$xref" | while read x; do
                    c=`expr $c + 1`
                    if [ $c -gt 8 ] ; then echo "parse-error"; break; fi
                    if [ $c -eq $choice ] ; then echo $x; break; fi
                  done ; }

pinfo()     { bfid=`pbfid $@`
              xref=`pxref $@`
              volume="`pinfo_helper 1`"
              location_cooke="`pinfo_helper 2`"
              size="`pinfo_helper 3`"
              file_family="`pinfo_helper 4`"
              orig_name="`pinfo_helper 5`"
              map_file="`pinfo_helper 6`"
              pnfsid_file="`pinfo_helper 7`"
              pnfsid_map="`pinfo_helper 8`"
              filename=`ppath $pnfsid_file`
              if [ `echo $SHELL | grep -c /bash` -ne 0 -o \
                   `echo $SHELL | grep -c /sh`   -ne 0 -o \
                   `echo $SHELL | grep -c /ksh`  -ne 0 -o \
                   `echo $SHELL | grep -c /zsh`  -ne 0  ] ; then
              echo "bfid=\"$bfid\";
volume=\"$volume\";
location_cookie=\"$cookie\";
size=\"$size\";
file_family=\"$file_family\";
filename=\"$filename\";
orig_name=\"$orig_name\";
map_file=\"$map_file\";
pnfsid_file=\"$pnfsid_file\";
pnfsid_map=\"$pnfsid_map\";"
              else
              echo "set bfid=\"$bfid\";
set volume \"$volume\";
set location_cookie \"$cookie\";
set size \"$size\";
set file_family \"$file_family\";
set filename \"$filename\";
set orig_name \"$orig_name\";
set map_file \"$map_file\";
set pnfsid_file \"$pnfsid_file\";
set pnfsid_map \"$pnfsid_map\";"
               fi; }

pls()       { eval ls -alsF `p_use $@` ; }

pecho()     { uj="Usage:  pecho text file [container number]"
              if [ -z "${1-}" -o  -z "${2-}" ] ; then echo $uj; return; fi
              pt="$1"
              shift 1
              eval echo -n "$pt" \>\| `p_use $@` ; }

prm()       { eval echo -n "" \>\| `p_use $@` ; }

pcp()       { uj="Usage:  pcp file pnfsfile [container number]"
              if [ -z "${1-}" -o  -z "${2-}" ] ; then echo $uj; return; fi
              pt="$1"
              shift 1
              eval cp "$pt" `p_use $@` ; }

psize()     { u_j="Usage:  psize filename size";
              if [ -z "${1-}" -o  -z "${2-}" ] ; then echo $uj; return; fi
              eval touch  "\"`dirname $1`/.(fset)(`basename $1`)(size)($2)\"" ; }

pid()       { uj="Usage:  pid file"
              if [ -z "${1-}" ] ; then echo $uj; return; fi
              eval cat  `p_cmd $1 ".(id)"` ; }

pconst()    { uj="Usage:  pid file"
              if [ -z "${1-}" ] ; then echo $uj; return; fi
              eval cat   `p_cmd $1 ".(const)"` ; }

#internal routine only
# For routines that use an id, I either need to have my cwd in pnfs, or I
#  I need to specify a (fake) path that begins with /pnfs.  Look at mounted
#  file system and return 1st pnfs filesystem - this works for both cases
p_pnfs()    { df | grep  /pnfs/ | sed -e 's%.*/pnfs/%/pnfs/%' -e 's%$%/%' | cut -d"
" -f1; }

pshowid()   { u_n="Usage: pshowid id"
              if [ -z "${1-}" ] ; then echo $u_n; return; fi
              eval cat  "\"`p_pnfs`.(showid)($1)\"" ; }

pnameof()   { u_n="Usage: pnameof id"
              if [ -z "${1-}" ] ; then echo $u_n; return; fi
              echo cat  "\"`p_pnfs`.(nameof)($1)\"" 1>&2
              eval cat  "\"`p_pnfs`.(nameof)($1)\"" ; }

pparent()   { u_p="Usage: pnameof id"
              if [ -z "${1-}" ] ; then echo $u_p; return; fi
              echo cat  "\"`p_pnfs`.(parent)($1)\"" 1>&2
              eval cat  "\"`p_pnfs`.(parent)($1)\"" ; }

ppath()     { u_p="Usage: ppath id"
              if [ -z "${1-}" ] ; then echo $u_p; return; fi
              filename=""
              id=$1
              while /bin/true;  do
	        #echo id=$id
		echo `pnameof $id` 1>/dev/null
		f2=`pnameof $id 2>/dev/null`
                if [ $? -ne 0 ] ; then break; fi
		filename=$f2/$filename
		#echo filename=$filename
                #echo filename=`pnameof $id 2>/dev/null`/$filename
                #filename=`pnameof $id 2>/dev/null`/$filename
                if [ $? -ne 0 ] ; then break; fi
                #echo id=`pparent $id`
                id=`pparent $id`
              done
              filename=`echo $filename | sed -e 's/ //g' -e 's%root/fs/usr%pnfs%' -e 's%/$%%'`
              echo $filename
              }

pcounters() { u_p="Usage: pcounters file"
              if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              eval cat  "\"`dirname $dir`/.(get)(counters)\"" ; }

# this doesn't seem right - check it
pcountersN() { u_p="Usage: pcounters file"
              eval cat  "\".(get)(counters)($1)\"" ; }

pcursor()   { u_p="Usage: pcursor file"
              if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              eval cat  "\"`dirname $dir`/.(get)(cursor)\"" ; }

pdatabase() { u_p="Usage: pdatabase file"
              if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              eval cat  "\"`dirname $dir`/.(get)(database)\"" ; }

pdatabaseN() { u_p="Usage: pdatabase dbnum"
              eval cat  "\"`p_pnfs`.(get)(database)($1)\"" ; }

pposition() { u_p="Usage: pposition file"
              if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              eval cat  "\"`dirname $dir`/.(get)(position)\"" ; }

pcursor()   { waste=/tmp/gc-$$
              rm -f $waste
              if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              cat "`dirname $dir`/.(get)(cursor)" >$waste
              if [ $? -ne 0 ] ; then problem "FAILED : Can get .(get)(cursor) " ; return ; fi
              . $waste
              /bin/echo  "dirID=$dirID ; dirPerm=$dirPerm ; mountID=$mountID ;"
              mode=`/bin/echo $dirPerm | awk '{ print substr( $1 , 15, 1 ) }'`
              level=`/bin/echo $dirPerm | awk '{ print substr( $1 , 16 , 1 ) }'`
              /bin/echo "We are at level $level in mode $mode "
              if [ $mode = "2" ] ; then
                /bin/echo "The I/O mode of level 0 is DISABLED "
              else
                /bin/echo "The I/O mode of level 0 is ENABLED "
              fi ; }

pio()       { u_j="Usage:  pio filename";
              if [ -z "${1-}" ] ; then echo $uj; return; fi
              eval touch  "\"`dirname $1`/.(fset)(`basename $1`)(io)\"" ; }


#internal routine only
p_tag()     { uj="Usage: p_tag tagname directory"
              if [ -z "${1-}" ] ; then echo $uj; return; fi
              if [ -z "${2-}" ] ; then dir=`pwd`; else dir=$2; fi
              echo "\"$dir/.(tag)($1)\"" ; }

ptagcat()   { eval cat  `p_tag $@` ; }
ptagmore()  { eval more `p_tag $@` ; }
ptagless()  { eval less `p_tag $@` ; }

#internal routine
ptagdir()   { if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              cat "$dir/.(tags)(all)" ; }

ptags()     { if [ -z "${1-}" ] ; then dir=`pwd`; else dir=$1; fi
              for i in `ptagdir $dir`; do v=`eval cat '$dir/$i'`; echo $i " = " $v; done ; }

ptagecho()  { uj="Usage:  ptagecho text tagname"
              if [ -z "${1-}" -o  -z "${2-}" ] ; then echo $uj; return; fi
              pt="$1"
              shift 1
              eval echo -n "$pt" \>\| `p_tag $@` ; }

ptagrm()    { echo "The attempt to remove a tag results in an unpredictable behavior and may corrupt the entire directory"
              echo "If you insist on doing this, try   eval echo -n \"\" >| `p_tag tagname`" ; }

#debugging routine - space in arguments are being eaten by eval
pdog()      { echo $#
              echo $1
              echo $2
              echo $3;          }

if [ -z "${1-}" ] ; then
  cmd="phelp"
else
  cmd=p$1
  shift
fi


#eval $cmd $@ # the eval command eats spaces in the positional arguments, so this doesn't work!
eval $cmd \"$1\" \"$2\" \"$3\" \"$4\" \"$5\" \"$6\" \"$7\" \"$8\" \"$9\" # not happy with this, but it works
stat=$?
if [ $stat -ne 0 ] ; then phelp; fi
exit $stat
