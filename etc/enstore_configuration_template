#!/usr/bin/env python


# $Id$
'''
Recommended configuration:
host1 : pnfs server
host2: apache web server, configuration_server, log_server, alarm_server, inquisitor,
       event_relay, ratekeeper
host3: media_changer(s), library_manager(s)
host4: postrres DB server, file_clerk, volume_clerk, info_server, accounting_server, drivestat_server

one host per mover with at least 2GB of memory.
You can find more informatiom in Enstore Users Guide"
http://computing.fnal.gov/docs/products/enstore/
'''

# all constants defined here are optional and used just for the
# convenience
# you are free to define your own
KB=1024L
MB=KB*KB
GB=KB*MB
TB=KB*GB
PB=KB*TB
EB=KB*PB

# maximal transfer rates for different types of tape drives
#
ait1_rate =    2.8 * MB
ait2_rate =    9.5 * MB
mam1_rate =    2.8 * MB
mam2_rate =   11.5 * MB
dlt_rate =     5.1 * MB
s9840_rate =  10.5 * MB
s9940_rate =  10.5 * MB
s9940b_rate = 27.0 * MB
lto3_rate =   55.0 * MB
lto4_rate =   70.0 * MB
lto5_rate =  130.0 * MB
t10k_rate =  240.0 * MB
null_rate =   11.5 * MB

# lowest allowed encp version
# compatioble with currens enstore servers
legal_encp_version = 'v3_11'

# frequency of read back CRC checks
# used in movers to randomly check written files. See mover section for more details.
mvr_check_f = 10
b_mvr_check_f = 10
b_mvr_check_1st = 0
lto3_mvr_check_f = 10
lto3_mvr_check_1st = 0

update_interval_in_bound = 2

# minimal and maximal buffer size
# for details see description of mover keys
# in the end of this file
lto3_min_buffer = 64*MB
lto3_max_buffer = 2500*MB
lto3_mvr_check_f = 300
lto3_mvr_check_1st = 0
lto3_dismount_delay = 20

lto4_min_buffer = 64*MB
lto4_max_buffer = 2500*MB
lto4_mvr_check_f = 600
lto4_mvr_check_f_jh = 50
lto4_mvr_check_1st = 0
lto4_dismount_delay = 30
lto4_update_interval = 5

lto5_min_buffer = 64*MB
lto5_max_buffer = 4500*MB
lto5_mvr_check_f = 600
lto5_mvr_check_f_test = 100
lto5_mvr_check_1st = 0
lto5_mvr_check_1st_test = 1
lto5_dismount_delay = 30
lto5_update_interval = 2

t10k_min_buffer = 64*MB
t10k_max_buffer = 4500*MB
t10k_mvr_check_f = 900
t10k_mvr_check_f_test = 100
t10k_mvr_check_1st = 0
t10k_mvr_check_1st_test = 1
t10k_dismount_delay = 30
t10k_update_interval = 2

blank_error_increment = 0

# maximal mover failures and mover consecutive failures
# for details see description of mover keys
# in the end of this file
mvr_max_failures=5
mvr_max_consecutive_failures=3


vol_max_noaccess_cnt=4

# pattern to look in syslog file when FTT_EIO occurs
# for details see description of mover keys
# in the end of this file
low_level_diag_pattern = 'sense|st[0-9]'

# enstore hosts
system_name="mysystem" # replace with system name (no white spaces allowed)
enstore_head_node="host2" # replace with name of your enstore head node running enstore configuration server"
monitoring_and_web=enstore_head_node
enstore_DB="host4" # replace with name of your enstore Database server"
enstore_backup="host5" # replace with name of your enstore server performing database, namespace and other backups"
enstore_library="host3" # replace with name of your library manager server"
#enstore_library_1="server5" # replace with name of your library manager server if needed more than one server"
enstore_pnfs="host1" # name space (pnfs/chimera)
enstore_DB_host=enstore_DB
backup_host=enstore_backup
verify_host=enstore_backup
monitoring_host=monitoring_and_web
web_server_host=monitoring_and_web
log_server_host=monitoring_and_web
alarm_server_host=monitoring_and_web
ratekeeper_host=monitoring_and_web
event_relay_host=monitoring_and_web
inquisitor_host=monitoring_and_web
DB_host=enstore_DB_host
file_clerk_host=enstore_DB_host
volume_clerk_host=enstore_DB_host
info_server_host=enstore_DB_host
accounting_server_host=enstore_DB_host # this can be additional host to spread the load between separate database hosts
drivestat_server_host=accounting_server_host
media_changer_host=enstore_library
library_manager_host=enstore_library
#library_manager_host_1=enstore_library_1

html_dir = "/srv2/enstore/www/web-pages/"
log_dir = "/srv2/enstore/enstore-log"
backup_dir =  "/srv3/enstore/backups"
inventory_dir =	"/srv3/enstore/db-inventory"
httpd_dir = "/srv2/enstore/www/stken"
httpd_dir2 = httpd_dir
ratekeeper_dir = "/srv2/enstore/ratekeeper/"
db_basedir = "/srv0/enstore/databases"
accounting_db_basedir = "/srv6/enstore/databases"
drivestat_db_basedir = accounting_db_basedir

crc_seed = 1

configdict = {}

configdict['namespace']    = {
system_name : {'dbname' : 'chimera',
               'dbhost' :  "localhost",
               'dbport' :  5432,
               'dbuser' : 'enstore' },
}

configdict['encp'] = {'crc_seed':crc_seed}

# known configuration servers
# syntax:
configdict['known_config_servers'] = {system_name  :             # enstore instance system name
                                      (enstore_head_node, # configuration server host
                                       7500),               # configuration server port
				      }



# allowed_down dictionary defining how many times a server is allowed down
# before it is marked with a red ball by the 'enstore system' command. each
# server has a list associated with it that has the followinw format - [number
# of  consecutive times when checked and no alive message rcvd, timeout]
configdict['system'] = { 'allowed_down' : {'log_server' :           [1, 10],
					   'alarm_server' :         [1, 10],
					   'configuration_server' : [1, 10],
					   'file_clerk' :           [1, 10],
					   'inquisitor' :           [3, 30],
					   'volume_clerk' :         [1, 10],
					   'library_manager' :      [2, 20],
					   'accounting_server' :    [3, 20],
					   'drivestat_server' :     [3, 20],
					   'info_server' :          [3, 20],
					   'media_changer' :        [2, 10],
					   'default' :              [1, 20] }}

'''
priority: OPTIONAL. If present specifies the request priority settings for a
Library Manager based on the ticket keys and regular expressions. For details
please contact developer or look in the priority.py code.

configdict['priority'] = {
    '9940.library_manager': # library manager
    {'adminpri':            # administrative (online) priority
     {2:                    # priority
      {'host': 'hal900[24]|damen|walcott|southport', # optional - for requests coming from host
       'uname':'e898',                               # optional - for requests coming from user
       'storage_group':'miniboone',                  # optional - for requests coming from storage group
       'work' : 'write_to_hsm',                      # optional - for work write_to_hsm (read_from_hsm)
       },
      }
     }
    }


----------------------------------------------------------------
discipline: OPTIONAL. If present specifies the restictions set for the request
for a Library Manager based on the ticket keys and regular expressions. For
details please contact developer or look in the discipline.py code.

----------------------------------------------------------------

configdict['discipline'] = {
    '9940.library_manager': # library manager
     {1:                    # 1st restriction
       {'host':"stkendca", # client host for which restrictions apply
       'function':'restrict_host_access', # function to call
       'args':['stkendca',(2,0,0)],     # function arguments
       'action':'ignore'},                # action

      },
     }

'''
# Block sizes for different types ot media in bytes
configdict['blocksizes'] = { '8MM'       : 131072,
		     'DECDLT'    : 131072,
		     '9840'      : 131072,
		     '9940'      : 131072,
		     '9940B'     : 131072,
		     'LTO3'      : 131072,
		     'LTO4'      : 131072,
		     'LTO5'      : 512*KB,
		     'null'      : 131072,
		     'T10000T2'  : 1*MB,
		     }

# alarm when common blank tapes pool is low (OPTIONAL)
#configdict['common_blank_low'] = { 'warning': 50, 'alarm': 10 }

# maximal file size for the following file wrappers
configdict['wrappersizes'] = { 'null' : (100L*GB) - 1,
			       'cern' : long("9"*20),
			       'cpio_odc' : (8L*GB) - 1 }


# domains allowed access to this system
# example:
'''
configdict['domains']      = {
    'invalid_domains' : [],
    'valid_domains'   : ['140.221.183'],
    }
'''
# real
configdict['domains'] = {
'invalid_domains' : [],
'valid_domains'   : [],
}

configdict['crons'] = {
'web_node'        : monitoring_and_web,
'html_dir'        : html_dir,
'log_dir'         : log_dir,
'tmp_dir'         : "/tmp",
'email'           : "system_admin", # put here operation email address
'developer_email' : "developer1, developer2", # put here developers email
'backup_node'     : enstore_backup,
'backup_dir'      : backup_dir,
# Only on the following nodes are the ecron outputs monitored
'monitored_nodes' : [
		enstore_head_node,
		enstore_DB,
		enstore_backup,
		enstore_library,
		enstore_pnfs,
		],
'farmlets_dir'    : "/usr/local/etc/farmlets",
'url_dir'         : "http://web-server.fnal.gov/enstore/", # make it up
'enstore_name'    : "MYen", # make it up
'spool_dir'       : "/srv3/enstore/MigrationSpool", #make_failed_copies
'backup2tape_dir' : "/pnfs/eagle/backups/", # replace with name of backup directory in name space
'copy_ran_file_log_dir'   : "/srv3/enstore/copy_ran_file",
}

# crontab definitions (see Admin Guide for details)
configdict['crontabs'] = {
'log_server'        : {'cronfiles' :
                       ["log_server",
                        "log_html"]},
'web_server'        : {'cronfiles' :
                       ["enstore_plots",
                        "enstore_html",
                        #"inventory.fermi",
                        #"inventory.cms",
                        "inventory_web",
                        "chkcrons",
                        #"tab_flip_watch_stken",
                        "summary_plots",
                        "drives_info",
                        ],
                       'host'      : monitoring_and_web},

'verifying'         : {'cronfiles' :
                       ["copy_ran_file"],
                       'host'      : verify_host},
'pnfs'              : {'cronfiles' :
                       ["delfile",
                        "pnfs_misc",
                        "pnfsFastBackup"],
                       'host'      : enstore_pnfs},
'accounting_server' : {'cronfiles' : ["accounting_db"]},
'drivestat_server'  : {'cronfiles' : ["drivestat_db"]},
'file_clerk'        : {'cronfiles' : ["enstore_db"]},
'databases'         : {'cronfiles' :
                       ["checkdb",
                        "backup",
                        "backup.operation",
                        "inventory",
                        "backup2Tape"],
                       'host'      : enstore_backup},
#'SL8500G1.media_changer' : {'cronfiles' : ["silo_balance.fermi",
#				  "tab_flip_close"]},
}
# inventory configuration
# places for tape inventory
configdict['inventory']    = {
'inventory_dir'		: inventory_dir,
'inventory_tmp_dir'		: "%s/tmp" % (inventory_dir,),
'inventory_cache_dir'	: "%s_cache" % (inventory_dir,),
'inventory_extract_dir'	: "%s/extract" % (inventory_dir,),
'inventory_rcp_dir'		: '%s:%s/tape_inventory' % (monitoring_and_web, html_dir,),
'wpa_states'		: ["full", "readonly"],
'wpa_media_types'		: ["9940", "9940B", "LTO3", "LTO4", "LTO5", "T10000T2"],
'wpa_excluded_libraries'	: ["null1", "disk", "test", "CD-10KCF1T", "CD-10KCG1T", "CD-LTO4F1T", "CD-LTO4G1T", "CD-LTO4GST"],
}

# tape mount limits according to media type
# when mounts exceed the first number, an alarm should be generated
# when it exceeds the second number, enstore ball should be turned red
#
# ignore any media type that is not mentioned
configdict['tape_mount_limit'] = {
'8MM':    (2000, 5000),
'DECDLT': (2000, 5000),
'9840':   (2000, 5000),
'9940':   (2000, 5000),
'9940B':  (2000, 5000),
'LTO3':   (10000, 15000),
'LTO4':   (10000, 15000),
'LTO5':   (10000, 15000),
'T10000T2': (10000, 15000),
}

configdict['pnfs_server'] = {'host':enstore_pnfs,}

# configuration for web service run by httpd
configdict['web_server'] = {
'ServerHost'     : web_server_host,  #name of the host running http server
'User'           : 'enstore',
'Group'          : 'enstore',
'port'           : 80,
'ServerName'     : 'www-stken.fnal.gov', # name of web server
'DocumentRoot'   : "%s/html" % (httpd_dir2,), #top level web directory
'ScoreBoardFile' : "%s/apache_status" % (httpd_dir,), # ScoreBoardFile
'PidFile'        : "%s/adm/httpd.pid" % (httpd_dir,), # full path to httpd pid file
'ErrorLog'       : "%s/adm/error.log" % (httpd_dir,), # full path to httpd error log file
'CustomLog'      : {
'combined' : "%s/adm/access.log" % (httpd_dir,), # full path to combined log file
'referer'  : "%s/adm/referer.log" % (httpd_dir,), #  full path to referer log file
'agent'    : "%s/adm/agent.log" % (httpd_dir,), #  full path to agent log file
},
'ServerRoot'  : '/etc/httpd/' , # location of httpd.conf (e.g. /etc/httpd)
'ScriptAlias' : {
'fake' : '/cgi-bin/', #  e.g. /cgi-bin/
'real' : "%s/cgi-bin/" % (httpd_dir2,), #  real path to cgi scripts
}
}

# configuration for presentation of syspem by inquisitor on web page(s)
configdict['www_server'] = { 'system_tag' : "MYSSYSTEM: Enstore for the Masses", # make up the name
		     'media' : {
				'1' : 'SL8500s at GCC', # make up the dictionary of media changers
				},
		     'inq_ignore' : 1 }

# other links on Status At A Glance web page
'''
configdict['other_saag_links'] = {
'dcache_cd'   : ['CD dCache', 'http://fndca.fnal.gov/'],
'dcache_cdf'  : ['CDF dCache', 'http://cdfdca.fnal.gov/'],
'dcache_cms'  : ['CMS dCache', 'http://cmsdca.fnal.gov/'],
'sfa_hud'     : ['SFA HUD', '/cgi-bin/enstore_sfa_hud_cgi.py'],
}
'''
#########################################################################
# The following items describe Enstore Servers.
#########################################################################
# The Event Relay (ER) is a server that forwards messages based on subscription.
# All the Enstore servers send messages to the ER.
#Any server may "subscribe" to the ER in order to have messages of particular types forwarded to it.

configdict['event_relay'] = {
'host':event_relay_host,
'port':55510,
}
# ratekeeper measures enstore nodes transfer rates and builds graphs
configdict['ratekeeper'] = {
'host'		: ratekeeper_host,		#node ratekeeper is running on
'port'		: 55511,			#port ratekeeper is running on
'norestart'		: 'INQ',
'noupdown'		: 'efb',                        # indicate who made this change
'logname'		: 'RATSRV',		#logname
### The following 5 items can be removed when confidence is high that
### the rate information is going into the accounting DB.
'dir'		: ratekeeper_dir,	#directory to write rates to
'tmp'		: "%s/tmp/" % (ratekeeper_dir,), #temp directory used
'ps'		: '%s/*rates.ps' % (html_dir,),
'jpg'		: '%s/*rates.jpg' % (html_dir,),
'stamp'		: '%s/*rates_stamp.jpg' % (html_dir,),
}

# inquisitor
#The Inquisitor monitors the Enstore servers, obtains information from them,
# and creates reports at regular intervals that can be viewed on the web
configdict['inquisitor'] = {
'host':inquisitor_host,
'port':7505,
'logname':'INQSRV',
'alive_rcv_timeout': 15, # timeout for alive request
'alive_retries':1,       # retires for alive request
'refresh' : 3600,        # refresh time
'html_file':html_dir,    # the path to WWW files
'http_log_file_path':'/enstore/log/',                 # enstore log files - usually sym link to log_file_path from log server
'www_host':'http://%s.fnal.gov' % (inquisitor_host,), # web server host - usually the same as 'host'
'max_encp_lines': 250,                                # number of lines on the transfer page
'user_log_dirs' : {'Node Info'	: '/enstore/nodeinfo.html', # make the key name up
	       'Stken Tape Drives'		: '/enstore/firmware_stat_report.html', # make the key name up
	       'Active Monitor Log'		: '/enstore/active_monitor.html', # make the key name up
	       'Network-At-A-Glance'		: '/enstore/enstore_saag_network.html', # make the key name up
	       'PNFS Export List'		: '/enstore/pnfsExports.html', # make the key name up
	       'FAILED Transfers'		: '/enstore/transfer_failed.txt ', # make the key name up
	       #'Recent SL8500F1 log messages'	: '/enstore/log/SL8500F1-log',
	       'PNFS monitor report'	: '/enstore/%s_pnfs_monitor' % (inquisitor_host,), # make the key name up
	       },
'default_alive_interval': 40,
'default_hung_interval' : 120,
'max_threads' : 200,
}

# monitor server
# echoes messages from monitor_client to fake enstore transfers

configdict['monitor_server'] = {
'html_dir'		: html_dir,
'html_gen_host'	: web_server_host,
'refresh'		: 3600,
'veto_nodes'	: {'rip3': 'not in system my reason'},
'block_size'	: 65536,
'block_count'	: 160,
'default_timeout'	: 3,
}

# backup server
configdict['backup'] = {
'host':backup_host,
'dir':"%s/enstore-backup" % (backup_dir,),
'extract_dir':"%s/check-db-tmp" % (backup_dir,),
'check_db_area':"%s/check-database" % (backup_dir,),
}

# enstore file database location and server configuration
# used by file, volume clerks and info server
# it is better to run them on the same host where this DB server runs.
# The old (and duplicated) db_host and db_port are for backward
# compatibility. Eventually, all should switch to dbhost and dbport
configdict['database'] = {
'dbarea':'%s/enstore-db' % (db_basedir,),        # database directory
'db_dir': '%s/enstore-database' % (db_basedir,), # backup database directory
'jou_dir': '%s/enstore-journal' % (db_basedir,), # journal files directory
'db_host': DB_host,                              # data base host - obsolete, replaced with dbhost
'db_port': 8888,                                 # data base port - obsolete, replaced with dbport
'max_threads' : 50,                              # maximum number of db threads
'dbhost': DB_host,                               # data base host
'dbport': 8888,                                  # data base port
'dbname': 'enstoredb',                           # database name
'dbuser': 'enstore',                             # enstore database account
'dbuser_reader': 'enstore_reader',               # read-only enstore database account
'dbserverowner': 'products',                     # owner of enstore database server process
}

# operation db
configdict['operation_db'] = {
'dbhost': accounting_server_host,
'dbport': 8800,
'dbname': 'operation',
'dbuser': 'enstore',
}

# file clerk
# The File Clerk (FC) is a server that tracks files in the system.
# It manages a database of metadata for each data file in the Enstore system.
# The metadata includes the file's name, its unique identifier (the bit file ID, or bfid,
# that the FC itself assigns to each new file ), the volume on which it resides, and so on.
configdict['file_clerk'] = {
'host':file_clerk_host,
'port':7501,
'logname':'FILSRV',
'norestart':'INQ',
'brand':'CDMS', # brand for bit file id, make it up
}

# volume clerk
# The Volume Clerk (VC) is a server that stores and administers storage volume (tape) information.
configdict['volume_clerk'] = {
'host':volume_clerk_host,
'port':7502,
'logname':'VOLSRV',
'norestart':'INQ',
'max_noaccess_cnt' : vol_max_noaccess_cnt, # maximum number of volumes squentially set to noaccess to mark the library broken
}


# info server is the read-only server that is supposed to ease a load on file and volume clerks
configdict['info_server'] = {
'host': info_server_host,
'port': 7777,
'logname': 'INFSRV',
'norestart':'INQ',
'dbhost': DB_host,
'dbname': 'enstoredb',
}

# accounting server
#maintains statistical information on a running system.
configdict['accounting_server'] = {
'host': accounting_server_host,
'port': 7580,
'logname': 'ACCSRV',
'norestart':'INQ',
'dbhost': accounting_server_host,
'dbport': 8800,
'dbname': 'accounting',
'dbuser': 'enstore',                                     # database account
'dbuser_reader': 'enstore_reader',
'dbserverowner': 'products',                             # owner of database server process
'dbarea': '%s/accounting-db' % (accounting_db_basedir,), # database directory
}

# Maintains tape drive statistics
configdict['drivestat_server'] = {
'host': drivestat_server_host,
'port': 7590,
'logname': 'DRSSRV',
'norestart':'INQ',
'dbhost': drivestat_server_host,
'dbport': 8802,
'dbname': 'drivestat',
'dbuser': 'enstore',
'dbuser_reader': 'enstore_reader',
'dbserverowner': 'products',
'dbarea': '%s/drivestat-db' % (drivestat_db_basedir,),
}

# alarm server
# The Alarm Server maintains a record of alarms raised by other servers,
# and creates a report available online
configdict['alarm_server'] = {
'host':alarm_server_host,
'port':7503,
'logname':'ALMSRV',
'norestart':'INQ',
'alarm_actions' : {'C' : [['send_mail', '*',
		       {'SG'  : 'SG_oper@mail.dom', # make up Storage Group and its operator
			}
		       ],]},
}

# log server
# The Log Server receives messages from enstore components and logs them into
# formatted log files available online
configdict['log_server'] = {
'host':log_server_host,
'port':7504,
'norestart':'INQ',
'msg_type_logs': {'MSG_TYPE=MC_LOAD_REQ'  : 'MOUNTS-', # separate files extracted from the log file based on the MSG_TYPE
	      'MSG_TYPE=MC_LOAD_DONE' : 'MOUNTS-',
	      'MSG_TYPE=ENCP_XFER'    : 'ENCPS-',
	      'MSG_TYPE=EVENT_RELAY'  : 'EVRLY-',
	      'MSG_TYPE=ADD_TO_LMQ'   : 'LMQADDS-'},
'log_file_path' : log_dir, # where the log files go
}


#####################################
# null library example configuration
#####################################
# library manager
configdict['null.library_manager']     =  {
    'host':library_manager_host,
    'port':7511,
    'mover_port': 7712, # movers interact with library manager on this port
    'encp_port':7713,   # encp client interact with library manager on this port
    'logname':'NULLBM',
    'norestart':'INQ',
    'noupdown':'PUT_SOMETHING_HERE',
    'max_encp_retries':3, # maximum number of encp re-tries
    'max_file_size':(8L*GB) - 1, # maximum allowed file size
    'suspect_volume_expiration_time':24*3600, # suspect volume will be removed from suspect list after this time expires
    'legal_encp_version':legal_encp_version,
    'max_requests':25000, # maximium number of requests in the queue (all excess requests will be silently dropped"
    'use_raw_input': 1,   # Use buffer to pull out requests from UDP buffer as fast as possible.
    }

# media changer
configdict['null.media_changer'] = {
    'host':media_changer_host,
    'port':7520,
    'logname':'NUL1MC',
    'type':'RDD_MediaLoader', # media changer type for null media changer
    'norestart':'INQ',
    'noupdown':'PUT_SOMETHING_HERE',
    'inq_ignore':'PUT_SOMETHING_HERE',
    }

# mover(s)
configdict['null01.mover'] = {
    'host':media_changer_host,
    'data_ip':media_changer_host,
    'port':7538,
    'logname':'NUL01MV',
    'norestart':'INQ',
    'noupdown':'PUT_SOMETHING_HERE',
    'max_buffer':100*MB,                   # maximum amount of memory to allocate for buffering (recommended not less than 1GB)
    'library':'null.library_manager',      # associated library manager
    'device':'/dev/null',                  # pathname to the UNIX (tape) device
    'driver':'NullDriver',                 # Low lewel media driver ('FTTDriver' for tape, 'NullDriver' for null mover, DiskDriver for disk)
    'mc_device':'-1',                      # media changer device as declared in the robot
    'media_changer':'null.media_changer',  # associated media changer
    'update_interval':2,                   # interval for the mover to ask LM for the work.
    'max_dismount_delay':30,               # maximum dismount delay that can be set for this mover
    'dismount_delay':10,                   # delayed dismount value to use when none specified by the client. Set to negative value to get "infinite" dismount delay

    }

# add more null movers here
#####################################
# end null library example configuration
#####################################

#####################################
# LTO4 library example configuration
# with IBM 3584 media changer using
# smc CLI
#####################################
# library manager
configdict['IBM_3584_LTO4.library_manager'] = {
'host':library_manager_host,
'port':8541,
'logname':'LTO4LM',
'norestart':'INQ',
'max_encp_retries':3,                             # maximum number of encp re-tries
'max_file_size':(800L*GB) - 1,                    # maximum allowed file size
'min_file_size':300*MB,                           # minimum file size
'storage_group_limits':{'cms' : 25,               # Minimal amount of drives that can be used by a certain storage group (fair share) when different storage groups compete for tape drives
		    },
'CleanTapeVolumeFamily': 'CLEAN.CleanTapeFileFamily.noWrapper', # volume family for cleaning tapes
'suspect_volume_expiration_time':3600*24,                       # remove entry from suspect volume list after this period of time
'max_requests':15000,                                           # Maximal amount of requests in the queue. The rest will be ignored (and retried later by encp)
'legal_encp_version':legal_encp_version,
'restrict_access_in_bound': True,                               # discipline applies to volumes in BOUND state
'mover_port': 7006,                                             # Movers communucate with library manager on this port if specified.
'encp_port':7007,                                               # Clents (encp) communucate with library manager on this port if specified.
'use_raw_input': 1,                                             # Use buffer to pull out requests from UDP buffer as fast as possible.
'use_threads':False,                                            # Use separate threads for every mover request (shows problems during testing, avoid setting to True).
}

#IBM 3584 media changer
configdict['IBM_SMC.media_changer'] = {
    'host': enstore_library,
    'port':7524,
    'logname':'IBMMC ',
    'type':'IBM_3584_MediaLoader',               # type of media changer
    'rmchost':'tps008',                          # host where smc runs
    'device':'/dev/sg6',                         # media loader device
    'norestart':'INQ',
    'max_work':4,                                # maximal number of simultaneous requests
    'tape_library':"IBM 3500 in this building",  # if present, suplies a name to the tape library (robot) for reporting.
}

# mover(s)
configdict['IBM_SMC00.mover'] = {
        'host':'mover_host1',
        'data_ip':'mover_host1_0', # if present provides a host name (or IP for data transfer).
        'port':7590,
        'statistics_path': '/tmp/enstore/enstore/IBM00MV.stat', # path to the statistics file
        'logname':'IBM00MV',
        #'norestart':'INQ',
        'max_consecutive_failures': mvr_max_consecutive_failures, # number of any consecutive errors after which the mover goes OFFLINE
        'max_failures': mvr_max_failures, # Mover will go OFFLINE if this many transfers fail within failure_interval
        'compression':0,                  # 0 means no compression. Everything else means use the drive compression (default: None - use the drive compression). Set this key to 0!!!
        'check_written_file':lto4_mvr_check_f, # if greater than 0, then randomly check files written using this number as the mean (default value:0 - don't check)
        'check_first_written_file':lto4_mvr_check_1st, # Reread and check CRC on a first write after a tape mount
        'min_buffer':lto4_min_buffer, # minimum amount of memory to allocate for buffering when transferring data
        'max_buffer':lto4_max_buffer, # maximum amount of memory to allocate for buffering (recommended not less than 1GB)
        'max_rate': lto4_rate, # maximum sustained transfer rate for writes. Used to calculate optimal buffer size. Recommended to set to the max. rate of the drive
        'mount_delay':15,    # seconds to wait after media changer mount completes, before trying to open device. Default is 15 for FTT driver, 0 for NULL driver
        'update_interval':5, # interval for the mover to ask LM for the work. Recommended value 5 s)
        'update_interval_in_bound':  update_interval_in_bound, # update inteval in BOUND state (when tape is mounted).
        'single_filemark':1,   # if not 0 write single file mark (Default value - 0 - write 2 filemarks)
        'library':'IBM_3584_LTO4.library_manager', # library(ies) that this mover serve
        'device':'/dev/rmt/tps3d0n', # pathname to the UNIX tape device
        'driver':'FTTDriver', # low lewel media driver ('FTTDriver' for tape)
        'mc_device':'0',      # tape drive media changer device as declared in the robot
        'media_changer':'IBM_SMC.media_changer.media_changer', # media changer serving this mover
        'syslog_entry':low_level_diag_pattern, # expression to match in the syslog for the low level failure diagnostics
        'media_type':'LTO4', # media type used for the mover. Recommended to set to the type of the media
        'max_time_in_state':1200, # maximum time for a mover to be in any transfer state (other than IDLE or ACTIVE)
        'send_stats':1,           # send tape drive statistics to the drivestat Data Base (defaul value 1, which means "send")
        'dismount_delay': lto4_dismount_delay, # delayed dismount value to use when none specified by the client. Set to negative value to get "infinite" dismount delay
}

# add more movers if needed

#####################################
# END LTO4 library example configuration
# with IBM 3584 media changer using
# smc CLI
#####################################



#####################################
# LTO4 library example configuration
# with IBM 3584 media changer using
# mtx CLI
#####################################
# library manager
configdict['IBM_3584_LTO4MTX.library_manager'] = {
'host':library_manager_host,
'port':8541,
'logname':'LTO4MTXLM',
'norestart':'INQ',
'max_encp_retries':3,                             # maximum number of encp re-tries
'max_file_size':(800L*GB) - 1,                    # maximum allowed file size
'min_file_size':300*MB,                           # minimum file size
'storage_group_limits':{'cms' : 25,               # Minimal amount of drives that can be used by a certain storage group (fair share) when different storage groups compete for tape drives
		    },
'CleanTapeVolumeFamily': 'CLEAN.CleanTapeFileFamily.noWrapper', # volume family for cleaning tapes
'suspect_volume_expiration_time':3600*24,                       # remove entry from suspect volume list after this period of time
'max_requests':15000,                                           # Maximal amount of requests in the queue. The rest will be ignored (and retried later by encp)
'legal_encp_version':legal_encp_version,
'restrict_access_in_bound': True,                               # discipline applies to volumes in BOUND state
'mover_port': 7006,                                             # Movers communucate with library manager on this port if specified.
'encp_port':7007,                                               # Clents (encp) communucate with library manager on this port if specified.
'use_raw_input': 1,                                             # Use buffer to pull out requests from UDP buffer as fast as possible.
'use_threads':False,                                            # Use separate threads for every mover request (shows problems during testing, avoid setting to True).
}


#IBM 3584 media changer (using mtx)
configdict['IBM_MTX.media_changer'] = {
    'host': enstore_library,
    'port':7524,
    'logname':'IBM_MTXMC ',
    'type':'MTX_MediaLoader',               # type of media changer
    'device_name':'/dev/sg6',               # media loader device
    'norestart':'INQ',
    'max_work':4,                                # maximal number of simultaneous requests
    'tape_library':"IBM 3500 in this building",  # if present, suplies a name to the tape library (robot) for reporting.
    'status_timeout':10, # maximum wait time for status command reply
    'mount_timeout':180, # maximum wait time for mount/dismolunt command reply
}

# mover(x)
configdict['IBM_MTX00.mover'] = {
        'host':'mover_host2',
        'data_ip':'mover_host2_0', # if present provides a host name (or IP for data transfer).
        'port':7590,
        'statistics_path': '/tmp/enstore/enstore/IBM_MTX00MV.stat', # path to the statistics file
        'logname':'IBMMTX00MV',
        #'norestart':'INQ',
        'max_consecutive_failures': mvr_max_consecutive_failures, # number of any consecutive errors after which the mover goes OFFLINE
        'max_failures': mvr_max_failures, # Mover will go OFFLINE if this many transfers fail within failure_interval
        'compression':0,                  # 0 means no compression. Everything else means use the drive compression (default: None - use the drive compression). Set this key to 0!!!
        'check_written_file':lto4_mvr_check_f, # if greater than 0, then randomly check files written using this number as the mean (default value:0 - don't check)
        'check_first_written_file':lto4_mvr_check_1st, # Reread and check CRC on a first write after a tape mount
        'min_buffer':lto4_min_buffer, # minimum amount of memory to allocate for buffering when transferring data
        'max_buffer':lto4_max_buffer, # maximum amount of memory to allocate for buffering (recommended not less than 1GB)
        'max_rate': lto4_rate, # maximum sustained transfer rate for writes. Used to calculate optimal buffer size. Recommended to set to the max. rate of the drive
        'mount_delay':15,    # seconds to wait after media changer mount completes, before trying to open device. Default is 15 for FTT driver, 0 for NULL driver
        'update_interval':5, # interval for the mover to ask LM for the work. Recommended value 5 s)
        'update_interval_in_bound':  update_interval_in_bound, # update inteval in BOUND state (when tape is mounted).
        'single_filemark':1,   # if not 0 write single file mark (Default value - 0 - write 2 filemarks)
        'library':'IBM_3584_LTO4MTX.library_manager', # library(ies) that this mover serve
        'device':'/dev/rmt/tps4d1n', # pathname to the UNIX tape device
        'driver':'FTTDriver', # low lewel media driver ('FTTDriver' for tape)
        'mc_device':'0',      # tape drive media changer device as declared in the robot
        'media_changer':'IBM_MTX.media_changer', # media changer serving this mover
        'syslog_entry':low_level_diag_pattern, # expression to match in the syslog for the low level failure diagnostics
        'media_type':'LTO4', # media type used for the mover. Recommended to set to the type of the media
        'max_time_in_state':1200, # maximum time for a mover to be in any transfer state (other than IDLE or ACTIVE)
        'send_stats':1,           # send tape drive statistics to the drivestat Data Base (defaul value 1, which means "send")
        'dismount_delay': lto4_dismount_delay, # delayed dismount value to use when none specified by the client. Set to negative value to get "infinite" dismount delay
}

# add more movers if needed

#####################################
# END LTO4 library example configuration
# with IBM 3584 media changer using
# mtx CLI
#####################################



#####################################
# T10000C library example configuration
# with IBM 3584 media changer using
# SL8500 robot with ACSLS controller
#####################################
# library manager
configdict['10KCG1.library_manager'] = {
'host':library_manager_host,
'port':8546,
'logname':'10KCG1LM',
'norestart':'INQ',
'max_encp_retries':3,
'max_file_size':(5000L*GB) - 1,
'min_file_size':300*MB,
'max_suspect_movers':3,
'max_requests':15000,
'restrict_access_in_bound': True,
'CleanTapeVolumeFamily': 'CLEAN.CleanTapeFileFamily.noWrapper',
'suspect_volume_expiration_time':3600*24,
'legal_encp_version':legal_encp_version,
'blank_error_increment': blank_error_increment,
'mover_port': 7020,
'encp_port':7021,
'use_threads':False,
'use_raw_input': 1,
}


# STK media changer
configdict['SL8500.media_changer'] = {
'host':media_changer_host,
'port':7508,
'logname':'SL8500G1MC',
'type':'STK_MediaLoader',
'norestart':'INQ',
'max_work':6,
'acls_host':'acslshost', # ACSLS controller host
'acls_uname':'acsss',    # ACSLS user name
'DriveCleanTime':{'LTO3':[60,1],
	      'LTO4':[60,1],
	      'T10000T2':[60,1],
	      },
'tape_library':"GCC StreamLine 8500",
}

# mover(s)
configdict['10KC_001.mover'] = {
'host':'mvr001',
'data_ip':'mvr001',
'port':7903,
'logname':'10KC_001MV',
'statistics_path':'/tmp/enstore/enstore/10KC_001.stat',
'norestart':'INQ',
'max_consecutive_failures': mvr_max_consecutive_failures,
'max_failures': mvr_max_failures,
'compression':0,
'check_written_file':t10k_mvr_check_f,
'check_first_written_file':t10k_mvr_check_1st,
'min_buffer':t10k_min_buffer,
'max_buffer':t10k_max_buffer,
'max_rate': t10k_rate,
'mount_delay':15,
'update_interval':t10k_update_interval,
'update_interval_in_bound' : update_interval_in_bound,
'library':'10KCG1.library_manager',
'device':'/dev/rmt/tps4d0n',
'driver':'FTTDriver',
'mc_device':'0,0,1,0',
'media_changer':'SL8500.media_changer',
'do_cleaning':'No',
'syslog_entry':low_level_diag_pattern,
'max_time_in_state':1200,
'send_stats':1,
'dismount_delay': t10k_dismount_delay,
'single_filemark': 1,
}
# add more movers if needed

#####################################
# END T10000C library example configuration
# with IBM 3584 media changer using
# SL8500 robot with ACSLS controller
#####################################

# AML2 media changer
'''
configdict['aml2r1.media_changer']   = { 'host':'stkensrv4',
                                         'port':7521,
                                         'logname':'AML2R1',
					 'type':'AML2_MediaLoader',
                                         'norestart':'INQ',
					 'RobotArm':'R1',
                                         'IdleTimeHome':30000000,
					 'DriveCleanTime':{'DE':[60,1],'DC':[60,1],'DM':[60,1],'D3':[120,2]},
					 'IOBoxMedia':{'ACI_8MM':['E01','E08'],'ACI_LTO':['E03','E05','E06'],'ACI_DECDLT':['E02','E04','E07']},
					 }
'''

"""


MOVER KEYS

These are all the keys that the mover cares about:

host (string) REQUIRED

port (int) REQUIRED

logname (string) OPTIONAL - defaults to mover name

do_eject (string) OPTIONAL - defaults to 'yes', override by setting
		  "no" or "No" (or anything starting with N or n)

do_cleaning (string) OPTIONAL - defaults to 'yes', override by setting
		     "no" or "No" (or anything starting with N or n)
		     This only controls automatic cleaning.  enstore mov --clean-drive
		     will always work, whether this is set or not.

mc_device (string) not needed for NULL movers; required otherwise

min_buffer (int)  OPTIONAL minimum amount of memory to allocate for
		  buffering - defaults to 8MB

max_buffer (int)  OPTIONAL maximum amount of memory to allocate for
		  buffering - defaults to 64MB

max_rate (float) OPTIONAL maximum sustained transfer rate for writes
		 This is used to calculate optimal buffer size.  It does not need to
		 be exact.

device (string) REQUIRED pathname to the UNIX tape device
		for NULL movers make this /dev/null

dismount_delay (int) OPTIONAL delayed dismount value to use when none
		     specified by the client. Default is 60 seconds.
		     Set to negative value to get "infinite" dismount
		     delay.

mount_delay (int) OPTIONAL number of seconds to wait after media
		  changer mount completes, before trying to open
		  device. Default is 15 for FTT driver, 0 for NULL
		  driver

max_dismount_delay: (int s) OPTIONAL maximal dismount delay that can be set for this mover.
			    Default 600 seconds

library (string or list):  REQUIRED.  Who are we working for?  One or
			   more library manager names.

driver (string): REQUIRED.  Currently must be 'FTTDriver' or
		 'NullDriver', or else mover will complain at startup.
		 If we need a disk mover, this would be easy to hack
		 together; doesn't seem too useful though.

max_consecutive_failures: type int, default 2
			  Mover will declare itself "broken" if this
			  many successive transfers fail, and the
			  error was not ENCP_GONE

max_failures: type int, default 3
	      Mover will declare itself "broken" if this many
	      transfers fail within failure_interval (see below).
	      Again, ENCP_GONE errors do not count

failure_interval: type int, default 3600 (one hour)
		  Interval for above.

send_stats: OPTIONAL if present (can be set to 1) send drive statistics to the drivestat Data Base

type: (string) OPTIONAL type of the mover ('','Mover','DiskMover') specifies the type of mover

ip_map: (string) OPTIONAL ip map of the mover node. Used only in Disk Mover to create a volume name

media_type: (string) OPTIONAL media type used for the mover

log_state: (int) OPTIONAL if set log the state of the mover processes

syslog_entry: (string) OPTIONAL expression to match in the syslog for the low level failure diagnostics

restart_on_error: (int) restart mover if it went to the ERROR state. Default - not restart

connect_timeout (sec) TO for mover connection to encp. Default - 15 s

connect_retries (int) number of connect retries. Default 4

update_interval: (int s) OPTIONAL interval for the mover to ask LM for the work. Default 15 s

single_filemark: (int) OPTIONAL if not 0 write single file mark. Default 0 - write 2 fm

check_written_file: (int) OPTIONAL if more than 0 randomly check written file using randomization of
			  this number. Default 0 - no check. 1 - check every written file.

max_time_in_state: (int s) OPTIONAL time in state after which alarm will be raised. Default 600 s

max_in_state_cnt: (int) OPTIONAL if this counter expires Mover errors out with Mover stuck message.
			Default 3

statistics_path: (string) OPTIONAL If specified write the last statistics to the file statistics_path.
			  Default None

compression: (int) OPTIONAL 0 means no compression. Everything else means use the drive compression.
		   Default None - use the drive compression

get_remaining_from_stats: OPTIONAL get remaining bytes info from drive.

include_thread_name: OPTIONAL thread name will be added to the end of log message.

"""

