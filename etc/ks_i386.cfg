# Kickstart file written by Michael Zalokar & Terry Jones for Enstore.
# $Id$
#
install
lang en_US.UTF-8
langsupport --default=en_US.UTF-8 en_US.UTF-8
keyboard us
rootpw --iscrypted $1$
firewall --disabled
selinux --disabled
%include /tmp/network-include
nfs --server=linux.fnal.gov --dir=/export/linux/lts44/i386
authconfig --enableshadow --enablemd5 --enablekrb5 --krb5realm FNAL.GOV --krb5kdc krb-fnal-1.fnal.gov:88,krb-fnal-2.fnal.gov:88,krb-fnal-3.fnal.gov:88,krb-fnal-4.fnal.gov:88,krb-fnal-5.fnal.gov:88 --krb5adminserver krb-fnal-admin.fnal.gov
timezone America/Chicago
bootloader --location=mbr
# The following is the partition information you requested
# Note that any partitions you deleted are not expressed
# here so unless you clear all partitions first, this is
# not guaranteed to work
%include /tmp/part-include

%packages
@ editors
@ yum
@ legacy-software-development
@ kernel-development
@ upsupdbootstrap
@ fermi-kerberos
@ development-tools
@ genericfarm
e2fsprogs
e2fsprogs-devel
sysstat
pam_krb5
grub
krbafs
krb5-libs
kernel
kernel-smp
dosfstools
OpenIPMI

%pre
#
# Make the directory where we will locally save the personality of the node.
# This way the kickstart.log will have a home.
#
mkdir -p /tmp/save

%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#
#
((
#
# Make the directory where we will locally save the personality of the node.
#
echo mkdir -p /tmp/save
mkdir -p /tmp/save
#
# Make the directory where we will remotely save the personality of the node.
#
echo mkdir -p /mnt/tmp
mkdir -p /mnt/tmp
#
# Mount the existing root directory on the node.
#
root_sysimage_count=0
root_sysimage=''
for t in hd sd; do
  for d in a b c d e f g h; do
    for i in 1 2 3 4 5 6 7 8 9; do

	#
	# If we found a disk labeled "/diska" or "/diskc"
	#
	label=`tune2fs -l /dev/$t$d$i | grep "Filesystem volume name:" | cut -c 24-`
	#This is a lazy way to remove whitespace.
	label=`echo $label`

	echo "$label is on /dev/$t$d$i"

	if [ "$label" == "/diska" ]; then
	     echo /dev/$t$d$i > /tmp/diska
	fi
	if [ "$label" == "/diskb" ]; then
	     echo /dev/$t$d$i > /tmp/diskb
	fi
	if [ "$label" == "/diskc" ]; then
	     echo /dev/$t$d$i > /tmp/diskc
	fi

	mount /dev/$t$d$i /mnt/tmp
	rtn1=$?
	# Check not just /dev/hda but also /dev/hda1.  CDROMs will show
	# up with /dev/hdc type names, but will not have any corresponding
	# /dev/hdc1, /dev/hdc2, etc devices.  This should just let disks
	# through (both IDE and SCSI) but exclude CDROMs.
	ls -l /dev/$t$d /dev/${t}${d}1
	rtn2=$?
	if [ "$rtn1" -eq "0" -a "$rtn2" -eq "0" ]; then
	   #Set this here for the case of a blank disk.
	   if [ -z "$root_sysimage" ]; then
	      root_sysimage="/dev/$t$d$i"
	   fi

	   if [ -d /mnt/tmp/etc -o -d /mnt/tmp/usr ]; then
	      echo "Found root file system at device /dev/$t$d$i."
	      root_sysimage="/dev/$t$d$i"
	      let "root_sysimage_count = $root_sysimage_count + 1"
	   fi
	elif [ "$rtn2" -eq "0" ]; then
	   #Set this here for the case of a blank disk.
	   if [ -z "$root_sysimage" ]; then
	      root_sysimage="/dev/$t$d$i"
	   fi
	fi
	if [ "$rtn1" ]; then
	   umount /mnt/tmp
	fi
    done
  done
done
#
# Write out the include file that will contain the disk "part"ition
# information.  Also, mount the disk to use.
#
if [ "$root_sysimage_count" -eq "1" -a -n "$root_sysimage" ]; then
   mount $root_sysimage /mnt/tmp
   which_disk=`echo $root_sysimage | cut -c 6-8`
elif [ "$root_sysimage_count" -eq "0" -a -n "$root_sysimage" ]; then
   mount $root_sysimage /mnt/tmp
   which_disk=`echo $root_sysimage | cut -c 6-8`
elif [ "$root_sysimage_count" -eq "0" ]; then
   abort_install "No sysimage found.  Aborting install."
else
   abort_install "Too many sysimages found.  Aborting install."
fi
if [ -n "$which_disk" ]; then
   echo "part /dos --onpart=${which_disk}1 --noformat" >> /tmp/part-include
   echo "part swap --onpart=${which_disk}2" >> /tmp/part-include
   echo "part /  --onpart=${which_disk}3" >> /tmp/part-include
   echo "part /scratch --onpart=${which_disk}5" >> /tmp/part-include

   echo /dev/$which_disk >> /tmp/which_disk
else
   abort_install "System disk not found.  Aborting install."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
#
# copyit will be removed to test dead start mover install.
#
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	#if [ ! -f "$1" -a ! -d "$1" ]; then
	#	return 2;
	#fi

	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	abort_install "Unable to backup file $1.  Aborting install."

	return 1; # Not reached.
}
#
#
((
#
# Record what got copied.
#
echo "What got copied."
ls -lh /tmp/save

) 2>&1 ) | tee -a /tmp/save/kickstart.log

#+++++++++++++++++++++++copyit removal+++++++++++++++++++=
##########################################################

%pre
#
# Determine the type of install, Edit heavily
##########################################################
#
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
get_cluster ( )
{
echo "222222222222222" >> /tmp/save/kickstart.log
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			;;
		cdfen*)
			system=cdfen
			;;
		d0en*)
			system=d0en
			;;
		gccen*)
			system=gccen
			;;
		*)
			system=""
			;;
	esac

    fi

echo "33333 $system 33333" >> /tmp/save/kickstart.log
    echo $system
}

get_type ( )
{
echo "444444444444444444" >> /tmp/save/kickstart.log
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $1 | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $1 | cut -c 5-`
			;;
		gccen*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			;;
		dm*)
			type=dm
			;;
		load*)
			type=""
			;;
		*)
			type=""
			;;
	esac
    fi

echo "55555555555555555" >> /tmp/save/kickstart.log
    echo $type
}

get_number ( )
{
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $1 | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $1 | cut -c 5-`
			;;
		gccen*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		dm*)
			type=dm
			number=`echo $rest | cut -c 3-`
			;;
		load*)
			type=""
			number=""
			;;
		*)
			type=""
			number=""
			;;
	esac
    fi

    echo $number
}
#
#
((
#
#
echo "  Determining hostname information."
#
# parse the host name
#
DOMAIN=".fnal.gov"
hostname1=`grep HOSTNAME /tmp/netinfo | cut -c 10- | cut -f 1 -d "."`
ip1=`grep IPADDR /tmp/netinfo | cut -c 8-`
hostname2=`grep HOSTNAME /tmp/save/network | cut -c 10- | cut -f 1 -d "."`
ip2=`grep IPADDR /tmp/save/ifcfg-eth0 | cut -c 8-`

echo "hostname debugging" >> /tmp/save/test.log
echo "hostname1:" "$hostname1" >> /tmp/save/test.log
echo "cluster of hostname1:" `get_cluster $hostname1` >> /tmp/save/test.log
echo "type of hostname1:" `get_type $hostname1` >> /tmp/save/test.log
echo "number of hostname1:" `get_number $hostname1` >> /tmp/save/test.log
echo "hostname2:" "$hostname2" >> /tmp/save/test.log
echo "cluster of hostname2:" `get_cluster $hostname2` >> /tmp/save/test.log
echo "type of hostname2:" `get_type $hostname2` >> /tmp/save/test.log
echo "number of hostname2:" `get_number $hostname2` >> /tmp/save/test.log

#Search in the order of the:
# 1) The ip that the node was told to use (by either the kickstart or
#    overridden by the user at the install boot prompt).
# 2) The contents of the pre-existing /etc/sysconfig/network file.
echo "1111111111111111" >> /tmp/save/kickstart.log
if [ -n `get_cluster $hostname1` -a -n `get_type $hostname1` ]; then
echo "666666666666666" >> /tmp/save/kickstart.log
   #If the contents of /tmp/netinfo have the real hostname (because
   # the user specified one on the kickstart command line), then use it.
   # What this really means is that if the $hostname1 is a *load.fnal.gov
   # name we will NOT take this branch.

   echo "$hostname1" >> /tmp/save/kickstart.log
   # echo the host information
   echo `get_cluster $hostname1` > /tmp/system_name
   echo `get_type $hostname1` > /tmp/type_name
   echo `get_number $hostname1` > /tmp/number_name
   echo "$hostname1" > /tmp/host_name

   echo "Using hostname from kickstart. (1)" >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname1}${DOMAIN} --bootproto static --ip $ip1" | tee -a /tmp/network-include

   hostname ${hostname1}${DOMAIN}

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

elif [ -n `get_cluster $hostname2` -a -n `get_type $hostname2` ]; then

   #If the user did not give an ip but the node had an existing name,
   # we will use the existing name.

   # echo the host information
   echo `get_cluster $hostname2` > /tmp/system_name
   echo `get_type $hostname2` > /tmp/type_name
   echo `get_number $hostname2` > /tmp/number_name
   echo "$hostname2" > /tmp/host_name

   echo "Using existing nodename." >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname2}${DOMAIN} --bootproto static --ip $ip2" | tee -a /tmp/network-include

   hostname ${hostname2}${DOMAIN}

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

else

   #If the contents of /tmp/netinfo have the fake hostname, then use it
   # since that is all we've got.

   # echo the host information
   echo `get_cluster $hostname1` > /tmp/system_name
   echo `get_type $hostname1` > /tmp/type_name
   echo `get_number $hostname1` > /tmp/number_name
   echo "$hostname1" > /tmp/host_name

   echo "Using hostname from kickstart. (2)" >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname1}${DOMAIN} --bootproto static --ip $ip1" | tee -a /tmp/network-include

   hostname ${hostname1}${DOMAIN}

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

fi
echo "Done with network configuration."
) 2>&1 ) | tee -a /tmp/save/kickstart.log

##########################################################
##########################################################

%pre
#
# Determine  if the personality files exist.  Edit heavily
##########################################################
#
# Check that there exists all the necessary personality files.
#
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
check_for_backup ( )
{
	targets=$1
	shift

	for target in $targets; do
		echo "checking for $target backup" | tee -a /tmp/save/kickstart.log
		for dname in $*; do
			if [ -f $dname/$target -o -d $dname/$target ]; then
				return 0;
			fi
		done
	done

	abort_install "Backup of $target not found.  Aborting install."

	return 1;  #Never reached.
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	if [ ! -f "$1" -a ! -d "$1" ]; then
		return 2;
	fi

	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	echo "Unable to backup file $1.  Aborting install." | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done

	return 1; # Not reached.
}
#
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
echo "$hostname" >> /tmp/save/kickstart.log
#
# Mounting 'srv3' backup disk
#
if [ "$system" = "stken" ]; then
        srv3_ip=131.225.13.3
elif [ "$system" = "d0en" ]; then
        srv3_ip=131.225.164.23
elif [ "$system" = "cdfen" ]; then
        srv3_ip=131.225.215.5
elif [ "$system" = "gccen" ]; then
        srv3_ip=131.225.13.3
else
        echo "Hostname not set."
	exit 1
fi
#
#
((
mkdir -p /mnt/backup
if [ -n "$srv3_ip" -a "$type" == "srv" -a "$number" == "3" ]; then
	echo "  Mounting local /diskc for backup."

	mkdir /mnt/backup
	if [ ! -f /tmp/diskc ]; then
	       abort_install "Unable to find LABEL=/diskc to make backups."
	fi
        mount `cat /tmp/diskc` /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
else
	echo "  Mounting ${system}srv3 backup disk for backup."
	mkdir /mnt/backup
	#service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
	#service portmap stop
	df -h
fi
mount
) 2>&1 ) | tee -a /tmp/save/kickstart.log
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
#pulldown_dir="/mnt/backup/backup/"
pulldown_dir="/mnt/backup/backup/kickstart"
#
# Backing up personality.
#
((
if [ -n "$system" -a -n "$type" -a -n "$number" ]; then
   echo "Backing up personality."
   mkdir -p $backup_dir
   for file in `ls $save_dir`; do
       if [ ! -f $backup_dir/$file -o $save_dir/$file -nt $backup_dir/$file ]
       then
	     copy_it $save_dir/$file $backup_dir/$file
       fi
   done
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

#
# Before continueing with the install.  Make sure that we have the personality
# stored away.
#
echo "Checking the consistancy of the personality backup." | tee -a /tmp/save/kickstart.log
# Only be this picky for nodes that we know who they are and that there
# was a single root filesystem already found (mounted at /mnt/tmp, otherwise
# /mnt/tmp should not exist).
if [ -n "$system" -a -n "$type" -a -n "$number" \
     -a -d /mnt/tmp ]; then
#	check_for_backup fstab $save_dir $backup_dir
#	check_for_backup passwd $save_dir $backup_dir $pulldown_dir
#	check_for_backup shadow $save_dir $backup_dir $pulldown_dir
#	check_for_backup group $save_dir $backup_dir $pulldown_dir
	check_for_backup network $save_dir $backup_dir $pulldown_dir
	check_for_backup ifcfg-eth0 $save_dir $backup_dir $pulldown_dir
	check_for_backup krb5.keytab $save_dir $backup_dir
	check_for_backup enstorekt $save_dir $backup_dir
#	check_for_backup rc.local $backup_dir $pulldown_dir
#	check_for_backup "cron_ks.tar.gz cron.tar.gz" $save_dir $backup_dir
#	check_for_backup "cron.d_ks.tar.gz cron.d.tar.gz" $save_dir $backup_dir
#	check_for_backup "root_ks.tar.gz root.tar.gz" $save_dir $backup_dir
#	check_for_backup "home_ks.tar.gz home.tar.gz" $save_dir $backup_dir
fi


#
#We are done with this mount.
#
cd /
sync
umount /mnt/backup
rm -r /mnt/backup

###) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
cd /
sync
umount /mnt/tmp


%pre
#
#Put this assignment outside any ( ) redirections.
#
disk_device=`cat /tmp/which_disk`
#
#
((
#
#Formating the disk.
#
echo "Formating the disk." | tee -a /tmp/save/kickstart.log
dd if=/dev/zero of=$disk_device bs=512 count=1
#
) 2>&1 ) | tee -a /tmp/save/kickstart.log
##
fdisk $disk_device <<EOF | tee -a /tmp/save/kickstart.log
n
p
1

+128M

n
p
2

+4104M

t
1
6

t
2
82

n
p
3

+10240M

a
3

n
e



n



n




w
q
EOF

#
((
echo "`date +%H:%M:%S`    -[ new partition table on $disk_device: ]-"
fdisk -l $disk_device | grep "^/dev/" | sed -e "s/^/       /"

mkdosfs ${disk_device}1
mkswap ${disk_device}2
#mke2fs ${disk_device}3
#mke2fs ${disk_device}5
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post --nochroot
#
# Move information from the /tmp area of the install area to that of the
# installed sysimage.
#

# These are the personality backups.
mkdir /mnt/sysimage/tmp/save
cp -p /tmp/save/* /mnt/sysimage/tmp/save

#These files contain information about networking/hostname information.
cp -p /tmp/netinfo /mnt/sysimage/tmp    #If the old image was lost.
cp -p /tmp/system_name /mnt/sysimage/tmp/
cp -p /tmp/type_name /mnt/sysimage/tmp/
cp -p /tmp/number_name /mnt/sysimage/tmp/
cp -p /tmp/host_name /mnt/sysimage/tmp/
cat /mnt/sysimage/tmp/save/network | tee -a /mnt/sysimage/tmp/save/test.log

%post
#We need to put in additional nameservers.
((
grep -v nameserver /etc/resolv.conf > /etc/resolv.conf.tmp
echo "nameserver 131.225.8.120" >> /etc/resolv.conf.tmp
echo "nameserver 131.225.17.150" >> /etc/resolv.conf.tmp
mv /etc/resolv.conf.tmp /etc/resolv.conf
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
# Mount the backup/pulldown disk.
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Mounting 'srv3' backup disk
#
if [ "$system" == "stken" ]; then
	srv3_ip=131.225.13.3
elif [ "$system" == "d0en" ]; then
	srv3_ip=131.225.164.23
elif [ "$system" == "cdfen" ]; then
	srv3_ip=131.225.215.5
elif [ "$system" == "gccen" ]; then
	srv3_ip=131.225.13.3
else
	echo "Hostname not set."
fi
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
use_name=$system
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
pulldown_dir="/mnt/backup/backup/kickstart"
#
#
((
echo "  Mounting ${system}srv3 backup disk for restoring."
mkdir -p /mnt/backup
if [ "$type" == "srv" -a "$number" == "3" ]; then
        mount `cat /tmp/diskc` /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
else
	service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq "0" ]; then
	   echo "Done mounting backup disk."
	else
	   echo "Failed mounting backup disk."
	fi
	service portmap stop
	df -h
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
#
# install defs for types of servers, Edit heavliy
#######################################################
#
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Shortcut variables.
#   $pulldown_dir = The remote directory that some files are downloaded.
#
#pulldown_dir="/mnt/backup/backup/"
pulldown_dir="/mnt/backup/backup/kickstart"
#
#
# Do things specific to each server.
#
install_tarball_python="0"
install_tarball_ipmi="1"
install_tarball_enstore="1"
install_upd_python="1"
install_upd_swig="1"
install_upd_ftt="1"
install_upd_ngop="1"
install_rpm_xfsprogs="1"

((
echo "   Extras to install."
echo install_tarball_python=$install_tarball_python
echo install_tarball_ipmi=$install_tarball_ipmi
echo install_tarball_enstore=$install_tarball_enstore
echo install_rpm_xfsprogs=$install_rpm_xfsprogs
echo install_upd_swig=$install_upd_swig
echo install_upd_ftt=$install_upd_ftt
echo install_upd_ngop=$install_upd_ngop
echo install_upd_python=$install_upd_python
echo
) 2>&1 ) | tee -a /tmp/save/kickstart.log

#
#
# Permform the system specific installs.
#
# RPMs go first.
#
# xfsprogs rpm
if [ "$install_rpm_xfsprogs" == "1" ]; then
   additional_rpms="xfsprogs xfsprogs-devel $additional_rpms"
fi
#
echo "Install these additional rpms:" | tee -a /tmp/save/kickstart.log
echo "$additional_rpms" | tee -a /tmp/save/kickstart.log
#
# Start these updates from contrib area.  It can/will take a while, better
# to start it in parallel with the other updates.  The yum.conf.contrib
# should include all the regular rpm areas too.
#
yum -y --enablerepo=fermi-contrib install $additional_rpms >> /tmp/save/yum.log &
#
#
# Begginning ups install.
#
#
# Regardless if /fnal or /local is the real directory, set the other one
# to be a symbolic link to it.
if [ -d /local ]; then
	cd /
	ln -s local fnal
elif [ -d /fnal ]; then
	cd /
	ln -s fnal local
fi
#
#
#  By default this file contains three lines, we only want one.
echo "/local/ups/db" > /local/ups/etc/upsdb_list
chmod 0664 /local/ups/etc/upsdb_list
#
#
mkdir -p /root
mkdir -p /home/enstore
chown 5744.6209 /home/enstore
echo "  Beginning ups installs." | tee -a /tmp/save/kickstart.log
. /fnal/ups/etc/setups.sh
setup upd
#
# swig
#
if [ "$install_upd_swig" == "1" ]; then
   ((
   upd install -G "-c" swig
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# ftt
#
if [ "$install_upd_ftt" == "1" ]; then
   ((
   upd install ftt -q enstore -G "-c" v2_25
   upd install ftt v2_22
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# Current enstore python install
#
if [ "$install_upd_python" == "1" ]; then
   ((
   upd install python -c -q enstore -G "-c -q enstore"
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# ngop
#
if [ "$install_upd_ngop" == "1" ]; then
   ((
   upd install -G "-c" -c fcslib
   upd install -G "-q agent" -q agent -c ngop
   ups declare -c -f Linux -m v2_1a.table -r ngop/v2_1a/Linux-agent ngop v2_1a
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
chown -R 1342.4525 /fnal/ups
#
#
# Lastly, install the tarballs.
#
# XXX - These tarballs need to come from somewhere.  That will most likely
# be *srv3.  So, this will likely be moved to the next %post section.
#Python
if [ "$install_tarball_python" == "1" ]; then
   echo "Installing python from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/python.tar.gz
   #cd /fnal/ups/db/
   #tar zxf $pulldown_dir/python_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#Enstore
if [ "$install_tarball_enstore" == "1" ]; then
   echo "Installing enstore db from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/enstore_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#IPMI
if [ "$install_tarball_ipmi" == "1" ]; then
   echo "Installing ipmi db from tarball." | tee -a /tmp/save/kickstart.log
   ((
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/ipmi_db.tar.gz
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi

#We should wait for yum to finish before continuing.
echo "Waiting for yum update/install to complete."
wait


%post
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
#pulldown_dir="/mnt/backup/backup/"
pulldown_dir="/mnt/backup/backup/kickstart"
#
#
#
# Unwinding tar files
#
#
echo "  Unwinding personality tar files." | tee -a /tmp/save/kickstart.log
mkdir /home /home/enstore
chown 5744.6209 /home/enstore

tar_opt="--same-owner --same-permissions --atime-preserve"

cd /
echo " ...home_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/home_ks.tar.gz ]; then
	tar zxf $save_dir/home_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/home_ks.tar.gz ]; then
	tar zxf $backup_dir/home_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/home.tar.gz ]; then
	tar zxf $backup_dir/home.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/$use_name/$type/home.tar.gz ] ; then
	tar zxf $pulldown_dir/$use_name/$type/home.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/$use_name/home.tar.gz ] ; then
	tar zxf $pulldown_dir/$use_name/home.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/home.tar.gz ] ; then
	tar zxf $pulldown_dir/home.tar.gz ${tar_opt}
else
	echo "No home[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

cd /var/spool
echo " ...cron_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/cron_ks.tar.gz ]; then
	tar zxf $save_dir/cron_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cron_ks.tar.gz ]; then
	tar zxf $backup_dir/cron_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cron.tar.gz ]; then
	tar zxf $backup_dir/cron.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/cron.tar.gz ] ; then
	tar zxf $pulldown_dir/cron.tar.gz ${tar_opt}
else
	echo "No cron[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

cd /etc
echo " ...cron.d_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/cron.d_ks.tar.gz ]; then
        tar zxf $save_dir/cron.d_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cron.d_ks.tar.gz ]; then
        tar zxf $backup_dir/cron.d_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/cron.d.tar.gz ]; then
        tar zxf $backup_dir/cron.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/cron.d.tar.gz ] ; then
        tar zxf $pulldown_dir/cron.d.tar.gz ${tar_opt}
else
        echo "No cron.d[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log


cd /
echo " ...root_ks.tar.gz" | tee -a /tmp/save/kickstart.log
((
if [ -f $save_dir/root_ks.tar.gz ]; then
	tar zxf $save_dir/root_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/root_ks.tar.gz ]; then
	tar zxf $backup_dir/root_ks.tar.gz ${tar_opt}
elif [ -f $backup_dir/root.tar.gz ]; then
	tar zxf $backup_dir/root.tar.gz ${tar_opt}
elif [ -f $pulldown_dir/root.tar.gz ] ; then
	tar zxf $pulldown_dir/root.tar.gz ${tar_opt}
else
	echo "No root[_ks].tar.gz file found to unpack."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

#Update the farmlets so that rgang can be used to fix stuff later.
mkdir -p /usr/local/etc /usr/local/etc/farmlets
cd /usr/local/etc/farmlets
echo " ...farmlets.tar.gz" | tee -a /tmp/save/test.log
tar zxf $pulldown_dir/farmlets.tar.gz | tee -a /tmp/save/test.log

#
# Restoring personality files.
#
echo "  Restoring personality files." | tee -a /tmp/save/kickstart.log

echo "  Installing passwd, shadow and group files."
copy_it $pulldown_dir/passwd /etc
copy_it $pulldown_dir/shadow /etc
copy_it $pulldown_dir/group /etc

copy_it $pulldown_dir/fstab /etc
copy_it $save_dir/krb5.keytab /etc
if [ ! -f /etc/krb5.keytab ] ;then
	copy_it $backup_dir/krb5.keytab /etc
fi

mkdir /fnal /fnal/ups /fnal/ups/kt
copy_it $save_dir/enstorekt /fnal/ups/kt/enstorekt
if [ ! -f /fnal/ups/kt/enstorekt ] ;then
	copy_it $backup_dir/enstorekt /fnal/ups/kt/enstorekt
fi
chown 5744.6209 /fnal/ups/kt/enstorekt
copy_it $pulldown_dir/rc.local /etc/rc.d/rc.local

mkdir -p /home/enstore
chown 5744.6209 /home/enstore/.k5login

copy_it $pulldown_dir/init.d.network /etc/rc.d/init.d/network
chown 0.0 /etc/rc.d/init.d/network

copy_it /local/ups/prd/ups/v4_7_2/Linux-2/init.d/ups /etc/rc.d/init.d/

cd /etc/rc.d/rc6.d/
ln -s ../init.d/ups K01ups
cd /etc/rc.d/rc3.d
ln -s ../init.d/ups S99ups

echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/shutdown/$hostname.products
echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
echo "ups start ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/startup/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/startup/$hostname.products

rm /home/enstore/*.fnal.gov.startup #Remove old copies...
touch /home/enstore/$hostname.fnal.gov.startup
chown 5744.6209 /home/enstore/$hostname.fnal.gov.startup


%post
#
#Finally, we are done with this.
#
umount /mnt/backup
/bin/rm -r /mnt/backup


%post
((
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
# Turning services on and off.
#
echo "  Turning services on and off." | tee -a /tmp/save/kickstart.log
/sbin/chkconfig autofs off
/sbin/chkconfig netfs off
/sbin/chkconfig netlock off
/sbin/chkconfig iptables off
/sbin/chkconfig xfs on
/sbin/chkconfig ftp off
/sbin/chkconfig eklogin on
/sbin/chkconfig klogin on
/sbin/chkconfig kshell on
/sbin/chkconfig telnet on
/sbin/chkconfig yum off
/sbin/chkconfig isdn off
/sbin/chkconfig pcmcia off
/sbin/chkconfig portmap on
/sbin/chkconfig mdmonitor off
/sbin/chkconfig mdmpd off
/sbin/chkconfig apmd off
/sbin/chkconfig nfslock off
/sbin/chkconfig rhnsd off
/sbin/chkconfig serial on
rm -f /etc/cron.daily/00-logwatch
rm -f /etc/cron.daily/0anacron
rm -f /etc/cron.daily/yum.cron
if [ "$type" == "mvr" -o "$type" == "dm" ]; then
   # We need to worry about this for dCache nodes.  It appears that the
   # head node and monitor node (door node too?) have sendmail enabled,
   # but pool nodes do not.  In the meantime, only Enstore servers
   # get sendmail turned on.

   /sbin/chkconfig sendmail off
   rm -f /etc/mail/submit.*
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post --nochroot
#
# Try putting the user and groups for users root and enstore to see if
# su really can work if these files are correct.  The installed versions
# should be correct, these only put information into the install environment.
#
grep "^enstore" /mnt/sysimage/etc/passwd >> /etc/passwd
grep "^root" /mnt/sysimage/etc/group >> /etc/group
grep "^enstore" /mnt/sysimage/etc/group >> /etc/group

%post
#
# Enstore home area stuff.
#
#
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
source /usr/local/etc/setups.sh
#
#
echo "  Beginning enstore home area stuff." | tee -a /tmp/save/kickstart.log
id enstore | tee -a /tmp/save/kickstart.log
( if [ "1" ]; then
	#
	#checkout enstore and ipmi
	#
	echo "Beginning cvs checkouts for enstore and ipmi."
	#grep "enstore" /etc/passwd  #does user enstore exist?
	export CVSROOT=hppccvs@cdcvs.fnal.gov:/cvs/hppc
	export CVS_RSH=/usr/krb5/bin/rsh
	mkdir -p /home/enstore
	cd /home/enstore

	short_hostname=`echo $hostname | cut -f 1 -d "."`
	krb5_principal="enstore/cd/${short_hostname}.fnal.gov@FNAL.GOV"
	if [ ! -s /home/enstore/.k5login ]; then
	   #If we don't have an enstore .k5login file, create a temporary
	   # one for getting kinit to work.
	   echo "$krb5_principal" > /home/enstore/.k5login
	fi

	echo /usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt $krb5_principal
	/usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt $krb5_principal

	if [ -d /home/enstore/enstore ]; then
		cd /home/enstore/enstore
		cvs update -r production
	else
		cd /home/enstore
		cvs checkout -r production enstore
	fi
	if [ -d /home/enstore/ipmi ]; then
		cd /home/enstore/ipmi
		cvs update ipmi
	else
		cd /home/enstore
		cvs checkout ipmi
	fi
	#The installing of PyGreSQL needs to go after krb5.keytab, enstorekt
	# et. al. are in place.
	if [ "$type" == "srv" -o "$type" == "pnfs" ]; then
	   # eagpnfs1 and cmspnfs1 should work!
	   if [ "$number" -eq 0 -o "$number" -eq 1 -o "$number" -eq 2 \
		 -o "$number" -eq 3  -o "$number" -eq 6 ]; then
		 #
		 #This is yucky.  Need a better source of PyGreSQL.
		 #
		 cd /home/enstore
		 export CVSROOT=hppccvs@cdcvs.fnal.gov:/cvs/hppc
		 export CVS_RSH=/usr/krb5/bin/rsh
		 cvs checkout PyGreSQL-3.6.2
		 setup python
		 setup postgres
		 cd /home/enstore/PyGreSQL-3.6.2
		 python setup.py build
		 python setup.py install
	   fi
	fi
	if [ "$type" == "pnfs" -o "$type" == "dca" \
		 -o "$type" == "srv" -a "$number" == "1" ]; then
	   if [ -d /home/enstore/dcache-deploy/dcache-fermi-config ]; then
	      cd /home/enstore/dcache-deploy/dcache-fermi-config
	      cvs update
	   else
	      mkdir -p /home/enstore/dcache-code
	      cd /home/enstore/dcache-code
	      cvs checkout dcache-fermi-config
	      cd /home/enstore
	      ln -s /home/enstore/dcache-code/ dcache-deploy
	   fi
	fi
fi 2>&1 ) | tee -a /tmp/save/kickstart.log
if [ -d /home/enstore/enstore ]; then
	#
	#build enstore and ipmi
	#
	echo "Beginning enstore and ipmi builds." | tee -a /tmp/save/kickstart.log
	((
	###This is to support going to the new python.
	cd /home/enstore/enstore/ups
	sed 's/setupOptional("python")/setupOptional("python -q enstore")/' enstore.table > enstore.table.new
	mv enstore.table.new enstore.table
	###
	cd /home/enstore/enstore/modules
	make clean
	setup enstore
	make
	cd /home/enstore/ipmi
	make
	) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
if [ -d /home/enstore/enstore ]; then
	#
	# Begin copying the following files to their needed locations.
	#
	echo "Copying enstore files to their needed locations." | tee -a /tmp/save/kickstart.log

	if [ "$type" == "srv" -o "$type" == "mvr" -o "$type" == "pnfs" ]; then
		copy_it /home/enstore/enstore/bin/enstore-boot /etc/rc.d/init.d
		chown 0.0 /etc/rc.d/init.d/enstore-boot
		ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc3.d/S99zzzenstore-boot
		ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc6.d/K01aaaenstore-boot
		copy_it /home/enstore/enstore/bin/monitor_server-boot /etc/rc.d/init.d
		chown 0.0 /etc/rc.d/init.d/monitor_server-boot
		ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc3.d/S99zzzmonitor_server-boot
		ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc6.d/K01aaamonitor_server-boot
	fi
	if [ "$type" == "pnfs" -o "$type" == "srv" -a "$number" == "1" ]; then


		#append the following kernel tunning paramaters.
		(
		echo
		echo "# Increase amount of shared memory up to 256MB."
		echo "kernel.shmmax=268435456"
		echo "kernel.shmall=268435456"
		) >> /etc/sysctl.conf
	fi
	copy_it /home/enstore/enstore/etc/enstore.bashrc /home/enstore/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /home/enstore/.bash_profile
	#Where do the root/.bashrc and root/.bash_profile files come from?
	copy_it /home/enstore/enstore/etc/enstore.bashrc /root/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /root/.bash_profile
	copy_it /home/enstore/enstore/etc/sudoers /etc/
	chmod 0440 /etc/sudoers
	chown 0.0 /etc/sudoers
	# new copies to satisfy netscan
	copy_it /home/enstore/enstore/etc/services /etc/services
	mkdir -p /etc/X11/xinit
	copy_it /home/enstore/enstore/etc/xserverrc /etc/X11/xinit/xserverrc
	copy_it /home/enstore/enstore/etc/xinetd.conf /etc/xinetd.conf
	#
	copy_it /home/enstore/enstore/sbin/routes /root/
	chown 0.0 /root/routes
	copy_it /home/enstore/enstore/etc/products.k5login /local/ups/.k5login
	chown 1342.4525 /local/ups/.k5login
	chmod 0664 /local/ups/.k5login
	if [ -n $system ]; then
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/root.k5login.m4 > /tmp/root.k5login 2>> /tmp/save/kickstart.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/root.k5login /root/.k5login
			chown 0.0 /root/.k5login
		fi
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/$system.enstore.k5login.m4 > /tmp/enstore.k5login 2>> /tmp/save/kickstart.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/enstore.k5login /home/enstore/.k5login
			chown 5744.6209 /home/enstore/.k5login
		fi
		copy_it /home/enstore/enstore/etc/$system.hosts.allow /etc/hosts.allow
		chown 0.0 /etc/hosts.allow
		copy_it /home/enstore/enstore/etc/$system.step-tickers /etc/ntp/step-tickers
		chown 0.0 /etc/ntp/step-tickers
	fi
	copy_it /home/enstore/enstore/etc/hosts /etc/hosts
	chown 0.0 /etc/hosts
	copy_it /home/enstore/enstore/etc/ups /etc/rc.d/init.d/ups
	chown 0.0 /etc/rc.d/init.d/ups
	copy_it /home/enstore/enstore/etc/ntp.conf /etc/ntp.conf
	chown 0.0 /etc/ntp.conf
	copy_it /home/enstore/enstore/etc/services /etc/services
	chown 0.0 /etc/services
	copy_it /home/enstore/enstore/etc/krb5.conf /etc/krb5.conf
	chown 0.0 /etc/krb5.conf
	mkdir /var/ngop /var/ngop/include /var/ngop/cron_agent /var/ngop/plugins_agent
	copy_it "/home/enstore/enstore/ngop/*.py" /var/ngop/include
	copy_it /home/enstore/enstore/ngop/raise_enstore_alarm /var/ngop/include
	copy_it /home/enstore/enstore/ngop/local_cronjob.xml /var/ngop/cron_agent
	copy_it /home/enstore/enstore/ngop/start_cron /var/ngop/cron_agent/.start
	chmod 0755 /var/ngop/cron_agent/.start
	if [ "$type" == "mvr" ]; then
		copy_it /home/enstore/enstore/ngop/linuxHealth.xml /var/ngop/plugins_agent/
	elif [ "$type" == "srv" ]; then
		copy_it /home/enstore/enstore/ngop/srv_linuxHealth.xml /var/ngop/plugins_agent/
	fi
	((
	setup enstore
#	/home/enstore/enstore/sbin/farmlets -f
	) 2>&1 ) | tee -a /tmp/save/kickstart.log
	chown -R 0.0 /var/ngop
	rm -f /home/enstore/enstore/tmp/enstore/*
	echo "" | tee -a /tmp/save/kickstart.log
	echo "end of enstore home stuff" | tee -a /tmp/save/kickstart.log
fi

%post
#
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
((
echo ""
echo " Last Few Things "
#  Setup the root and enstore .forward files.
echo "enstore-admin@fnal.gov" > /root/.forward
echo "enstore-admin@fnal.gov" > /home/enstore/.forward
#  Some versions of ftt have these files without execute permissions.
echo " CHmod "
chmod +x /local/ups/prd/ftt/v2_22/Linux-2-4-2-3-2/etc/*
chmod +x /local/ups/prd/ftt/v2_25/Linux-2-6/etc/*
#  Some enstore CRON jobs will look for /PRODUCTION to exist.
touch PRODUCTION
chmod 0644 PRODUCTION
mkdir -p /root/CRON
chmod 0755 /root/CRON
#  Set these permissions...
echo " Set these permissions... " | tee -a /tmp/save/kickstart.log
chown -R 5744.6209 /home/enstore
chown -R 5744.6209 /local/ups/kt/
chmod 0775 /fnal/ups/db
chmod 0775 /fnal/ups/prd
chmod 0775 /fnal/ups/db/.upsfiles/startup/${hostname}.products
chmod 0775 /fnal/ups/db/.upsfiles/shutdown/${hostname}.products
#Make the dir for mounting the backup directory.
mkdir /backup
chmod 0755 /backup
#Make the pnfs directories.
echo "Make the pnfs directories."  | tee -a /tmp/save/kickstart.log
for item in `grep -v "$\#" /etc/fstab | awk '{print $2}' | grep pnfs | tr '\n' ' '`; do
    if [ ! -d $item ]; then
       echo "Making $item"
       mkdir -p $item
    fi
done
#
# for NFS
#
echo "  For NFS mounts."
if [ "$type" == "srv" -a "$number" == "3" ]; then
       echo "RQUOTAD=no" >> /etc/sysconfig/network
fi
#

) 2>&1 ) | tee -a /tmp/save/kickstart.log
