# Kickstart file written by Michael Zalokar & Terry Jones for Enstore.
# $Id$
#

install
lang en_US.UTF-8
langsupport --default en_US.UTF-8 en_US.UTF-8
keyboard us
mouse none
skipx
nfs --server linux.fnal.gov --dir /export/linux/lts305/i386
%include /tmp/network-include
#network --device eth0 --bootproto static --ip 131.225.164.62 --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120 --hostname d0enload.fnal.gov
#network --device eth1 --bootproto dhcp --hostname stkenmvr12a.fnal.gov
rootpw --iscrypted $1$
firewall --disabled
authconfig --enableshadow --enablemd5 --enablekrb5 --krb5realm FNAL.GOV --krb5kdc krb-fnal-1.fnal.gov:88,krb-fnal-2.fnal.gov:88,krb-fnal-3.fnal.gov:88,krb-fnal-4.fnal.gov:88,krb-fnal-5.fnal.gov:88 --krb5adminserver krb-fnal-admin.fnal.gov
timezone America/Chicago
bootloader --location=mbr
# The following is the partition information you requested
# Note that any partitions you deleted are not expressed
# here so unless you clear all partitions first, this is
# not guaranteed to work
%include /tmp/part-include


#clearpart --all
#part /dos --fstype vfat --start=1 --end=17 --ondisk=hda --onpart=hda1
#part swap --size=512 --start=18 --end=148  --ondisk=hda --onpart=hda2
#part / --fstype ext3 --start=149 --end=671 --ondisk=hda --onpart=hda3
#part /scratch --fstype ext3 --ondisk=hda --size=1 --grow
#part /dos --ondisk=hda --onpart=hda1
#part swap --size=1024 --ondisk=hda --onpart=hda2
#part / --ondisk=hda --onpart=hda3
#part /scratch --ondisk=hda --size=1 --grow
#part /dos --onpart=hda1 --noformat
#part swap --onpart=hda2
#part /  --onpart=hda3
#part /scratch --onpart=hda5

%packages
Fermi-release
GenericFarm-tag
GenericFarm-tree
MAKEDEV
SL_enable_serialconsole
SL_inittab_change
SysVinit
XFree86-Mesa-libGL
XFree86-libs
XFree86-libs-data
Xaw3d
acl
anacron
apmd
ash
at
atk
attr
authconfig
basesystem
bash
bc
beecrypt
bind-libs
bind-utils
binutils
byacc
bzip2
bzip2-libs
chkconfig
compat-db
compat-libstdc++
compat-slang
coreutils
cpio
cpp
cracklib
cracklib-dicts
crontabs
cvs
cyrus-sasl
cyrus-sasl-gssapi
cyrus-sasl-md5
cyrus-sasl-plain
db4
db4-devel
db4-utils
dev
devlabel
dhclient
diffutils
dos2unix
dosfstools
dump
e2fsprogs
e2fsprogs-devel
ed
eject
elfutils
elfutils-libelf
emacs
ethtool
expat
fbset
file
filesystem
findutils
finger
flpr
fontconfig
freetype
ftp
gawk
gcc
gcc-c++
gcc-java
gd
gdb
gdbm
gdbm-devel
gettext
glib
glib-devel
glib2
glib2-devel
glibc
glibc-common
glibc-debug
glibc-devel
glibc-headers
glibc-kernheaders
glibc-profile
glibc-utils
gmp
gnupg
gpm
grep
groff
grub
gtk2
gzip
hdparm
hesiod
hotplug
htmlview
hwdata
info
initscripts
iproute
ipsec-tools
iptables
iptables-ipv6
iputils
irda-utils
isdn4k-utils
jfsutils
jwhois
kbd
kernel
kernel-doc
kernel-pcmcia-cs
kernel-smp
kernel-utils
krb5-fermi-config
krb5-libs
krb5-libs-fermi
krb5-workstation
krb5-workstation-fermi
krbafs
kudzu
laus-libs
less
lftp
lha
libacl
libattr
libcap
libdbi
libdbi-devel
libgcc
libgcj
libgcj-devel
libjpeg
libpng
libstdc++
libstdc++-devel
libtermcap
libtermcap-devel
libtiff
libtool-libs
libungif
libuser
libwvstreams
libxml2
libxml2-python
lilo
lockdev
logrotate
logwatch
losetup
lslk
lsof
lvm
m4
mailcap
mailx
make
man
man-pages
mdadm
mgetty
mingetty
minicom
mkbootdisk
mkinitrd
mktemp
modutils
mount
mt-st
mtools
mtr
nano
nc
ncompress
ncurses
ncurses-devel
ncurses4
net-tools
netconfig
netdump
newt
nfs-utils
nscd
nss_ldap
ntp
ntsysv
openldap
openssh
openssh-clients
openssl
pam
pam_krb5
pam_smb
pango
parted
passwd
patch
pax
pciutils
pcre
pdksh
perl
perl-Filter
perl-HTML-Parser
perl-HTML-Tagset
perl-URI
perl-libwww-perl
pinfo
pkgconfig
popt
portmap
ppp
prelink
procps
psacct
psmisc
pyOpenSSL
pygtk2
python
python-optik
pyxf86config
quota
raidtools
rdate
rdist
readline
readline-devel
redhat-config-language
redhat-config-mouse
redhat-config-network-tui
redhat-config-securitylevel-tui
redhat-logos
redhat-lsb
redhat-menus
rhnlib
rhpl
rmt
rootfiles
rp-pppoe
rpm
rpm-libs
rpm-python
rsh
rsync
schedutils
sed
sendmail
sendmail-cf
sendmail-devel
sendmail-doc
setarch
setserial
setup
setuptool
shadow-utils
sharutils
slang
slang-devel
slocate
specspo
star
stunnel
sudo
symlinks
sysklogd
syslinux
sysreport
sysstat
talk
tar
tcl
tcp_wrappers
tcpdump
tcsh
telnet
termcap
tftp
time
tmpwatch
traceroute
tzdata
unix2dos
unzip
up2date
upsupdbootstrap
upsupdbootstrap-generic
usbutils
usermode
utempter
util-linux
vconfig
vim-common
vim-minimal
vixie-cron
wget
which
wireless-tools
words
wvdial
xinetd
xterm
yp-tools
ypbind
yum
yum-conf
zip
zlib
zlib-devel
zz_cups_nobrowse
zz_dhcp_resolv
zz_fermi-logos
zz_firstboot_fix
zz_lang_collate
zz_logwatch_df
zz_ntp_configure
zz_pine_user_domain
zz_sendmail_fermi_gateway
zz_tcp_wrappers_change

%pre
#
# Make the directory where we will locally save the personality of the node.
# This way the kickstart.log will have a home.
#
mkdir -p /tmp/save

%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#
#
((
#
# Make the directory where we will locally save the personality of the node.
#
echo mkdir -p /tmp/save
mkdir -p /tmp/save
#
# Make the directory where we will remotely save the personality of the node.
#
echo mkdir -p /mnt/tmp
mkdir -p /mnt/tmp
#
# Mount the existing root directory on the node.
#
root_sysimage_count=0
root_sysimage=''
for t in hd sd; do
  for d in a b c d e f g h; do
    for i in 1 2 3 4 5 6 7 8 9; do
	mount /dev/$t$d$i /mnt/tmp
	rtn1=$?
	# Check not just /dev/hda but also /dev/hda1.  CDROMs will show
	# up with /dev/hdc type names, but will not have any corresponding
	# /dev/hdc1, /dev/hdc2, etc devices.  This should just let disks
	# through (both IDE and SCSI) but exclude CDROMs.
	ls -l /dev/$t$d /dev/${t}${d}1
	rtn2=$?
	if [ "$rtn1" -eq "0" -a "$rtn2" -eq "0" ]; then
	   #Set this here for the case of a blank disk.
	   if [ -z "$root_sysimage" ]; then
	      root_sysimage="/dev/$t$d$i"
	   fi

	   if [ -d /mnt/tmp/etc -o -d /mnt/tmp/usr ]; then
	      echo "Found root file system at device /dev/$t$d$i."
	      root_sysimage="/dev/$t$d$i"
	      let "root_sysimage_count = $root_sysimage_count + 1"
	   fi
	fi
	if [ "$rtn1" ]; then
	   umount /mnt/tmp
	fi
    done
  done
done
#
# Write out the include file that will contain the disk "part"ition
# information.  Also, mount the disk to use.
#
if [ "$root_sysimage_count" -eq "1" -a -n "$root_sysimage" ]; then
   mount $root_sysimage /mnt/tmp
   which_disk=`echo $root_sysimage | cut -c 6-8`
elif [ "$root_sysimage_count" -eq "0" -a -n "$root_sysimage" ]; then
   mount $root_sysimage /mnt/tmp
   which_disk=`echo $root_sysimage | cut -c 6-8`
elif [ "$root_sysimage_count" -eq "0" ]; then
   abort_install "No sysimage found.  Aborting install."
else
   abort_install "Too many sysimages found.  Aborting install."
fi
if [ -n "$which_disk" ]; then
   echo "part /dos --onpart=${which_disk}1 --noformat" >> /tmp/part-include
   echo "part swap --onpart=${which_disk}2" >> /tmp/part-include
   echo "part /  --onpart=${which_disk}3" >> /tmp/part-include
   echo "part /scratch --onpart=${which_disk}5" >> /tmp/part-include

   echo /dev/$which_disk >> /tmp/which_disk
else
   abort_install "System disk not found.  Aborting install."
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	#if [ ! -f "$1" -a ! -d "$1" ]; then
	#	return 2;
	#fi

	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	abort_install "Unable to backup file $1.  Aborting install."
        
	return 1; # Not reached.
}
#
#
((
#
#
copy_it /mnt/tmp/etc/fstab /tmp/save
copy_it /mnt/tmp/etc/passwd /tmp/save
copy_it /mnt/tmp/etc/shadow /tmp/save
copy_it /mnt/tmp/etc/group /tmp/save
copy_it /mnt/tmp/etc/sysconfig/network /tmp/save
copy_it /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth0 /tmp/save
copy_it /mnt/tmp/etc/krb5.keytab /tmp/save
copy_it /mnt/tmp/root/.k5login /tmp/save/root.k5login
copy_it /mnt/tmp/home/enstore/.k5login /tmp/save/enstore.k5login
copy_it /mnt/tmp/fnal/ups/kt/enstorekt /tmp/save
copy_it /mnt/tmp/etc/rc.d/rc.local /tmp/save
if [ -f /mnt/tmp/usr/etc/pnfsSetup ]; then
	copy_it /mnt/tmp/usr/etc/pnfsSetup /tmp/save
fi
if [ -f /mnt/tmp/etc/conserver.cf ]; then
	copy_it /mnt/tmp/etc/conserver.cf /tmp/save
fi
if [ -f /mnt/tmp/usr/local/bin/cons ]; then
	copy_it /mnt/tmp/usr/local/bin/cons /tmp/save
fi
if [ -d /mnt/tmp/var/spool ]; then
   cd /mnt/tmp/var/spool
   tar cz cron > /tmp/save/cron.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring crons."
   fi
fi
if [ -d /mnt/tmp/root ]; then
   cd /mnt/tmp
   tar cz root > /tmp/save/root.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring root."
   fi
fi
if [ -d /mnt/tmp/home ]; then
   cd /mnt/tmp
   tar cz home > /tmp/save/home.tar.gz
   if [ $? -ne 0 ]; then
	   abort_install "Abort taring home."
   fi
fi
cd /

#
# Record what got copied.
#
echo "What got copied."
ls -lh /tmp/save | tee -a /tmp/save/kickstart.log

) 2>&1 ) | tee -a /tmp/save/kickstart.log


%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
get_cluster ( )
{
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			;;
		cdfen*)
			system=cdfen
			;;
		d0en*)
			system=d0en
			;;
		eagpnfs*)
			system=stken
			;;
		cmspnfs*)
			system=stken
			;;
		*)
			system=""
			;;
	esac

    fi

    echo $system
}

get_type ( )
{
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $1 | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $1 | cut -c 5-`
			;;
		eagpnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		cmspnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			;;
		srv*)
			type=srv
			;;
		dm*)	
			type=dm
			;;
		load*)
			type=""
			;;
		dca*)   
			type=dca
			;;
		pnfs*)
			type=pnfs
			;;
		*)
			type=""
			;;
	esac
    fi
    
    echo $type
}

get_number ( )
{
    if [ -n $1 ]; then
	case $1 in
		stken*)
			system=stken
			rest=`echo $1 | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $1 | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $1 | cut -c 5-`
			;;
		eagpnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		cmspnfs*)
			system=stken
			rest=`echo $1 | cut -c 4-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		srv*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		dm*)	
			type=dm
			number=`echo $rest | cut -c 3-`
			;;
		dca*)
			type=dca
			number=`echo $rest | cut -c 4-`
			;;
		pnfs*)
			type=pnfs
			number=`echo $rest | cut -c 5-`
			;;
		load*)
			type=""
			number=""
			;;
		*)
			type=""
			number=""
			;;
	esac
    fi	

    echo $number
}
#
#
((
#
#
echo "  Determining hostname information." | tee -a /tmp/save/kickstart.log
#
# parse the host name
#
DOMAIN=".fnal.gov"
hostname1=`grep HOSTNAME /tmp/netinfo | cut -c 10- | cut -f 1 -d "."`
ip1=`grep IPADDR /tmp/netinfo | cut -c 8-`
hostname2=`grep HOSTNAME /tmp/save/network | cut -c 10- | cut -f 1 -d "."`
ip2=`grep IPADDR /tmp/save/ifcfg-eth0 | cut -c 8-`

echo "hostname debugging" >> /tmp/save/test.log
echo "hostname1:" "$hostname1" >> /tmp/save/test.log
echo "cluster of hostname1:" `get_cluster $hostname1` >> /tmp/save/test.log
echo "type of hostname1:" `get_type $hostname1` >> /tmp/save/test.log
echo "number of hostname1:" `get_number $hostname1` >> /tmp/save/test.log
echo "hostname2:" "$hostname2" >> /tmp/save/test.log
echo "cluster of hostname2:" `get_cluster $hostname2` >> /tmp/save/test.log
echo "type of hostname2:" `get_type $hostname2` >> /tmp/save/test.log
echo "number of hostname2:" `get_number $hostname2` >> /tmp/save/test.log

#Search in the order of the:
# 1) The ip that the node was told to use (by either the kickstart or
#    overridden by the user at the install boot prompt).
# 2) The contents of the pre-existing /etc/sysconfig/network file.
if [ -n `get_cluster $hostname1` -a -n `get_type $hostname1` ]; then
   #If the contents of /tmp/netinfo have the real hostname (because
   # the user specified one on the kickstart command line), then use it.
   # What this really means is that if the $hostname1 is a *load.fnal.gov
   # name we will NOT take this branch.  
 
   # echo the host information
   echo `get_cluster $hostname1` > /tmp/system_name
   echo `get_type $hostname1` > /tmp/type_name
   echo `get_number $hostname1` > /tmp/number_name
   echo "$hostname1" > /tmp/host_name

   echo "Using hostname from kickstart. (1)" >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname1}${DOMAIN} --bootproto static --ip $ip1" | tee -a /tmp/network-include

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

elif [ -n `get_cluster $hostname2` -a -n `get_type $hostname2` ]; then

   #If the user did not give an ip but the node had an existing name,
   # we will use the existing name.  
 
   # echo the host information
   echo `get_cluster $hostname2` > /tmp/system_name
   echo `get_type $hostname2` > /tmp/type_name
   echo `get_number $hostname2` > /tmp/number_name
   echo "$hostname2" > /tmp/host_name

   echo "Using existing nodename." >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname2}${DOMAIN} --bootproto static --ip $ip2" | tee -a /tmp/network-include

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120
else

   #If the contents of /tmp/netinfo have the fake hostname, then use it
   # since that is all we've got.

   # echo the host information
   echo `get_cluster $hostname1` > /tmp/system_name
   echo `get_type $hostname1` > /tmp/type_name
   echo `get_number $hostname1` > /tmp/number_name
   echo "$hostname1" > /tmp/host_name

   echo "Using hostname from kickstart. (2)" >> /tmp/save/test.log
   echo "network --device eth0 --hostname ${hostname1}${DOMAIN} --bootproto static --ip $ip1" | tee -a /tmp/network-include

# --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120

fi
echo "Done with network configuration."
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
#
# Check that there exists all the necessary personality files.
#
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
check_for_backup ( )
{
	target=$1
	shift

	echo "checking for $target backup" | tee -a /tmp/save/kickstart.log
	for dname in $*; do
		if [ -f $dname/$target -o -d $dname/$target ]; then
		       return 0;
		fi
	done

	abort_install "Backup of $target not found.  Aborting install."

	return 1;  #Never reached.
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	if [ ! -f "$1" -a ! -d "$1" ]; then
		return 2;
	fi

	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	echo "Unable to backup file $1.  Aborting install." | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
        
	return 1; # Not reached.
}
#
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Mounting 'srv3' backup disk
#
if [ "$system" = "stken" ]; then
        srv3_ip=131.225.13.3
elif [ "$system" = "d0en" ]; then
        srv3_ip=131.225.164.23
elif [ "$system" = "cdfen" ]; then
        srv3_ip=131.225.215.5
else
        echo "Hostname not set."
	exit 1
fi
#
#
((
mkdir -p /mnt/backup
if [ -n "$srv3_ip" -a "$type" == "srv" -a "$number" == "3" ]; then
        mount -L /diskc /mnt/backup
else
	echo "  Mounting ${system}srv3 backup disk for backup." | tee -a /tmp/save/kickstart.log
	mkdir /mnt/backup
	#service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	fi
	#service portmap stop
	df -h
fi
mount | tee -a /tmp/save/kickstart.log
) 2>&1 ) | tee -a /tmp/save/kickstart.log
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
pulldown_dir="/mnt/backup/backup/"
pulldown_dir2="/mnt/backup/backup/pulldown"
#
# Backing up personality.
#
((
if [ -n "$system" -a -n "$type" -a -n "$number" ]; then
   echo "Backing up personality."
   mkdir -p $backup_dir
   for file in `ls $save_dir`; do
       if [ ! -f $backup_dir/$file -o $save_dir/$file -nt $backup_dir/$file ]
       then
	     copy_it $save_dir/$file $backup_dir/$file
       fi
   done
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

#if [ ! -f $backup_dir/fstab -o /mnt/tmp/etc/fstab -nt $backup_dir/fstab ];
#	copy_it /mnt/tmp/etc/fstab $backup_dir
#fi
#if [ ! -f $backup_dir/hostname ];
#	copy_it /mnt/tmp/etc/hostname $backup_dir
#fi
#if [ ! -f $backup_dir/passwd ];
#	copy_it /mnt/tmp/etc/passwd $backup_dir
#fi
#if [ ! -f $backup_dir/shadow ];
#	copy_it /mnt/tmp/etc/shadow $backup_dir
#fi
#if [ ! -f $backup_dir/group ];
#	copy_it /mnt/tmp/etc/group $backup_dir
#fi
#if [ ! -f $backup_dir/network ];
#	copy_it /mnt/tmp/etc/sysconfig/network $backup_dir
#fi
#if [ ! -f $backup_dir/ifcfg-eth0 ];
#	copy_it /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth0 $backup_dir
#fi
#if [ ! -f $backup_dir/krb5.keytab ];
#	copy_it /mnt/tmp/etc/krb5.keytab $backup_dir
#fi
#if [ ! -f $backup_dir/root.k5login ];
#	copy_it /mnt/tmp/root/.k5login $backup_dir/root.k5login
#fi
#if [ ! -f $backup_dir/enstore.k5login ];
#	copy_it /mnt/tmp/home/enstore/.k5login $backup_dir/enstore.k5login
#fi
#if [ ! -f $backup_dir/enstorekt ];
#	copy_it /mnt/tmp/local/ups/kt/enstorekt $backup_dir
#fi
#if [ ! -f $backup_dir/rc.local ];
#	copy_it /mnt/tmp/etc/rc.d/rc.local $backup_dir
#fi
#
# The next two should only apply to console servers.
#
#if [ ! -f $backup_dir/conserver.cf -a -f /mnt/tmp/etc/conserver.cf ];
#	copy_it /mnt/tmp/etc/conserver.cf $backup_dir
#fi
#if [ ! -f $backup_dir/cons -a -f /mnt/tmp/usr/local/bin/cons ];
#	copy_it /mnt/tmp/usr/local/bin/cons $backup_dir
#fi
#
#
#if [ -f /tmp/save/cron.tar.gz ]; then
#	echo "Storing cron tarfile."
#	copy_it /tmp/save/cron.tar.gz $backup_dir
#fi
#
#if [ -f /tmp/save/root.tar.gz ]; then
#	echo "Storing root tarfile."
#	copy_it /tmp/save/root.tar.gz $backup_dir
#fi
#
#if [ -f /tmp/save/home.tar.gz ]; then
#	echo "Storing home tarfile."
#	copy_it /tmp/save/home.tar.gz $backup_dir
#fi


#
# Before continueing with the install.  Make sure that we have the personality
# stored away.
#
echo "Checking the consistancy of the personality backup." | tee -a /tmp/save/kickstart.log
# Only be this picky for nodes that we know who they are and that there
# was a single root filesystem already found (mounted at /mnt/tmp, otherwise
# /mnt/tmp should not exist).
if [ -n "$system" -a -n "$type" -a -n "$number" \
     -a -d /mnt/tmp ]; then
	check_for_backup fstab $save_dir $backup_dir
	check_for_backup passwd $save_dir $backup_dir $pulldown_dir
	check_for_backup shadow $save_dir $backup_dir $pulldown_dir
	check_for_backup group $save_dir $backup_dir $pulldown_dir
	check_for_backup network $save_dir $backup_dir $pulldown_dir
	check_for_backup ifcfg-eth0 $save_dir $backup_dir $pulldown_dir
	check_for_backup krb5.keytab $save_dir $backup_dir
	#check_for_backup root.k5login $save_dir $backup_dir $pulldown_dir
	#check_for_backup enstore.k5login $save_dir $backup_dir $pulldown_dir
	check_for_backup enstorekt $save_dir $backup_dir
	check_for_backup rc.local $save_dir $backup_dir
	if [ \( "$system" == "stken" -o "$system" == "cdfen" -o \
	        "$system" == "d0en" \) -a "$type" == "srv" \
	        -a \( "$number" == "5" -o "$number" == "7" \) ]
	then
		#Only worry about these on console servers.
		check_for_backup conserver.cf $save_dir $backup_dir $pulldown_dir
		check_for_backup cons $save_dir $backup_dir $pulldown_dir
	fi
	check_for_backup cron.tar.gz $save_dir $backup_dir
	check_for_backup root.tar.gz $save_dir $backup_dir
	check_for_backup home.tar.gz $save_dir $backup_dir
fi


#
#We are done with this mount.
#
cd /
sync
umount /mnt/backup
rm -r /mnt/backup

###) 2>&1 ) | tee -a /tmp/save/kickstart.log

%pre
cd /
sync
umount /mnt/tmp


%pre
#
#Put this assignment outside any ( ) redirections.
#
disk_device=`cat /tmp/which_disk`
#
#
((
#
#Formating the disk.
#
echo "Formating the disk." | tee -a /tmp/save/kickstart.log
dd if=/dev/zero of=$disk_device bs=512 count=1
#
) 2>&1 ) | tee -a /tmp/save/kickstart.log
##
fdisk $disk_device <<EOF | tee -a /tmp/save/kickstart.log
n
p
1

+128M

n
p
2

+4104M

t
1
6

t
2
82

n
p
3

+10240M

a
3

n
e



n



n




w
q
EOF

#
((
echo "`date +%H:%M:%S`    -[ new partition table on $disk_device: ]-"
fdisk -l $disk_device | grep "^/dev/" | sed -e "s/^/       /"

mkdosfs ${disk_device}1
mkswap ${disk_device}2
#mke2fs ${disk_device}3
#mke2fs ${disk_device}5
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post --nochroot
#
# Move information from the /tmp area of the install area to that of the
# installed sysimage.
# 

# These are the personality backups.
mkdir /mnt/sysimage/tmp/save
cp -p /tmp/save/* /mnt/sysimage/tmp/save

#These files contain information about networking/hostname information.
cp -p /tmp/netinfo /mnt/sysimage/tmp    #If the old image was lost.
cp -p /tmp/system_name /mnt/sysimage/tmp/
cp -p /tmp/type_name /mnt/sysimage/tmp/
cp -p /tmp/number_name /mnt/sysimage/tmp/
cp -p /tmp/host_name /mnt/sysimage/tmp/
cat /mnt/sysimage/tmp/save/network | tee -a /mnt/sysimage/tmp/save/test.log

%post
# Mount the backup/pulldown disk.
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Mounting 'srv3' backup disk
#
if [ "$system" == "stken" ]; then
	srv3_ip=131.225.13.3
elif [ "$system" == "d0en" ]; then
	srv3_ip=131.225.164.23
elif [ "$system" == "cdfen" ]; then
	srv3_ip=131.225.215.5
else
	echo "Hostname not set."
fi
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
pulldown_dir="/mnt/backup/backup/"
pulldown_dir2="/mnt/backup/backup/pulldown"
#
#
((
echo "  Mounting ${system}srv3 backup disk for restoring."
mkdir -p /mnt/backup
if [ "$type" == "srv" -a "$number" == "3" ]; then
        mount -L /diskc /mnt/backup
else
	service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq "0" ]; then
	   echo "Done mounting backup disk."
	fi
	service portmap stop
	df -h
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/kickstart.log
	while [ 1 ]; do sleep 1; done
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
# Shortcut variables.
#   $pulldown_dir = The remote directory that some files are downloaded.
#
pulldown_dir="/mnt/backup/backup/"
pulldown_dir2="/mnt/backup/backup/pulldown"
#
#
# Do things specific to each server.
#
if [ "$system" == "stken" -o "$system" == "d0en" -o "$system" == "cdfen" ]; then

   install_rpm_xfsprogs="1" #All nodes get this.

   if [ "$type" == "srv" ]; then
      
      if [ "$number" == "0" ]; then
	 
	 install_tarball_postgres="1"

      elif [ "$number" == "1" ]; then

	 install_tarball_postgres="1"
	 install_tarball_pnfs="1"
	 install_rpm_java="1"
	 install_tarball_dcache="1"

      elif [ "$number" == "2" ]; then

         install_upd_apache="1"
	 install_rpm_apache="1"
	 install_upd_remedy_api="1"
	 install_rpm_gnuplot="1"

      elif [ "$number" == "3" ]; then

         install_rpm_java="1"
	 install_upd_dcache_clients="1"
	 install_rpm_console_server="1"
	 install_rpm_gnuplot="1"

      elif [ "$number" == "4" ]; then
      
         install_tarball_aci="1"

      elif [ "$number" == "5" ]; then

         install_rpm_console_server="1"

      elif [ "$number" == "6" ]; then

         install_rpm_tarball_postgres="1"

      elif [ "$number" == "7" ]; then

         install_rpm_console_server="1"

      elif [ "$number" == "8" ]; then

         echo "" > /dev/null
         
      elif [ "$number" == "9" ]; then

         install_rpm_console_server="1"

      fi
   elif [ "$type" == "pnfs" ]; then
     #These are for extra pnfs servers.
     install_tarball_postgres="1"
     install_tarball_pnfs="1"
     install_rpm_java="1"
     install_tarball_dcache="1"
   fi
elif [ "$system" == "rip" ]; then
     #Place rip specific stuff here.
     echo "Performing rip specific installs." | tee -a /tmp/save/kickstart.log
fi

#
#Do the following for all mass storage nodes.
#
install_tarall_python="1"
install_tarball_ipmi="1"
install_tarball_enstore="1"
install_upd_swig="1"
install_upd_ftt="1"
install_upd_ngop="1"

#
#
# Permform the system specific installs.
#
# RPMs go first.
#
# xfsprogs rpm
if [ "$install_rpm_xfsprogs" == "1" ]; then
   additional_rpms="xfsprogs xfsprogs-devel $additional_rpms"
fi
#
# Java
#
if [ "$install_rpm_java" == "1" ]; then
   #In the future these should be installed via yum.

   "Installing java rpms".
   ((
   rpm -i $pulldown_dir/j2sdk-1_4_2_10-linux-i586.rpm
   rpm -i $pulldown_dir/jdk-1_5_0_06-linux-i586.rpm
   ) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
#
# gnuplot
#
if [ "$install_rpm_gnuplot" == "1" ]; then
   additional_rpms="gnuplot $additional_rpms"
fi
#
# Apache
#
if [ "$install_rpm_apache" == "1" ]; then
   additional_rpms="httpd $additional_rpms"
fi
#
# console_server
#
if [ "$install_rpm_console_server" == "1" ]; then
   mkdir -p /var/log/conserver   

   additional_rpms="ConsoleServer-tag ConsoleServer-tree $additional_rpms"
   additional_rpms="XFree86 $additional_rpms"
fi
echo "Install these additional rpms:" | tee -a /tmp/save/kickstart.log
echo "$additional_rpms" | tee -a /tmp/save/kickstart.log
#
# Start these updates from contrib area.  It can/will take a while, better
# to start it in parallel with the other updates.  The yum.conf.contrib
# should include all the regular rpm areas too.
#
yum -y -c /etc/yum.conf.contrib install $additional_rpms >> /dev/null &
#
#
# Begginning ups install.
#
#
# Regardless if /fnal or /local is the real directory, set the other one
# to be a symbolic link to it.
if [ -d /local ]; then
	cd /
	ln -s local fnal
elif [ -d /fnal ]; then
	cd /
	ln -s fnal local
fi
mkdir -p /root
mkdir -p /home/enstore
chown 5744.6209 /home/enstore
echo "  Beginning ups installs." | tee -a /tmp/save/kickstart.log
. /fnal/ups/etc/setups.sh
setup upd
#
# Apache
#
if [ "$install_upd_apache" == "1" ]; then
   upd install -G "-c" -c apache | tee -a /tmp/save/kickstart.log
fi
#
# remedy_api
#
if [ "$install_upd_remedy_api" == "1" ]; then
   upd install -G "-c" -c remedy_api | tee -a /tmp/save/kickstart.log
fi
#
# dcache_clients
#
if [ "$install_upd_dcache_clients" == "1" ]; then
   upd install -G "-c" -c dcap | tee -a /tmp/save/kickstart.log
   upd install -G "-c" -c kftp | tee -a /tmp/save/kickstart.log
   upd install -G "-c" -c srmcp | tee -a /tmp/save/kickstart.log
fi
#
# swig
#
if [ "$install_upd_swig" == "1" ]; then
   upd install -G "-c" swig | tee -a /tmp/save/kickstart.log
fi
#
# ftt
#
if [ "$install_upd_ftt" == "1" ]; then
   upd install ftt -G "-c" v2_22 | tee -a /tmp/save/kickstart.log
   upd install ftt v2_18 | tee -a /tmp/save/kickstart.log
fi
#
# ngop
#
if [ "$install_upd_ngop" == "1" ]; then
   upd install -G "-c" -c fcslib | tee -a /tmp/save/kickstart.log
   upd install -G "-c" -c ngop | tee -a /tmp/save/kickstart.log
   upd install -G "-q agent" -q agent -c ngop | tee -a /tmp/save/kickstart.log
   ups declare -c -f Linux -m v2_1a.table -r ngop/v2_1a/Linux-agent ngop v2_1a
   chown -R 1342.4525 /fnal/ups 
fi
#
#
# Lastly, install the tarballs.
# 
# XXX - These tarballs need to come from somewhere.  That will most likely
# be *srv3.  So, this will likely be moved to the next %post section.

# PostgreSQL
if [ "$install_tarball_postgres" == "1" ]; then
   echo "Installing postgres from tarball." | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/postgres.tar.gz | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/postgres_db.tar.gz | tee -a /tmp/save/kickstart.log
fi
# PNFS
if [ "$install_tarball_pnfs" == "1" ]; then
   echo "Installing pnfs from tarball." | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/pnfs.tar.gz | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/pnfs_db.tar.gz | tee -a /tmp/save/kickstart.log
fi
# dCache
if [ "$install_tarball_dcache" == "1" ]; then
   echo "No-op for install of dCache."
fi
#Python
if [ "$install_tarball_python" == "1" ]; then
   echo "Installing python from tarball." | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/prd/
   tar zxf $pulldown_dir/python.tar.gz | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/python_db.tar.gz | tee -a /tmp/save/kickstart.log
fi
#Enstore
if [ "$install_tarball_enstore" == "1" ]; then
   echo "Installing enstore db from tarball." | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/enstore_db.tar.gz | tee -a /tmp/save/kickstart.log
fi
#IPMI
if [ "$install_tarball_ipmi" == "1" ]; then
   echo "Installing ipmi db from tarball." | tee -a /tmp/save/kickstart.log
   cd /fnal/ups/db/
   tar zxf $pulldown_dir/ipmi_db.tar.gz | tee -a /tmp/save/kickstart.log
fi

#We should wait for yum to finish before continuing.
echo "Waiting for yum update/install to complete."
wait


%post
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
if [ "$type" == "pnfs" ]; then
   use_name=`echo $hostname | sed 's/pnfs.*//'`
else
   use_name=$system
fi
backup_dir="/mnt/backup/backup/$use_name/$type/$number"
pulldown_dir="/mnt/backup/backup/"
pulldown_dir2="/mnt/backup/backup/pulldown"
#
#
#
# Unwinding tar files 
#
#
echo "  Unwinding personality tar files." | tee -a /tmp/save/kickstart.log
mkdir /home /home/enstore
chown 5744.6209 /home/enstore

cd /
echo " ...home.tar.gz" | tee -a /tmp/save/test.log
if [ -f $save_dir/home.tar.gz ]; then
	tar zxf $save_dir/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f $backup_dir/home.tar.gz ]; then
	tar zxf $backup_dir/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f $pulldown_dir/$use_name/$type/home.tar.gz ] ; then
	tar zxf $pulldown_dir/$use_name/$type/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f $pulldown_dir/$use_name/home.tar.gz ] ; then
	tar zxf $pulldown_dir/$use_name/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f $pulldown_dir/home.tar.gz ] ; then
	tar zxf $pulldown_dir/home.tar.gz | tee -a /tmp/save/test.log
else
	echo "No home.tar.gz file found to unpack." | tee -a /tmp/save/test.log
fi

cd /var/spool
echo " ...cron.tar.gz" | tee -a /tmp/save/test.log
if [ -f $save_dir/cron.tar.gz ]; then
	tar zxf $save_dir/cron.tar.gz | tee -a /tmp/save/test.log
elif [ -f $backup_dir/cron.tar.gz ]; then
	tar zxf $backup_dir/cron.tar.gz | tee -a /tmp/save/test.log
elif [ -f $pulldown_dir/cron.tar.gz ] ; then
	tar zxf $pulldown_dir/cron.tar.gz | tee -a /tmp/save/test.log
else
	echo "No cron.tar.gz file found to unpack." | tee -a /tmp/save/test.log
fi

cd /
echo " ...root.tar.gz" | tee -a /tmp/save/test.log
if [ -f $save_dir/root.tar.gz ]; then
	tar zxf $save_dir/root.tar.gz | tee -a /tmp/save/test.log
elif [ -f $backup_dir/root.tar.gz ]; then
	tar zxf $backup_dir/root.tar.gz | tee -a /tmp/save/test.log
elif [ -f $pulldown_dir/root.tar.gz ] ; then
	tar zxf $pulldown_dir/root.tar.gz | tee -a /tmp/save/test.log
else
	echo "No root.tar.gz file found to unpack." | tee -a /tmp/save/test.log
fi

#cd /var/spool; tar xzf $save_dir/cron.tar.gz
#cd /; tar xzf $save_dir/root.tar.gz


#Update the farmlets so that rgang can be used to fix stuff later.
mkdir -p /usr/local/etc /usr/local/etc/farmlets
cd /usr/local/etc/farmlets
echo " ...farmlets.tar.gz" | tee -a /tmp/save/test.log
tar zxf $pulldown_dir/farmlets.tar.gz | tee -a /tmp/save/test.log

#Install Java.
cd 
if [ "$type" == "srv" -a "$number" == "1" -o "$type" == "pnfs"]; then
   rpm -i $pulldown_dir/j2sdk-1_4_2_10-linux-i586.rpm
   rpm -i $pulldown_dir/jdk-1_5_0_06-linux-i586.rpm
fi
#
# Restoring personality files.
#
echo "  Restoring personality files." | tee -a /tmp/save/kickstart.log

echo "  Installing passwd, shadow and group files."
copy_it $pulldown_dir/passwd /etc
copy_it $pulldown_dir/shadow /etc
copy_it $pulldown_dir/group /etc

copy_it $save_dir/fstab /etc
if [ $? -eq 1 ] ;then
	copy_it $backup_dir/fstab /etc
fi
copy_it $save_dir/krb5.keytab /etc
if [ ! -f /etc/krb5.keytab ] ;then
	copy_it $backup_dir/krb5.keytab /etc
fi

#We want to generate these from the m4 files.
#copy_it $save_dir/root.k5login /root/.k5login
#if [ ! -f /root/.k5login ] ;then
#	copy_it $backup_dir/root.k5login /root/.k5login
#fi
#copy_it $save_dir/enstore.k5login /home/enstore/.k5login
#if [ ! -f /home/enstore/.k5login ] ;then
#	copy_it $backup_dir/enstore.k5login /home/enstore/.k5login
#fi

mkdir /fnal /fnal/ups /fnal/ups/kt
copy_it $save_dir/enstorekt /fnal/ups/kt/enstorekt
if [ ! -f /fnal/ups/kt/enstorekt ] ;then
	copy_it $backup_dir/enstorekt /fnal/ups/kt/enstorekt
fi
chown 5744.6209 /fnal/ups/kt/enstorekt
copy_it $pulldown_dir/rc.local /etc/rc.d
if [ $? -eq 1 ] ;then
	copy_it $backup_dir/rc.local /etc/rc.d/rc.local
fi

### Don't clobber the newly generated files anymore.
#copy_it $save_dir/network /etc/sysconfig/network
#if [ $? -eq 1 ] ;then
#	copy_it $backup_dir/network /etc/sysconfig/network
#fi
### Don't clobber the newly generated files anymore.
#copy_it $save_dir/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
#if [ $? -eq 1 ] ;then
#	copy_it $backup_dir/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
#fi

mkdir -p /home/enstore
copy_it $save_dir/enstore.k5login /home/enstore/.k5login
if [ $? -eq 1 ]; then
	copy_it $backup_dir/enstore.k5login /home/enstore/.k5login
fi
chown 5744.6209 /home/enstore/.k5login

copy_it $pulldown_dir/init.d.network /etc/rc.d/init.d/network
chown 0.0 /etc/rc.d/init.d/network

if [ -f $save_dir/pnfsSetup ]; then
	copy_it $save_dir/pnfsSetup /usr/etc/
	chown 0.0 /usr/etc/pnfsSetup
elif [ -f $backup_dir/pnfsSetup ]; then
	copy_it $backup_dir/pnfsSetup /usr/etc/
	chown 0.0 /usr/etc/pnfsSetup
fi

#
# The next two should only apply to console servers.
#
if [ -f $save_dir/conserver.cf ]; then
	copy_it $save_dir/conserver.cf /etc/
	chown 0.0 /etc/conserver.cf
elif [ -f $backup_dir/conserver.cf ]; then
	copy_it $backup_dir/conserver.cf /etc/
	chown 0.0 /etc/conserver.cf
fi
if [ -f $save_dir/cons ]; then
	copy_it $save_dir/cons /usr/local/bin/
	chown 0.0 /usr/local/bin/cons
	chmod a+x /usr/local/bin/cons
elif [ -f $backup_dir/cons ]; then
	copy_it $backup_dir/cons /usr/local/bin/
	chown 0.0 /usr/local/bin/cons
	chmod a+x /usr/local/bin/cons
fi


copy_it $pulldown/$system.hosts.allow /etc/hosts.allow
copy_it $pulldown/hosts /etc/hosts >>/tmp/save/test.log
chown 0.0 /etc/hosts.allow
chown 0.0 /etc/hosts 

copy_it /local/ups/prd/ups/v4_7_2/Linux-2/init.d/ups /etc/rc.d/init.d/

cd /etc/rc.d/rc6.d/
ln -s ../init.d/ups K01ups
cd /etc/rc.d/rc3.d
ln -s ../init.d/ups S99ups

echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/shutdown/$hostname.products
echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
echo "ups start ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/startup/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/startup/$hostname.products

rm /home/enstore/*.fnal.gov.startup #Remove old copies...
touch /home/enstore/$hostname.fnal.gov.startup
chown 5744.6209 /home/enstore/$hostname.fnal.gov.startup


%post
#
#Finally, we are done with this.
#
umount /mnt/backup
/bin/rm -r /mnt/backup


%post
((
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
# Turning services on and off.
#
echo "  Turning services on and off." | tee -a /tmp/save/kickstart.log
/sbin/chkconfig autofs off
/sbin/chkconfig netfs off
/sbin/chkconfig netlock off
/sbin/chkconfig xfs off
/sbin/chkconfig ftp on
/sbin/chkconfig eklogin on
/sbin/chkconfig klogin on
/sbin/chkconfig kshell on
/sbin/chkconfig telnet on
/sbin/chkconfig netperf on
/sbin/chkconfig yum off
/sbin/chkconfig isdn off
/sbin/chkconfig pcmcia off
/sbin/chkconfig portmap off
/sbin/chkconfig mdmonitor off
/sbin/chkconfig mdmpd off
/sbin/chkconfig apmd off
/sbin/chkconfig nfslock off
/sbin/chkconfig rhnsd off
rm -f /etc/cron.daily/00-logwatch
rm -f /etc/cron.daily/0anacron
rm -f /etc/cron.daily/yum.cron
if [ "$type" == "mvr" -o "$type" == "dm" ]; then
   # We need to worry about this for dCache nodes.  It appears that the
   # head node and monitor node (door node too?) have sendmail enabled,
   # but pool nodes do not.  In the meantime, only Enstore servers
   # get sendmail turned on.

   /sbin/chkconfig sendmail off
   rm -f /etc/mail/submit.*
fi
) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post --nochroot
#
# Try putting the user and groups for users root and enstore to see if
# su really can work if these files are correct.  The installed versions
# should be correct, these only put information into the install environment.
# 
grep "^enstore" /mnt/sysimage/etc/passwd >> /etc/passwd
grep "^root" /mnt/sysimage/etc/group >> /etc/group
grep "^enstore" /mnt/sysimage/etc/group >> /etc/group

%post
#
# Enstore home area stuff.
#
#
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/kickstart.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/kickstart.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
#
#
# Get these values from previous %pre.
#
system=`cat /tmp/system_name`
type=`cat /tmp/type_name`
number=`cat /tmp/number_name`
hostname=`cat /tmp/host_name`
#
#
echo "  Beginning enstore home area stuff." | tee -a /tmp/save/kickstart.log
id enstore | tee -a /tmp/save/kickstart.log
( if [ "1" ]; then
	#
	#checkout enstore and ipmi
	#
	echo "Beginning cvs checkouts for enstore and ipmi."
	#grep "enstore" /etc/passwd  #does user enstore exist?
	export CVSROOT=hppccvs@cdcvs.fnal.gov:/cvs/hppc
	export CVS_RSH=/usr/krb5/bin/rsh
	mkdir -p /home/enstore
	cd /home/enstore

	short_hostname=`echo $hostname | cut -f 1 -d "."`
	krb5_principal="enstore/cd/${short_hostname}.fnal.gov@FNAL.GOV"
	if [ ! -s /home/enstore/.k5login ]; then
	   #If we don't have an enstore .k5login file, create a temporary
	   # one for getting kinit to work.
	   echo "$krb5_principal" > /home/enstore/.k5login
	fi

	echo /usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt $krb5_principal
	/usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt $krb5_principal

	if [ -d /home/enstore/enstore ]; then
		cd /home/enstore/enstore
		cvs update -r production
	else
		cd /home/enstore
		cvs checkout -r production enstore
	fi
	if [ -d /home/enstore/ipmi ]; then
		cd /home/enstore/ipmi
		cvs update ipmi
	else
		cd /home/enstore
		cvs checkout ipmi
	fi
fi 2>&1 ) | tee -a /tmp/save/kickstart.log
if [ -d /home/enstore/enstore ]; then
	#
	#build enstore and ipmi
	#
	echo "Beginning enstore and ipmi builds." | tee -a /tmp/save/kickstart.log
	((
	cd /home/enstore/enstore/modules
	make clean
	source /usr/local/etc/setups.sh
	setup enstore
	make
	cd /home/enstore/ipmi
	make
	) 2>&1 ) | tee -a /tmp/save/kickstart.log
fi
if [ -d /home/enstore/enstore ]; then
	#
	# Begin copying the following files to their needed locations.
	#
	echo "Copying enstore files to their needed locations." | tee -a /tmp/save/kickstart.log
	copy_it /home/enstore/enstore/bin/enstore-boot /etc/rc.d/init.d/
	chown 0.0 /etc/rc.d/init.d/enstore-boot
	ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc3.d/S99zzzenstore-boot
	ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc6.d/K01aaaenstore-boot
	copy_it /home/enstore/enstore/bin/monitor_server-boot /etc/rc.d/init.d
	chown 0.0 /etc/rc.d/init.d/monitor_server-boot
	ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc3.d/S99zzzmonitor_server-boot
	ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc6.d/K01aaamonitor_server-boot
	copy_it /home/enstore/enstore/etc/enstore.bashrc /home/enstore/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /home/enstore/.bash_profile
	#Where do the root/.bashrc and root/.bash_profile files come from?
	copy_it /home/enstore/enstore/etc/enstore.bashrc /root/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /root/.bash_profile
	copy_it /home/enstore/enstore/etc/sudoers /etc/
	chmod 0440 /etc/sudoers
	chown 0.0 /etc/sudoers
	copy_it /home/enstore/enstore/sbin/routes /root/
	chown 0.0 /root/routes
	copy_it /home/enstore/enstore/etc/products.k5login /local/ups/.k5login
	chown 1342.4525 /local/ups/.k5login
	chmod 0664 /local/ups/.k5login
	if [ -n $system ]; then
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/root.k5login.m4 > /tmp/root.k5login 2>> /tmp/save/kickstart.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/root.k5login /root/.k5login
			chown 0.0 /root/.k5login
		fi
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/$system.enstore.k5login.m4 > /tmp/enstore.k5login 2>> /tmp/save/kickstart.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/enstore.k5login /home/enstore/.k5login
			chown 5744.6209 /home/enstore/.k5login
		fi
		copy_it /home/enstore/enstore/etc/$system.hosts.allow /etc/hosts.allow
		chown 0.0 /etc/hosts.allow
		copy_it /home/enstore/enstore/etc/$system.step-tickers /etc/ntp/step-tickers
		chown 0.0 /etc/ntp/step-tickers
	fi
	copy_it /home/enstore/enstore/etc/ups /etc/rc.d/init.d/ups
	chown 0.0 /etc/rc.d/init.d/ups
	copy_it /home/enstore/enstore/etc/ntp.conf /etc/ntp.conf
	chown 0.0 /etc/ntp.conf
	copy_it /home/enstore/enstore/etc/services /etc/services
	chown 0.0 /etc/services
	mkdir /var/ngop /var/ngop/include /var/ngop/cron_agent /var/ngop/plugins_agent
	copy_it "/home/enstore/enstore/ngop/*.py" /var/ngop/include
	copy_it /home/enstore/enstore/ngop/raise_enstore_alarm /var/ngop/include
	copy_it /home/enstore/enstore/ngop/local_cronjob.xml /var/ngop/cron_agent
	copy_it /home/enstore/enstore/ngop/start_cron /var/ngop/cron_agent/.start
	chmod 0755 /var/ngop/cron_agent/.start
	if [ "$type" == "mvr" ]; then
		copy_it /home/enstore/enstore/ngop/linuxHealth.xml /var/ngop/plugins_agent/
	elif [ "$type" == "srv" ]; then
		copy_it /home/enstore/enstore/ngop/srv_linuxHealth.xml /var/ngop/plugins_agent/
	fi
	/home/enstore/enstore/sbin/farmlets -f
	chown -R 0.0 /var/ngop
	rm -f /home/enstore/enstore/tmp/enstore/*
	echo "" | tee -a /tmp/save/kickstart.log
	echo "end of enstore home stuff" | tee -a /tmp/save/kickstart.log
fi

#) 2>&1 ) | tee -a /tmp/save/kickstart.log

%post
((
echo ""
echo " Last Few Things "
#  Setup the root and enstore .forward files.
echo "enstore-admin@fnal.gov" > /root/.forward
echo "enstore-admin@fnal.gov" > /home/enstore/.forward
#  Some versions of ftt have these files without execute permissions.
chmod +x /local/ups/prd/ftt/v2_22/Linux-2-4-2-3-2/etc/*
#  By default this file contains three lines, we only want one.
grep /local/ups/db /local/ups/etc/upsdb_list >> /local/ups/etc/upsdb_list.fixed
rm -f /local/ups/etc/upsdb_list
mv /local/ups/etc/upsdb_list.fixed /local/ups/etc/upsdb_list
chmod 0664 /local/ups/etc/upsdb_list
#  Some enstore CRON jobs will look for /PRODUCTION to exist.
touch PRODUCTION
chmod 0644 PRODUCTION
mkdir -p /root/CRON
chmod 0755 /root/CRON
#  Set these permissions...
chown -R 5744.6209 /home/enstore
chown -R 5744.6209 /local/ups/kt/
) 2>&1 ) | tee -a /tmp/save/kickstart.log
