# Kickstart file written by Michael Zalokar & Terry Jones for Enstore.
# $Id$
#

install
lang en_US.UTF-8
langsupport --default en_US.UTF-8 en_US.UTF-8
keyboard us
mouse none
skipx
nfs --server linux.fnal.gov --dir /export/linux/lts305/i386
#network --device eth0 --bootproto static --ip 131.225.164.62 --netmask 255.255.255.0 --gateway 131.225.164.200 --nameserver 131.225.8.120 --hostname d0enload.fnal.gov
#network --device eth1 --bootproto dhcp --hostname stkenmvr12a.fnal.gov
rootpw --iscrypted $1$
firewall --disabled
authconfig --enableshadow --enablemd5 --enablekrb5 --krb5realm FNAL.GOV --krb5kdc krb-fnal-1.fnal.gov:88,krb-fnal-2.fnal.gov:88,krb-fnal-3.fnal.gov:88,krb-fnal-4.fnal.gov:88,krb-fnal-5.fnal.gov:88 --krb5adminserver krb-fnal-admin.fnal.gov
timezone America/Chicago
bootloader --location=mbr
# The following is the partition information you requested
# Note that any partitions you deleted are not expressed
# here so unless you clear all partitions first, this is
# not guaranteed to work
#clearpart --all
#part /dos --fstype vfat --start=1 --end=17 --ondisk=hda --onpart=hda1
#part swap --size=512 --start=18 --end=148  --ondisk=hda --onpart=hda2
#part / --fstype ext3 --start=149 --end=671 --ondisk=hda --onpart=hda3
#part /scratch --fstype ext3 --ondisk=hda --size=1 --grow
#part /dos --ondisk=hda --onpart=hda1
#part swap --size=1024 --ondisk=hda --onpart=hda2
#part / --ondisk=hda --onpart=hda3
#part /scratch --ondisk=hda --size=1 --grow
part /dos --onpart=hda1 --noformat
part swap --onpart=hda2
part /  --onpart=hda3
part /scratch --onpart=hda5

%packages
Fermi-release
GenericFarm-tag
GenericFarm-tree
MAKEDEV
SL_enable_serialconsole
SL_inittab_change
SysVinit
XFree86-Mesa-libGL
XFree86-libs
XFree86-libs-data
Xaw3d
acl
anacron
apmd
ash
at
atk
attr
authconfig
basesystem
bash
bc
beecrypt
bind-libs
bind-utils
binutils
byacc
bzip2
bzip2-libs
chkconfig
compat-db
compat-libstdc++
compat-slang
coreutils
cpio
cpp
cracklib
cracklib-dicts
crontabs
cvs
cyrus-sasl
cyrus-sasl-gssapi
cyrus-sasl-md5
cyrus-sasl-plain
db4
db4-devel
db4-utils
dev
devlabel
dhclient
diffutils
dos2unix
dosfstools
dump
e2fsprogs
e2fsprogs-devel
ed
eject
elfutils
elfutils-libelf
emacs
ethtool
expat
fbset
file
filesystem
findutils
finger
flpr
fontconfig
freetype
ftp
gawk
gcc
gcc-c++
gcc-java
gd
gdb
gdbm
gdbm-devel
gettext
glib
glib-devel
glib2
glib2-devel
glibc
glibc-common
glibc-debug
glibc-devel
glibc-headers
glibc-kernheaders
glibc-profile
glibc-utils
gmp
gnupg
gpm
grep
groff
grub
gtk2
gzip
hdparm
hesiod
hotplug
htmlview
hwdata
info
initscripts
iproute
ipsec-tools
iptables
iptables-ipv6
iputils
irda-utils
isdn4k-utils
jfsutils
jwhois
kbd
kernel
kernel-doc
kernel-pcmcia-cs
kernel-smp
kernel-utils
krb5-fermi-config
krb5-libs
krb5-libs-fermi
krb5-workstation
krb5-workstation-fermi
krbafs
kudzu
laus-libs
less
lftp
lha
libacl
libattr
libcap
libdbi
libdbi-devel
libgcc
libgcj
libgcj-devel
libjpeg
libpng
libstdc++
libstdc++-devel
libtermcap
libtermcap-devel
libtiff
libtool-libs
libungif
libuser
libwvstreams
libxml2
libxml2-python
lilo
lockdev
logrotate
logwatch
losetup
lslk
lsof
lvm
m4
mailcap
mailx
make
man
man-pages
mdadm
mgetty
mingetty
minicom
mkbootdisk
mkinitrd
mktemp
modutils
mount
mt-st
mtools
mtr
nano
nc
ncompress
ncurses
ncurses-devel
ncurses4
net-tools
netconfig
netdump
newt
nfs-utils
nscd
nss_ldap
ntp
ntsysv
openldap
openssh
openssh-clients
openssl
pam
pam_krb5
pam_smb
pango
parted
passwd
patch
pax
pciutils
pcre
pdksh
perl
perl-Filter
perl-HTML-Parser
perl-HTML-Tagset
perl-URI
perl-libwww-perl
pinfo
pkgconfig
popt
portmap
ppp
prelink
procps
psacct
psmisc
pyOpenSSL
pygtk2
python
python-optik
pyxf86config
quota
raidtools
rdate
rdist
readline
readline-devel
redhat-config-language
redhat-config-mouse
redhat-config-network-tui
redhat-config-securitylevel-tui
redhat-logos
redhat-lsb
redhat-menus
rhnlib
rhpl
rmt
rootfiles
rp-pppoe
rpm
rpm-libs
rpm-python
rsh
rsync
schedutils
sed
sendmail
sendmail-cf
sendmail-devel
sendmail-doc
setarch
setserial
setup
setuptool
shadow-utils
sharutils
slang
slang-devel
slocate
specspo
star
stunnel
sudo
symlinks
sysklogd
syslinux
sysreport
sysstat
talk
tar
tcl
tcp_wrappers
tcpdump
tcsh
telnet
termcap
tftp
time
tmpwatch
traceroute
tzdata
unix2dos
unzip
up2date
upsupdbootstrap
upsupdbootstrap-generic
usbutils
usermode
utempter
util-linux
vconfig
vim-common
vim-minimal
vixie-cron
wget
which
wireless-tools
words
wvdial
xinetd
xterm
yp-tools
ypbind
yum
yum-conf
zip
zlib
zlib-devel
zz_cups_nobrowse
zz_dhcp_resolv
zz_fermi-logos
zz_firstboot_fix
zz_lang_collate
zz_logwatch_df
zz_ntp_configure
zz_pine_user_domain
zz_sendmail_fermi_gateway
zz_tcp_wrappers_change

%pre
#
# Make the directory where we will locally save the personality of the node.
#
mkdir /tmp/save
#
# Mount the existing root directory on the node.
#
mkdir /mnt/tmp
mount /dev/hda3 /mnt/tmp

%pre
#If called do not proceed with the install.
abort_install ( )
{
	echo $* | tee -a /tmp/save/test.log
	while [ 1 ]; do sleep 1; done
}
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	if [ ! -f "$1" -a ! -d "$1" ]; then
		return 2;
	fi

	echo "copying $1 to $2" | tee -a /tmp/save/test.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/test.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	abort_install "Unable to backup file $1.  Aborting install."
        
	return 1; # Not reached.
}
copy_it /mnt/tmp/etc/fstab /tmp/save
copy_it /mnt/tmp/etc/passwd /tmp/save
copy_it /mnt/tmp/etc/shadow /tmp/save
copy_it /mnt/tmp/etc/group /tmp/save
copy_it /mnt/tmp/etc/sysconfig/network /tmp/save
copy_it /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth0 /tmp/save
copy_it /mnt/tmp/etc/krb5.keytab /tmp/save
copy_it /mnt/tmp/root/.k5login /tmp/save/root.k5login
copy_it /mnt/tmp/home/enstore/.k5login /tmp/save/enstore.k5login
copy_it /mnt/tmp/fnal/ups/kt/enstorekt /tmp/save
copy_it /mnt/tmp/etc/rc.d/rc.local /tmp/save
if [ -f /mnt/tmp/etc/conserver.cf ]; then
	copy_it /mnt/tmp/etc/conserver.cf /tmp/save
fi
if [ -f /mnt/tmp/usr/local/bin/cons ]; then
	copy_it /mnt/tmp/usr/local/bin/cons /tmp/save
fi
mkdir -p /mnt/tmp/var/spool/cron
cd /mnt/tmp/var/spool; tar cz cron > /tmp/save/cron.tar.gz
if [ $? -ne 0 ]; then
	echo "Abort taring crons." | tee -a /tmp/save/test.log
	while [ 1 ]; do sleep 1; done
fi
mkdir -p /mnt/tmp/root
cd /mnt/tmp; tar cz root > /tmp/save/root.tar.gz
if [ $? -ne 0 ]; then
	echo "Abort taring root." | tee -a /tmp/save/test.log
	while [ 1 ]; do sleep 1; done
fi
mkdir -p /mnt/tmp/home
cd /mnt/tmp; tar cz home > /tmp/save/home.tar.gz
if [ $? -ne 0 ]; then
	echo "Abort taring home." | tee -a /tmp/save/test.log
	while [ 1 ]; do sleep 1; done
fi
cd /

#
# Record what got copied.
#
echo "What got copied."
ls -lh /tmp/save | tee -a /tmp/save/test.log


%pre
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.  If the file exists, but fails to copy
# we will abort the install.
copy_it ( )
{
	if [ ! -f "$1" -a ! -d "$1" ]; then
		return 2;
	fi

	echo "copying $1 to $2" | tee -a /tmp/save/test.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/test.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done

	echo "Unable to backup file $1.  Aborting install." | tee -a /tmp/save/test.log
	while [ 1 ]; do sleep 1; done
        
	return 1; # Not reached.
}
#
# parse the host name
#
hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/save/network | cut -c 10-`
if [ -n $hostname ]; then
	case $hostname in
		stken*)
			system=stken
			rest=`echo $hostname | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $hostname | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $hostname | cut -c 5-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		srv*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		*)
			type=""
			number=""
			;;
	esac

	echo "This is the type $type and the instance $number of the $system system."
else
	echo "Hostname not set."
	exit 1
fi
#
# Mounting 'srv3' backup disk
#
if [ $system = "stken" ]; then
        srv3_ip=131.225.13.3
elif [ $system = "d0en" ]; then
        srv3_ip=131.225.164.23
elif [ $system = "cdfen" ]; then
        srv3_ip=131.225.215.5
else
        echo "Hostname not set."
	exit 1
fi
mkdir -p /mnt/backup
if [ $type == "srv" -a $number == "3" ]; then
        mount -L /diskc /mnt/backup
else
	echo "  Mounting ${system}srv3 backup disk for backup."
	echo "Mounting ${system}srv3 backup disk for backup." >> /tmp/save/test.log
	mkdir /mnt/backup
	service portmap start
	mount $srv3_ip:/diskc /mnt/backup
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	fi
	service portmap stop
	df -h
fi
#
#Shortcut variables.
#  $save_dir = The local temporary directory the personality is copied to.
#  $backup_dir = The remote directory that the personality is copied to.
#  $pulldown_dir = The remote directory that some files are downloaded.
#
save_dir="/tmp/save"
backup_dir="/mnt/backup/backup/$system/$type/$number"
pulldown_dir="/mnt/backup/backup"
#
# Backing up personality.
#
echo "Backing up personality."
mkdir -p $backup_dir
for file in `ls $save_dir`; do
	if [ ! -f $backup_dir/$file \
	   -o $save_dir/$file -nt $backup_dir/$file ]; then
		copy_it $save_dir/$file $backup_dir/$file
	fi
done

#if [ ! -f $backup_dir/fstab -o /mnt/tmp/etc/fstab -nt $backup_dir/fstab];
#	copy_it /mnt/tmp/etc/fstab $backup_dir
#fi
#if [ ! -f $backup_dir/hostname ];
#	copy_it /mnt/tmp/etc/hostname $backup_dir
#fi
#if [ ! -f $backup_dir/passwd ];
#	copy_it /mnt/tmp/etc/passwd $backup_dir
#fi
#if [ ! -f $backup_dir/shadow ];
#	copy_it /mnt/tmp/etc/shadow $backup_dir
#fi
#if [ ! -f $backup_dir/group ];
#	copy_it /mnt/tmp/etc/group $backup_dir
#fi
#if [ ! -f $backup_dir/network ];
#	copy_it /mnt/tmp/etc/sysconfig/network $backup_dir
#fi
#if [ ! -f $backup_dir/ifcfg-eth0 ];
#	copy_it /mnt/tmp/etc/sysconfig/network-scripts/ifcfg-eth0 $backup_dir
#fi
#if [ ! -f $backup_dir/krb5.keytab ];
#	copy_it /mnt/tmp/etc/krb5.keytab $backup_dir
#fi
#if [ ! -f $backup_dir/root.k5login ];
#	copy_it /mnt/tmp/root/.k5login $backup_dir/root.k5login
#fi
#if [ ! -f $backup_dir/enstore.k5login ];
#	copy_it /mnt/tmp/home/enstore/.k5login $backup_dir/enstore.k5login
#fi
#if [ ! -f $backup_dir/enstorekt ];
#	copy_it /mnt/tmp/local/ups/kt/enstorekt $backup_dir
#fi
#if [ ! -f $backup_dir/rc.local ];
#	copy_it /mnt/tmp/etc/rc.d/rc.local $backup_dir
#fi
#
# The next two should only apply to console servers.
#
#if [ ! -f $backup_dir/conserver.cf -a -f /mnt/tmp/etc/conserver.cf ];
#	copy_it /mnt/tmp/etc/conserver.cf $backup_dir
#fi
#if [ ! -f $backup_dir/cons -a -f /mnt/tmp/usr/local/bin/cons ];
#	copy_it /mnt/tmp/usr/local/bin/cons $backup_dir
#fi
#
#
#if [ -f /tmp/save/cron.tar.gz ]; then
#	echo "Storing cron tarfile."
#	copy_it /tmp/save/cron.tar.gz $backup_dir
#fi
#
#if [ -f /tmp/save/root.tar.gz ]; then
#	echo "Storing root tarfile."
#	copy_it /tmp/save/root.tar.gz $backup_dir
#fi
#
#if [ -f /tmp/save/home.tar.gz ]; then
#	echo "Storing home tarfile."
#	copy_it /tmp/save/home.tar.gz $backup_dir
#fi

#
# Check that there exists all the necessary personality files.
#
abort_install ( )
{
	echo $* | tee -a /tmp/save/test.log
	while [ 1 ]; do sleep 1; done
}
check_for_backup ( )
{
	target=$1
	shift
	
	for dname in $*; do
		if [ -f $dname/$target -o -d $dname/$target]; then
		       return 0;
		fi
	done

	abort_install "Backup of $1 not found.  Aborting install."

	return 1;  #Never reached.
}
#
# Before continueing with the install.  Make sure that we have the personality
# stored away.
#
echo "Checking the consistancy of the personality backup." | tee -a /tmp/save/test.log
if [ -n "$system" -a -n "$type" -a -n "$number" ]; then
	check_for_backup fstab $save_dir $backup_dir
	check_for_backup passwd $save_dir $backup_dir $pulldown_dir
	check_for_backup shadow $save_dir $backup_dir $pulldown_dir
	check_for_backup group $save_dir $backup_dir $pulldown_dir
	check_for_backup network $save_dir $backup_dir $pulldown_dir
	check_for_backup network-scripts $save_dir $backup_dir $pulldown_dir
	check_for_backup krb5.keytab $save_dir $backup_dir
	check_for_backup root.k5login $save_dir $backup_dir $pulldown_dir
	check_for_backup enstore.k5login $save_dir $backup_dir $pulldown_dir
	check_for_backup enstorekt $save_dir $backup_dir
	check_for_backup rc.local $save_dir $backup_dir
	if [ \( "$system" == "stken -o "$system" == "cdfen" -o \
	        "$system" == "d0en" \) -a $type == "srv" \
	        -a \( "$number" == "5" -o "$number" == "7" ) ]
	then
		#Only worry about these on console servers.
		check_for_backup conserver.cf $save_dir $backup_dir $pulldown_dir
		check_for_backup cons $save_dir $backup_dir $pulldown_dir
	fi
	check_for_backup cron.tar.gz $save_dir $backup_dir
	check_for_backup root.tar.gz $save_dir $backup_dir
	check_for_backup home.tar.gz $save_dir $backup_dir
fi

#
#We are done with this mount.
#
cd /
sync
umount /mnt/backup
/bin/rm -r /mnt/backup

%pre
cd /
sync
umount /mnt/tmp


%pre
#
#Formating the disk.
#
echo "Formating the disk." | tee -a /tmp/save/test.log
dd if=/dev/zero of=/dev/hda bs=512 count=1
fdisk /dev/hda <<EOF
n
p
1

+128M

n
p
2

+4104M

t
1
6

t
2
82

n
p
3

+10240M

a
3

n
e



n



n




w
q
EOF

echo "`date +%H:%M:%S`    -[ new partition table on /dev/hda: ]-"
fdisk -l /dev/hda | grep "^/dev/" | sed -e "s/^/       /"

mkdosfs /dev/hda1
mkswap /dev/hda2
#mke2fs /dev/hda3
#mke2fs /dev/hda5

%post --nochroot
mkdir /mnt/sysimage/tmp/save
cp -p /tmp/save/* /mnt/sysimage/tmp/save
cp -p /tmp/netinfo /mnt/sysimage/tmp    #If the old image was lost.
cat /mnt/sysimage/tmp/save/network

%post
#
# parse the host name
#
hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/save/network | cut -c 10-`
if [ -z $hostname ]; then
	hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/netinfo | cut -c 10-`
fi
if [ -n $hostname ]; then
	case $hostname in
		stken*)
			system=stken
			rest=`echo $hostname | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $hostname | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $hostname | cut -c 5-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		srv*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		dca*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		load*)
			type=""
			number=""
			;;
		*)
			type=""
			number=""
			;;
	esac

	echo "This is the type $type and the instance $number of the $system system."
else
	echo "Hostname not set."
fi
#
#All mass storage nodes should define these extra rpms.
#
additional_rpms="xfsprogs xfsprogs-devel"
#
#Do things specific to each server.
#
if [ "$system" == "stken" -o "$system" == "d0en" -o "$system" == "cdfen" ]; then
   echo "Performing $system production system install." | tee -a /tmp/save/test.log
   if [ "$type" == "srv" ]; then

      additional_rpms="gnuplot $additional_rpms"

      if [ \( "$number" == "5" -o "$number" == "7" \) ]; then
	 #Insert console specific stuff here.
	 echo "Performing console specific installs." | tee -a /tmp/save/test.log
	 additional_rpms="console-software console-server zz_conserver_cyc-z $additional_rpms"
	 additional_rpms="XFree86 $additional_rpms"
	 mkdir -p /var/log/conserver

      elif [ "$number" == "0" ]; then
	 #Insert 'srv0' specific stuff here.
	 echo "Performing srv1 specific installs." | tee -a /tmp/save/test.log

      elif [ "$number" == "1" ]; then
         #Insert 'srv1' specific stuff here.
	 echo "Performing srv1 specific installs." | tee -a /tmp/save/test.log

      elif [ "$number" == "2" ]; then
	 #Insert 'srv2' specific stuff here.
	 echo "Performing srv1 specific installs." | tee -a /tmp/save/test.log
      
	 upd install -G "-c" -c remedy_api
	 upd install -G "-c" -c apache

      elif [ "$number" == "3" ]; then
	 #Insert 'srv3' specific stuff here.
	 echo "Performing srv1 specific installs." | tee -a /tmp/save/test.log
	 
	 if [ "$system" == "stken" ]; then
	    mkdir -p /var/log/conserver
	    echo "Performing console specific installs." | tee -a /tmp/save/test.log
            additional_rpms="console-software console-server zz_conserver_cyc-z $additional_rpms"
	    additional_rpms="XFree86 $additional_rpms"      
	 fi

	 upd install -G "-c" -c dcap
	 upd install -G "-c" -c kftp
	 upd install -G "-c" -c srmcp

      elif [ "$number" == "4" ]; then
	 #Insert 'srv4' specific stuff here.
	 echo "Performing srv1 specific installs." | tee -a /tmp/save/test.log
   
      elif [ "$number" == "6" ]; then
         #Insert 'srv6' specific stuff here.
	 echo "Performing srv1 specific installs." | tee -a /tmp/save/test.log
      fi
   fi
elif [ "$system" == "rip" ]; then
     #Place rip specific stuff here.
     echo "Performing rip specific installs." | tee -a /tmp/save/test.log
fi
echo "Install these additional rpms:" | tee -a /tmp/save/test.log
echo "$additional_rpms" | tee -a /tmp/save/test.log
#
# Start these updates from contrib area.  It can/will take a while, better
# to start it in parallel with the other updates.  The yum.conf.contrib
# should include all the regular rpm areas too.
#
yum -y -c /etc/yum.conf.contrib install $additional_rpms >> /dev/null &
#
# Begginning ups install.
#
#
# Regardless if /fnal or /local is the real directory, set the other one
# to be a symbolic link to it.
if [ -d /local ]; then
	cd /
	ln -s local fnal
elif [ -d /fnal ]; then
	cd /
	ln -s fnal local
fi
mkdir -p /root
mkdir -p /home/enstore
chown 5744.6209 /home/enstore
echo "  Beginning ups installs."
. /fnal/ups/etc/setups.sh
setup upd
upd install -G "-c" swig
upd install ftt -G "-c" v2_22 
upd install ftt v2_18
upd install -G "-c" -c fcslib
upd install -G "-c" -c ngop
upd install -G "-q agent" -q agent -c ngop
chown -R 1342.4525 /fnal/ups 

#We should wait for yum to finish before continuing.
echo "Waiting for yum update/install to complete."
wait

%post
#
# parse the host name
#
hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/save/network | cut -c 10-`
if [ -z $hostname ]; then
	hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/netinfo | cut -c 10-`
fi
if [ -n $hostname ]; then
	case $hostname in
		stken*)
			system=stken
			rest=`echo $hostname | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $hostname | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $hostname | cut -c 5-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		srv*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		dca*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		load*)
			type=""
			number=""
			;;
		*)
			type=""
			number=""
			;;
	esac

	echo "This is the type $type and the instance $number of the $system system."
else
	echo "Hostname not set."
fi
#
# Mounting 'srv3' backup disk
#
if [ $system = "stken" ]; then
	srv3_ip=131.225.13.3
elif [ $system = "d0en" ]; then
	srv3_ip=131.225.164.23
elif [ $system = "cdfen" ]; then
	srv3_ip=131.225.215.5
else
	echo "Hostname not set."
fi
echo "  Mounting ${system}srv3 backup disk for restoring." | tee -a /tmp/save/test.log
mkdir -p /mnt/backup
if [ "$type" == "srv" -a "$number" == "3" ]; then
        mount -L /diskc /mnt/backup
else
	service portmap start
	mount $srv3_ip:/diskc /mnt/backup | tee -a /tmp/save/test.log
	if [ $? -eq 0 ]; then
	   echo "Done mounting backup disk."
	fi
	service portmap stop
	df -h
fi
#
# Unwinding tar files 
#
#if [ -n "$system" -a -n "$type" -a -n "$number" ]; then
#
echo "  Unwinding personality tar files." | tee -a /tmp/save/test.log
mkdir /home /home/enstore
chown/ 5744.6209 /home/enstore
cd /
echo " ...home.tar.gz" | tee -a /tmp/save/test.log
if [ -f /tmp/save/home.tar.gz ]; then
	tar zxf /tmp/save/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f /mnt/backup/backup/$system/$type/$number/home.tar.gz ]; then
	tar zxf /mnt/backup/backup/$system/$type/$number/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f /mnt/backup/backup/$system/$type/home.tar.gz ] ; then
	tar zxf /mnt/backup/backup/$system/$type/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f /mnt/backup/backup/$system/home.tar.gz ] ; then
	tar zxf /mnt/backup/backup/$sytem/home.tar.gz | tee -a /tmp/save/test.log
elif [ -f /mnt/backup/backup/home.tar.gz ] ; then
	tar zxf /mnt/backup/backup/home.tar.gz | tee -a /tmp/save/test.log
else
	echo "No home.tar.gz file found to unpack." | tee -a /tmp/save/test.log
fi


#Unpack this enstore tarball onto the enstore home area.  This will likely
# clobber the enstore source with an older version, but is needed so that
# the properly compiled version (for the OS we're upgrading to) can be
# installed for things like ipmi.  This should be fixed by getting CVS
# updates to work from within this install script.
cd /home
echo " ...enstore.tar.gz" | tee -a /tmp/save/test.log
tar zxf /mnt/backup/backup/enstore.tar.gz | tee -a /tmp/save/test.log
#Install some of our privatly compiled ups products.  And their DB entries
# so that ups knows what it has to run.  Note: ipmi and enstore DB tars
# are listed; their product counterparts should be in the home.tar.gz
# (failing that enstore.tar.gz) enstore directory.
cd /fnal/ups/db
echo " ...enstore_db.tar.gz" | tee -a /tmp/save/test.log
tar zxf /mnt/backup/backup/enstore_db.tar.gz | tee -a /tmp/save/test.log
echo " ...ipmi_db.tar.gz" | tee -a /tmp/save/test.log
tar zxf /mnt/backup/backup/ipmi_db.tar.gz | tee -a /tmp/save/test.log
echo " ...python_db.tar.gz" | tee -a /tmp/save/test.log
tar zxf /mnt/backup/backup/python_db.tar.gz | tee -a /tmp/save/test.log
if [ \( "$system" == "cdfen" -o "$system" == "d0en" -o "$system" == "stken" \) \
   -a \( "$type" == "srv" \) ]; then
     #Only on servers.
     echo " ...aci_db.tar.gz" | tee -a /tmp/save/test.log
     tar zxf /mnt/backup/backup/aci_db.tar.gz | tee -a /tmp/save/test.log
fi
if [ \( "$system" == "cdfen" -o "$system" == "d0en" -o "$system" == "stken" \) \
   -a \( "$type" == "srv" -o "$type" == "dm" \) \
   -a \( "$number" == "0" -o "$number" == "1" -o "$number" == "2" \
        -o "$number" == "4" -o "$number" == "6" \) ]; then
     #Only on some servers.
     echo " ...postgres_db.tar.gz" | tee -a /tmp/save/test.log
     tar zxf /mnt/backup/backup/postgres_db.tar.gz | tee -a /tmp/save/test.log
fi
#Always make sure that the version of python in this tarball is compiled
# for the OS version we are upgrading to.
cd /fnal/ups/prd/
echo " ...python.tar.gz" | tee -a /tmp/save/test.log
tar zxf /mnt/backup/backup/python.tar.gz | tee -a /tmp/save/test.log
if [ \( "$system" == "cdfen" -o "$system" == "d0en" -o "$system" == "stken" \) \
   -a \( "$type" == "srv" \) ]; then
     #Only on servers.
     echo " ...aci.tar.gz" | tee -a /tmp/save/test.log
     tar zxf /mnt/backup/backup/aci.tar.gz | tee -a /tmp/save/test.log
fi
if [ \( "$system" == "cdfen" -o "$system" == "d0en" -o "$system" == "stken" \) \
   -a \( "$type" == "srv" -o "$type" == "dm" \) \
   -a \( "$number" == "0" -o "$number" == "1" -o "$number" == "2" \
        -o "$number" == "3" -o "$number" == "4" -o "$number" == "6" \) ]; then
      #Only on some servers.
      echo " ...postgres.tar.gz" | tee -a /tmp/save/test.log
      tar zxf /mnt/backup/backup/postgres.tar.gz | tee -a /tmp/save/test.log
fi
#Update the farmlets so that rgang can be used to fix stuff later.
mkdir -p /usr/local/etc /usr/local/etc/farmlets
cd /usr/local/etc/farmlets
echo " ...farmlets.tar.gz" | tee -a /tmp/save/test.log
tar zxf /mnt/backup/backup/farmlets.tar.gz | tee -a /tmp/save/test.log
#
# Restoring personality files.
#
echo "  Restoring personality files."
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/test.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/test.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#copy_it /tmp/save/passwd /etc
#if [ $? -eq 1 ] ;then
	#copy_it /mnt/backup/backup/$system/$type/$number/passwd /etc
#fi
#copy_it /tmp/save/shadow /etc
#if [ $? -eq 1 ] ;then
	#copy_it /mnt/backup/backup/$system/$type/$number/shadow /etc
#fi
#copy_it /tmp/save/group /etc
#if [ $? -eq 1 ] ;then
	#copy_it /mnt/backup/backup/$system/$type/$number/group /etc
#fi

echo "  Installing passwd, shadow and group files."
copy_it /mnt/backup/backup/passwd /etc
copy_it /mnt/backup/backup/shadow /etc
copy_it /mnt/backup/backup/group /etc

copy_it /tmp/save/fstab /etc
if [ $? -eq 1 ] ;then
	copy_it /mnt/backup/backup/$system/$type/$number/fstab /etc
fi
copy_it /tmp/save/krb5.keytab /etc
if [ ! -f /etc/krb5.keytab ] ;then
	copy_it /mnt/backup/backup/$system/$type/$number/krb5.keytab /etc
fi
copy_it /tmp/save/root.k5login /root/.k5login
if [ ! -f /root/.k5login ] ;then
	copy_it /mnt/backup/backup/$system/$type/$number/root.k5login /root/.k5login
fi
copy_it /tmp/save/enstore.k5login /home/enstore/.k5login
if [ ! -f /home/enstore/.k5login ] ;then
	copy_it /mnt/backup/backup/$system/$type/$number/enstore.k5login /home/enstore/.k5login
fi
mkdir /fnal /fnal/ups /fnal/ups/kt
copy_it /tmp/save/enstorekt /fnal/ups/kt/enstorekt
if [ ! -f /fnal/ups/kt/enstorekt ] ;then
	copy_it /mnt/backup/backup/$system/$type/$number/enstorekt /fnal/ups/kt/enstorekt
	#chown -R 5744.6209 /fnal/ups/kt/
	chown 5744.6209 /fnal/ups/kt/enstorekt
fi
#cp -pr /mnt/backup/backup/stken/mvr/rc.local /etc/rc.d
#copy_it /tmp/save/rc.local /etc/rc.d
copy_it /mnt/backup/backup/rc.local /etc/rc.d
if [ $? -eq 1 ] ;then
#	#cp -pr /mnt/backup/backup/stken/mvr/rc.local /etc/rc.d/rc.local
	copy_it /mnt/backup/backup/$system/$type/rc.local /etc/rc.d/rc.local
fi

copy_it /tmp/save/network /etc/sysconfig/network
if [ $? -eq 1 ] ;then
#	#cp -pr /mnt/backup/backup/stken/mvr/network /etc/sysconfig/network
	copy_it /mnt/backup/backup/$system/$type/network /etc/sysconfig/network
fi

copy_it /tmp/save/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
if [ $? -eq 1 ] ;then
#	#cp -pr /mnt/backup/backup/stken/mvr/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
	copy_it /mnt/backup/backup/$system/$type/ifcfg-eth0 /etc/sysconfig/network-scripts/ifcfg-eth0
fi

mkdir -p /home/enstore
copy_it /tmp/save/enstore.k5login /home/enstore/.k5login
if [ $? -eq 1 ]; then
	copy_it /mnt/backup/backup/$system/$type/$number/enstore.k5login /home/enstore/.k5login
fi
chown 5744.6209 /home/enstore/.k5login

copy_it /mnt/backup/backup/init.d.network /etc/rc.d/init.d/network
chown 0.0 /etc/rc.d/init.d/network

#
# The next two should only apply to console servers.
#
if [ -f /tmp/save/conserver.cf ]; then
	copy_it /tmp/save/conserver.cf /etc/
	chown 0.0 /etc/conserver.cf
elif [ -f /mnt/backup/backup/$system/$type/$number/conserver.cf ]; then
	copy_it /mnt/backup/backup/$system/$type/$number/conserver.cf /etc/
	chown 0.0 /etc/conserver.cf
fi
if [ -f /tmp/save/cons ]; then
	copy_it /tmp/save/cons /usr/local/bin/
	chown 0.0 /usr/local/bin/cons
	chmod a+x /usr/local/bin/cons
elif [ -f /mnt/backup/backup/$system/$type/$number/cons ]; then
	copy_it /mnt/backup/backup/$system/$type/$number/cons /usr/local/bin/
	chown 0.0 /usr/local/bin/cons
	chmod a+x /usr/local/bin/cons
fi


copy_it /mnt/backup/backup/$system.hosts.allow /etc/hosts.allow
copy_it /mnt/backup/backup/hosts /etc/hosts >>/tmp/save/test.log
chown 0.0 /etc/hosts.allow
chown 0.0 /etc/hosts 

cd /var/spool; tar xzf /tmp/save/cron.tar.gz
cd /; tar xzf /tmp/save/root.tar.gz

copy_it /local/ups/prd/ups/v4_7_2/Linux-2/init.d/ups /etc/rc.d/init.d/

cd /etc/rc.d/rc6.d/
ln -s ../init.d/ups K01ups
cd /etc/rc.d/rc3.d
ln -s ../init.d/ups S99ups

echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/shutdown/$hostname.products
echo "ups stop ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
echo "ups start ngop" >> /fnal/ups/db/.upsfiles/startup/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chmod 0755 /fnal/ups/db/.upsfiles/startup/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/shutdown/$hostname.products
chown 1342.4525 /fnal/ups/db/.upsfiles/startup/$hostname.products

rm /home/enstore/*.fnal.gov.startup #Remove old copies...
touch /home/enstore/$hostname.fnal.gov.startup
chown 5744.6209 /home/enstore/$hostname.fnal.gov.startup

#
#Finally, we are done with this.
#
umount /mnt/backup
/bin/rm -r /mnt/backup

%post
#
# Turning services on and off.
#
echo "  Turning services on and off." | tee -a /tmp/save/test.log
/sbin/chkconfig autofs off
/sbin/chkconfig netfs off
/sbin/chkconfig netlock off
/sbin/chkconfig sendmail off
/sbin/chkconfig xfs off
/sbin/chkconfig ftp on
/sbin/chkconfig eklogin on
/sbin/chkconfig klogin on
/sbin/chkconfig kshell on
/sbin/chkconfig telnet on
/sbin/chkconfig netperf on
/sbin/chkconfig yum off
/sbin/chkconfig isdn off
/sbin/chkconfig pcmcia off
/sbin/chkconfig portmap off
/sbin/chkconfig mdmonitor off
/sbin/chkconfig mdmpd off
/sbin/chkconfig apmd off
/sbin/chkconfig nfslock off
/sbin/chkconfig rhnsd off
rm -f /etc/cron.daily/00-logwatch
rm -f /etc/cron.daily/0anacron
rm -f /etc/cron.daily/yum.cron
rm -f /etc/mail/submit.*

%post --nochroot
#
# Try putting the user and groups for users root and enstore to see if
# su really can work if these files are correct.  The installed versions
# should be correct, these only put information into the install environment.
# 
grep "^enstore" /mnt/sysimage/etc/passwd >> /etc/passwd
grep "^root" /mnt/sysimage/etc/group >> /etc/group
grep "^enstore" /mnt/sysimage/etc/group >> /etc/group

%post
#
# parse the host name
#
hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/save/network | cut -c 10-`
if [ -z $hostname ]; then
	hostname=`awk -F. '/HOSTNAME/ {print $1}' /tmp/netinfo | cut -c 10-`
fi
if [ -n $hostname ]; then
	case $hostname in
		stken*)
			system=stken
			rest=`echo $hostname | cut -c 6-`
			;;
		cdfen*)
			system=cdfen
			rest=`echo $hostname | cut -c 6-`
			;;
		d0en*)
			system=d0en
			rest=`echo $hostname | cut -c 5-`
			;;
		*)
			system=""
			rest=""
			;;
	esac

	case $rest in
		mvr*)
			type=mvr
			number=`echo $rest | cut -c 4-`
			;;
		srv*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		dca*)
			type=srv
			number=`echo $rest | cut -c 4-`
			;;
		load*)
			type=""
			number=""
			;;
		*)
			type=""
			number=""
			;;
	esac

	echo "This is the type $type and the instance $number of the $system system."
else
	echo "Hostname not set."
fi
#This is a function that will retry the copy.  We are seeing strange copy
# failures (I'm wondering if they are related to the -p option).  Hopefully
# brute force will get us past this.
copy_it ( )
{
	echo "copying $1 to $2" | tee -a /tmp/save/test.log
        for i in 1 2 3 4 5 6 7 8 9 10; do
                ( cp -pr $1 $2 2>&1 ) | tee -a /tmp/save/test.log
                if [ $? -ne 0 ]; then sleep 1; continue; fi  #error
                return 0; #success
        done
        return 1;
}
#
# Enstore home area stuff.
#
echo "  Beginning enstore home area stuff." | tee -a /tmp/save/test.log
id enstore | tee -a /tmp/save/test.log
#if [ $? -eq 0 -a -d /home/enstore ]; then
if [ ]; then
	#
	#checkout enstore and ipmi
	#
	echo "Beginning cvs checkouts for enstore and ipmi."
	grep "enstore" /etc/passwd  #does user enstore exist?
	export CVSROOT=hppccvs@cdcvs.fnal.gov:/cvs/hppc
	mkdir -p /home/enstore
	cd /home/enstore
	echo "About to swith to user enstore!"
	su enstore   #Hope this works!!!
	/usr/krb5/bin/kinit -k -t /fnal/ups/kt/enstorekt enstore/cd/$hostname@FNAL.GOV
	if [ -f /home/enstore/enstore ]; then
		cd /home/enstore/enstore
		cvs update -r production
	else
		cd /home/enstore
		cvs checkout -r production enstore
	fi
	if [ -f /home/enstore/ipmi ]; then
		cd /home/enstore/ipmi
		cvs update ipmi
	else
		cd /home/enstore
		cvs checkout ipmi
	fi
	exit  #Become user root again.
fi
if [ -d /home/enstore/enstore ]; then
	#
	#build enstore and ipmi
	#
	echo "Beginning enstore and ipmi builds." | tee -a /tmp/save/test.log
	cd /home/enstore/enstore/modules
	make clean
	source /usr/local/etc/setups.sh
	setup enstore
	make
	cd /home/enstore/ipmi
	make
fi
if [ -d /home/enstore/enstore ]; then
	#
	# Begin copying the following files to their needed locations.
	#
	echo "Copying enstore files to their needed locations." | tee -a /tmp/save/test.log
	copy_it /home/enstore/enstore/bin/enstore-boot /etc/rc.d/init.d/
	chown 0.0 /etc/rc.d/init.d/enstore-boot
	ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc3.d/S99zzzenstore-boot
	ln -s /etc/rc.d/init.d/enstore-boot /etc/rc.d/rc6.d/K01aaaenstore-boot
	copy_it /home/enstore/enstore/bin/monitor_server-boot /etc/rc.d/init.d
	chown 0.0 /etc/rc.d/init.d/monitor_server-boot
	ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc3.d/S99zzzmonitor_server-boot
	ln -s /etc/rc.d/init.d/monitor_server-boot /etc/rc.d/rc6.d/K01aaamonitor_server-boot
	copy_it /home/enstore/enstore/etc/enstore.bashrc /home/enstore/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /home/enstore/.bash_profile
	#Where do the root/.bashrc and root/.bash_profile files come from?
	copy_it /home/enstore/enstore/etc/enstore.bashrc /root/.bashrc
	copy_it /home/enstore/enstore/etc/enstore.bash_profile /root/.bash_profile
	copy_it /home/enstore/enstore/etc/sudoers /etc/
	chmod 0440 /etc/sudoers
	chown 0.0 /etc/sudoers
	copy_it /home/enstore/enstore/sbin/routes /root/
	chown 0.0 /root/routes
	copy_it /home/enstore/enstore/etc/products.k5login /local/ups/.k5login
	chown 1342.4525 /local/ups/.k5login
	chmod 0664 /local/ups/.k5login
	if [ -n $system ]; then
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/root.k5login.m4 > /tmp/root.k5login 2>> /tmp/save/test.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/root.k5login /root/.k5login
			chown 0.0 /root/.k5login
		fi
		m4 -DHOSTNAME=$hostname /home/enstore/enstore/etc/$system.enstore.k5login.m4 > /tmp/enstore.k5login 2>> /tmp/save/test.log
		if [ $? -eq 0 ]; then
			copy_it /tmp/enstore.k5login /home/enstore/.k5login
			chown 5744.6209 /home/enstore/.k5login
		fi
		copy_it /home/enstore/enstore/etc/$system.hosts.allow /etc/hosts.allow
		chown 0.0 /etc/hosts.allow
		copy_it /home/enstore/enstore/etc/$system.step-tickers /etc/ntp/step-tickers
		chown 0.0 /etc/ntp/step-tickers
	fi
	copy_it /home/enstore/enstore/etc/ups /etc/rc.d/init.d/ups
	chown 0.0 /etc/rc.d/init.d/ups
	copy_it /home/enstore/enstore/etc/ntp.conf /etc/ntp.conf
	chown 0.0 /etc/ntp.conf
	copy_it /home/enstore/enstore/etc/services /etc/services
	chown 0.0 /etc/services
	mkdir /var/ngop /var/ngop/include /var/ngop/cron_agent /var/ngop/plugins_agent
	copy_it "/home/enstore/enstore/ngop/*.py" /var/ngop/include
	copy_it /home/enstore/enstore/ngop/raise_enstore_alarm /var/ngop/include
	copy_it /home/enstore/enstore/ngop/local_cronjob.xml /var/ngop/cron_agent
	copy_it /home/enstore/enstore/ngop/start_cron /var/ngop/cron_agent/.start
	chmod 0755 /var/ngop/cron_agent/.start
	if [ $type == "mvr" ]; then
		copy_it /home/enstore/enstore/ngop/linuxHealth.xml /var/ngop/plugins_agent/
	elif [ $type == "srv" ]; then
		copy_it /home/enstore/enstore/ngop/srv_linuxHealth.xml /var/ngop/plugins_agent/
	fi
	farmlets -f
	chown -R 0.0 /var/ngop
	rm /home/enstore/enstore/tmp/enstore/*
	echo ""
	echo "end of enstore home stuff"
fi


%post
echo ""
echo " Last Few Things "
#  Setup the root and enstore .forward files.
echo "enstore-admin@fnal.gov" > /root/.forward
echo "enstore-admin@fnal.gov" > /home/enstore/.forward
#  Some versions of ftt have these files without execute permissions.
chmod +x /local/ups/prd/ftt/v2_22/Linux-2-4-2-3-2/etc/*
#  By default this file contains three lines, we only want one.
grep /local/ups/db /local/ups/etc/upsdb_list >> /local/ups/etc/upsdb_list.fixed
rm -f /local/ups/etc/upsdb_list
mv /local/ups/etc/upsdb_list.fixed /local/ups/etc/upsdb_list
chmod 0664 /local/ups/etc/upsdb_list
#  Some enstore CRON jobs will look for /PRODUCTION to exist.
touch PRODUCTION
chmod 0644 PRODUCTION
mkdir -p /root/CRON
chmod 0755 /root/CRON
#  Set these permissions...
chown -R 5744.6209 /home/enstore
chown -R 5744.6209 /local/ups/kt/
