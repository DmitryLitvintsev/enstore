FILE = TABLE
PRODUCT=encp

FLAVOR = ANY
QUALIFIERS = ""
    ACTION=SETUP
	setupEnv()
	proddir()
	pathPrepend(PATH, "${UPS_PROD_DIR}")

        # control where the trace file goes
	execute("whoami", NO_UPS_ENV, meme)
        execute("mkdir -p /tmp/enstore/$meme", NO_UPS_ENV)
	execute("chmod 777 /tmp/enstore 2>/dev/null 1>/dev/null",NO_UPS_ENV)
	execute("uname -n | cut -d '.' -f 1", NO_UPS_ENV, tracehost)
        envSet(TRACE_KEY, "/tmp/enstore/$meme/trace.$tracehost")
        envUnset(tracehost)
        envUnset(meme)

	# we need a file lock to serialize access to requesting ports (callback.py)
	execute("touch /tmp/enstore/hunt_port_lock",NO_UPS_ENV)
	execute("chmod go+rw /tmp/enstore/hunt_port_lock 2>/dev/null 1>/dev/null",NO_UPS_ENV)

        # default "control" environmental variables
	envSet(ENSTORE_CONFIG_PORT, 7500)
	envSet(ENSTORE_CONFIG_HOST, pcfarm9.fnal.gov)

	# allow a user to override the default control environmental variables
	# the control variables are overridden by sourcing another "virtual" product
	#       note that the enstore_variables product doesn't exist - only the table file does
	#	ups doesn't check the databases since an absolute path is given 
	# the enstore_variables.table file should be a LINK to the appropriate file
	#     so, for example if this were a "sam" system, a user would ln -s sam.table enstore_variables.table
	#     or, if bakken had special needs,                          ln -s bakken.table enstore_variables.table
	# The basic idea is that everything in this table file is general, and everything in the
	#     enstore_variables.table file is user/installation specific
	setupOptional('-r "${UPS_PROD_DIR}" -M "${UPS_PROD_DIR}"     -m enstore_variables.table enstore_variables')
