--
-- PostgreSQL database dump
--

SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

--
-- Name: SCHEMA public; Type: COMMENT; Schema: -; Owner: products
--

COMMENT ON SCHEMA public IS 'Standard public schema';


--
-- Name: plpgsql; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: products
--

CREATE PROCEDURAL LANGUAGE plpgsql;


SET search_path = public, pg_catalog;

--
-- Name: bd; Type: TYPE; Schema: public; Owner: enstore
--

CREATE TYPE bd AS (
	media_type character varying,
	blanks_drawn integer
);


ALTER TYPE public.bd OWNER TO enstore;

--
-- Name: daily_xfer_size; Type: TYPE; Schema: public; Owner: enstore
--

CREATE TYPE daily_xfer_size AS (
	date date,
	storage_group character varying,
	"read" bigint,
	"write" bigint
);


ALTER TYPE public.daily_xfer_size OWNER TO enstore;

--
-- Name: ts; Type: TYPE; Schema: public; Owner: enstore
--

CREATE TYPE ts AS (
	storage_group character varying,
	total bigint,
	"read" bigint,
	"write" bigint
);


ALTER TYPE public.ts OWNER TO enstore;

--
-- Name: blanks_drawn(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION blanks_drawn(date) RETURNS SETOF bd
    AS $_$
select
    a.media_type, a.blanks - b.blanks as blanks_drawn
from
    blanks_of_day($1::date) a,
    blanks_of_day(current_date) b
where
    a.media_type = b.media_type;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.blanks_drawn(date) OWNER TO enstore;

--
-- Name: blanks_drawn(date, date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION blanks_drawn(date, date) RETURNS SETOF bd
    AS $_$
select
    a.media_type, a.blanks - b.blanks as blanks_drawn
from
    blanks_of_day($1::date) a,
    blanks_of_day($2::date) b
 where
    a.media_type = b.media_type;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.blanks_drawn(date, date) OWNER TO enstore;

--
-- Name: blanks_drawn_last_7days(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION blanks_drawn_last_7days() RETURNS SETOF bd
    AS $$
select
    a.media_type, a.blanks - b.blanks as blanks_drawn
from
    blanks_of_day(current_date - 7) a,
    blanks_of_day(current_date) b
where
    a.media_type = b.media_type;
 $$
    LANGUAGE sql;


ALTER FUNCTION public.blanks_drawn_last_7days() OWNER TO enstore;

SET default_tablespace = '';

SET default_with_oids = true;

--
-- Name: blanks; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE blanks (
    date timestamp without time zone NOT NULL,
    media_type character varying NOT NULL,
    blanks integer
);


ALTER TABLE public.blanks OWNER TO enstore;

--
-- Name: blanks_of_day(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION blanks_of_day(date) RETURNS SETOF blanks
    AS $_$
select
    *
from
    blanks
where
    date = (select min(date) from blanks where date >= $1::date and date < $1::date + '1 day'::interval);
$_$
    LANGUAGE sql;


ALTER FUNCTION public.blanks_of_day(date) OWNER TO enstore;

--
-- Name: xfer_count_by_day; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE xfer_count_by_day (
    date date,
    storage_group character varying,
    n_read bigint,
    n_write bigint
);


ALTER TABLE public.xfer_count_by_day OWNER TO enstore;

--
-- Name: daily_count(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION daily_count(date) RETURNS SETOF xfer_count_by_day
    AS $_$
select
    $1::date,
    storage_group,
    sum(case when rw='r' then 1 else 0 end)::bigint as n_read,
    sum(case when rw='w' then 1 else 0 end)::bigint as n_write
from
    encp_xfer
where
    date >= $1 and date < $1 + 1
group by storage_group;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.daily_count(date) OWNER TO enstore;

--
-- Name: xfer_by_day; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE xfer_by_day (
    date date NOT NULL,
    storage_group character varying NOT NULL,
    "read" bigint,
    "write" bigint,
    n_read bigint,
    n_write bigint
);


ALTER TABLE public.xfer_by_day OWNER TO enstore;

--
-- Name: daily_size(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION daily_size(date) RETURNS SETOF xfer_by_day
    AS $_$
select
    $1::date,
    storage_group,
    sum(case when rw='r' then size else 0 end)::bigint as read,
    sum(case when rw='w' then size else 0 end)::bigint as write,
    sum(case when rw='r' then 1 else 0 end)::bigint as n_read,
    sum(case when rw='w' then 1 else 0 end)::bigint as n_write
from
    encp_xfer
where
    date >= $1 and date < $1 + 1
group by storage_group;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.daily_size(date) OWNER TO enstore;

--
-- Name: xfer_by_day_by_mover; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE xfer_by_day_by_mover (
    date date NOT NULL,
    mover character varying NOT NULL,
    "read" bigint,
    "write" bigint
);


ALTER TABLE public.xfer_by_day_by_mover OWNER TO enstore;

--
-- Name: daily_size_by_mover(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION daily_size_by_mover(date) RETURNS SETOF xfer_by_day_by_mover
    AS $_$
select
    $1::date,
    rtrim(mover, '.mover') as mover,
    sum(case when rw='r' then size else 0 end)::bigint as read,
    sum(case when rw='w' then size else 0 end)::bigint as write
from
    encp_xfer
where
    date >= $1 and date < $1 + 1
group by rtrim(mover, '.mover');
$_$
    LANGUAGE sql;


ALTER FUNCTION public.daily_size_by_mover(date) OWNER TO enstore;

--
-- Name: data_transfer(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION data_transfer(timestamp without time zone) RETURNS SETOF ts
    AS $_$
select
        storage_group,
        sum(size)::bigint as total,
        sum(case
                when rw = 'r' then size
                else 0
        end)::bigint as read,
        sum(case
                when rw = 'w' then size
                else 0
        end)::bigint as write
from
        encp_xfer
where
        date >= $1::timestamp
group by storage_group
order by storage_group;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.data_transfer(timestamp without time zone) OWNER TO enstore;

--
-- Name: data_transfer(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION data_transfer(timestamp without time zone, timestamp without time zone) RETURNS SETOF ts
    AS $_$
select
        storage_group,
        sum(size)::bigint as total,
        sum(case
                when rw = 'r' then size
                else 0
        end)::bigint as read,
        sum(case
                when rw = 'w' then size
                else 0
        end)::bigint as write
from
        encp_xfer
where
        date >= $1::timestamp and date < $2::timestamp
group by storage_group
order by storage_group;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.data_transfer(timestamp without time zone, timestamp without time zone) OWNER TO enstore;

--
-- Name: data_transfer_last_7days(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION data_transfer_last_7days() RETURNS SETOF ts
    AS $$
select
        storage_group,
        sum(size)::bigint as total,
        sum(case
                when rw = 'r' then size
                else 0
        end)::bigint as read,
        sum(case
                when rw = 'w' then size
                else 0
        end)::bigint as write
from
        encp_xfer
where
        date >= current_date - 8 and
        date < current_date
group by storage_group
order by storage_group;
$$
    LANGUAGE sql;


ALTER FUNCTION public.data_transfer_last_7days() OWNER TO enstore;

--
-- Name: make_daily_xfer_count(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_daily_xfer_count() RETURNS date
    AS $$
declare
	day date;
begin
	day = (select max(date) from xfer_count_by_day);
	if day is null then
		day = (select make_first_daily_xfer_count())::date;
	end if;
	if day is null then
		return day;
	end if;
	day = day + 1;
	while day < current_date loop
		insert into xfer_count_by_day select * from daily_count(day);
		day = day + 1;
	end loop;
	return day;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_daily_xfer_count() OWNER TO enstore;

--
-- Name: make_daily_xfer_size(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_daily_xfer_size() RETURNS date
    AS $$
declare
	day date;
begin
	day = (select max(date) from xfer_by_day);
	if day is null then
		day = (select make_first_daily_xfer_size())::date;
	end if;
	if day is null then
		return day;
	end if;
	day = day + 1;
	while day < current_date loop
		insert into xfer_by_day select * from daily_size(day);
		day = day + 1;
	end loop;
	return day;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_daily_xfer_size() OWNER TO enstore;

--
-- Name: make_daily_xfer_size(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_daily_xfer_size(date) RETURNS date
    AS $_$
declare
	day date;
begin
	day = (select max(date) from xfer_by_day);
	if day is null then
		day = (select make_first_daily_xfer_size())::date;
	end if;
	if day is null then
		return day;
	end if;
	day = day + 1;
	while day < $1::date loop
		insert into xfer_by_day select * from daily_size(day);
		day = day + 1;
	end loop;
	return day;
end;
$_$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_daily_xfer_size(date) OWNER TO enstore;

--
-- Name: make_daily_xfer_size_by_mover(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_daily_xfer_size_by_mover(date) RETURNS date
    AS $_$
declare
	day date;
begin
	day = (select max(date) from xfer_by_day_by_mover);
	if day is null then
		day = (select make_first_daily_size_by_mover())::date;
	end if;
	if day is null then
		return day;
	end if;
	day = day + 1;
	while day < $1::date loop
		insert into xfer_by_day_by_mover select * from daily_size_by_mover(day);
		day = day + 1;
	end loop;
	return day;
end;
$_$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_daily_xfer_size_by_mover(date) OWNER TO enstore;

--
-- Name: make_daily_xfer_size_by_mover(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_daily_xfer_size_by_mover() RETURNS date
    AS $$
declare
	day date;
begin
	day = (select max(date) from xfer_by_day_by_mover);
	if day is null then
		day = (select make_first_daily_size_by_mover())::date;
	end if;
	if day is null then
		return day;
	end if;
	day = day + 1;
	while day < current_date loop
		insert into xfer_by_day_by_mover select * from daily_size_by_mover(day);
		day = day + 1;
	end loop;
	return day;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_daily_xfer_size_by_mover() OWNER TO enstore;

--
-- Name: make_first_daily_size_by_mover(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_first_daily_size_by_mover() RETURNS date
    AS $$
declare
        first_day date;
begin
        first_day = (select min(date)::date from encp_xfer);
	if first_day = current_date then
		return null;
	end if;
        if not first_day is null then
                insert into xfer_by_day_by_mover select * from daily_size_by_mover(first_day);
        end if;
        return first_day;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_first_daily_size_by_mover() OWNER TO enstore;

--
-- Name: make_first_daily_xfer_count(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_first_daily_xfer_count() RETURNS date
    AS $$
declare
	first_day date;
begin
	first_day = (select min(date)::date from encp_xfer);
	if first_day = current_date then
		return null;
	end if;
	if not first_day is null then
		insert into xfer_count_by_day select * from daily_count(first_day);
	end if;
	return first_day;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_first_daily_xfer_count() OWNER TO enstore;

--
-- Name: make_first_daily_xfer_size(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_first_daily_xfer_size() RETURNS date
    AS $$
declare
	first_day date;
begin
	first_day = (select min(date)::date from encp_xfer);
	if first_day = current_date then
		return null;
	end if;
	if not first_day is null then
		insert into xfer_by_day select * from daily_size(first_day);
	end if;
	return first_day;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_first_daily_xfer_size() OWNER TO enstore;

--
-- Name: make_first_monthly_xfer_size(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_first_monthly_xfer_size() RETURNS date
    AS $$
declare
	first_month date;
begin
	first_month = (select year_month((select min(date) from encp_xfer)));
	if first_month = (select year_month(current_date)) then
		return null;
	end if;
	if not first_month is null then
		insert into xfer_by_month select * from monthly_size(first_month);
	end if;
	return first_month;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_first_monthly_xfer_size() OWNER TO enstore;

--
-- Name: make_monthly_xfer_size(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_monthly_xfer_size(date) RETURNS date
    AS $_$
declare
	month date;
begin
	month = (select max(date) from xfer_by_month);
	if month is null then
		month = (select make_first_monthly_xfer_size());
	end if;
	if month is null then
		return month;
	end if;
	month = month + '1 mons'::interval;
	while month < year_month($1::date) loop
		insert into xfer_by_month select * from monthly_size(month);
		month = month + '1 mons'::interval;
	end loop;
	return month;
end;
$_$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_monthly_xfer_size(date) OWNER TO enstore;

--
-- Name: make_monthly_xfer_size(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION make_monthly_xfer_size() RETURNS date
    AS $$
declare
	month date;
begin
	month = (select max(date) from xfer_by_month);
	if month is null then
		month = (select make_first_monthly_xfer_size());
	end if;
	if month is null then
		return month;
	end if;
	month = month + '1 mons'::interval;
	while month < year_month(current_date) loop
		insert into xfer_by_month select * from monthly_size(month);
		month = month + '1 mons'::interval;
	end loop;
	return month;
end;
$$
    LANGUAGE plpgsql;


ALTER FUNCTION public.make_monthly_xfer_size() OWNER TO enstore;

--
-- Name: monthly_size(date); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION monthly_size(date) RETURNS SETOF daily_xfer_size
    AS $_$
select
    year_month(date) as date,
    storage_group,
    sum(case when rw='r' then size else 0 end)::bigint as read,
    sum(case when rw='w' then size else 0 end)::bigint as write
from
    encp_xfer
where
    date >= year_month($1) and date < year_month($1) + '1 mons'::interval
group by year_month(date), storage_group;
$_$
    LANGUAGE sql;


ALTER FUNCTION public.monthly_size(date) OWNER TO enstore;

--
-- Name: plpgsql_call_handler(); Type: FUNCTION; Schema: public; Owner: products
--

CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
    AS '$libdir/plpgsql', 'plpgsql_call_handler'
    LANGUAGE c;


ALTER FUNCTION public.plpgsql_call_handler() OWNER TO products;

--
-- Name: plpgsql_validator(oid); Type: FUNCTION; Schema: public; Owner: products
--

CREATE FUNCTION plpgsql_validator(oid) RETURNS void
    AS '$libdir/plpgsql', 'plpgsql_validator'
    LANGUAGE c;


ALTER FUNCTION public.plpgsql_validator(oid) OWNER TO products;

--
-- Name: unix2timestamp(bigint); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION unix2timestamp(bigint) RETURNS timestamp with time zone
    AS $_$
DECLARE
    STAMP  TIMESTAMP WITH TIME ZONE;
BEGIN
    select TIMESTAMP WITH TIME ZONE 'epoch' +($1) * INTERVAL '1 second' into STAMP;
    return STAMP;
END;
$_$
    LANGUAGE plpgsql;


ALTER FUNCTION public.unix2timestamp(bigint) OWNER TO enstore;

--
-- Name: year_month(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION year_month(timestamp without time zone) RETURNS date
    AS $_$
select to_date(to_char($1, 'YYYY-MM-01'), 'YYYY-MM-DD');$_$
    LANGUAGE sql;


ALTER FUNCTION public.year_month(timestamp without time zone) OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: drive_utilization; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE drive_utilization (
    "time" timestamp with time zone NOT NULL,
    "type" character varying NOT NULL,
    "storage_group" character varying NULL, 
    total integer,
    busy integer,
    tape_library character varying DEFAULT 'TBA'::character varying NOT NULL
);


ALTER TABLE public.drive_utilization OWNER TO enstore;

---
-- alter table drive_utilization  DROP CONSTRAINT drive_utilization_pkey;
---


SET default_with_oids = true;

--
-- Name: encp_error; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE encp_error (
    date timestamp without time zone NOT NULL,
    node character varying NOT NULL,
    pid integer NOT NULL,
    username character varying NOT NULL,
    encp_id character varying,
    version character varying NOT NULL,
    "type" character varying NOT NULL,
    error character varying NOT NULL,
    src character varying,
    dst character varying,
    size bigint,
    storage_group character varying,
    file_family character varying,
    wrapper character varying,
    mover character varying,
    drive_id character varying,
    drive_sn character varying,
    rw character(1),
    volume character varying
);


ALTER TABLE public.encp_error OWNER TO enstore;

--
-- Name: encp_xfer; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE encp_xfer (
    date timestamp without time zone NOT NULL,
    node character varying(32) NOT NULL,
    pid integer NOT NULL,
    username character varying(32) NOT NULL,
    src text NOT NULL,
    dst text NOT NULL,
    size bigint NOT NULL,
    rw character(1) NOT NULL,
    overall_rate bigint NOT NULL,
    network_rate bigint NOT NULL,
    drive_rate bigint NOT NULL,
    volume character varying(64) NOT NULL,
    mover character varying(32) NOT NULL,
    drive_id character varying(16) NOT NULL,
    drive_sn character varying(16) NOT NULL,
    elapsed double precision NOT NULL,
    media_changer character varying(32) NOT NULL,
    mover_interface character varying(32) NOT NULL,
    driver character varying(16) NOT NULL,
    storage_group character varying(16) NOT NULL,
    encp_ip character varying(16) NOT NULL,
    encp_id character varying(64) NOT NULL,
    disk_rate bigint,
    transfer_rate bigint,
    encp_version character varying(48),
    file_family character varying,
    wrapper character varying
);


ALTER TABLE public.encp_xfer OWNER TO enstore;

--
-- Name: encp_xfer_average_by_storage_group; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE encp_xfer_average_by_storage_group (
    unix_time integer NOT NULL,
    date timestamp without time zone NOT NULL,
    from_date timestamp without time zone NOT NULL,
    to_date timestamp without time zone NOT NULL,
    storage_group character varying(16) NOT NULL,
    rw character(1) NOT NULL,
    avg_overall_rate double precision,
    avg_network_rate double precision,
    avg_disk_rate double precision,
    avg_transfer_rate double precision,
    avg_drive_rate double precision,
    avg_size double precision,
    stddev_overall_rate double precision,
    stddev_network_rate double precision,
    stddev_disk_rate double precision,
    stddev_transfer_rate double precision,
    stddev_drive_rate double precision,
    stddev_size double precision,
    counter integer
);


ALTER TABLE public.encp_xfer_average_by_storage_group OWNER TO enstore;

--
-- Name: encp_xfer_by_day_view; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW encp_xfer_by_day_view AS
    SELECT (sum(encp_xfer.size))::double precision AS date, encp_xfer.rw AS size, encp_xfer.mover AS rw, (substr((encp_xfer.date)::text, 0, 11))::timestamp without time zone AS mover FROM encp_xfer GROUP BY encp_xfer.rw, encp_xfer.mover, substr((encp_xfer.date)::text, 0, 11);


ALTER TABLE public.encp_xfer_by_day_view OWNER TO enstore;

--
-- Name: encp_xfer_clone; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE encp_xfer_clone (
    date timestamp without time zone NOT NULL,
    overall_rate bigint NOT NULL,
    network_rate bigint NOT NULL,
    disk_rate bigint NOT NULL,
    transfer_rate bigint NOT NULL,
    drive_rate bigint NOT NULL,
    storage_group character varying(16) NOT NULL
);


ALTER TABLE public.encp_xfer_clone OWNER TO enstore;

--
-- Name: enstore_tables; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW enstore_tables AS
    SELECT n.nspname AS schemaname, c.relname AS tablename, pg_get_userbyid(c.relowner) AS tableowner, c.reltuples AS "rows", c.relpages AS pages, t.spcname AS "tablespace", c.relhaspkey AS haspkey, c.relhasindex AS hasindexes, c.relhasrules AS hasrules, (c.reltriggers > 0) AS hastriggers FROM ((pg_class c LEFT JOIN pg_namespace n ON ((n.oid = c.relnamespace))) LEFT JOIN pg_tablespace t ON ((t.oid = c.reltablespace))) WHERE ((c.relkind = 'r'::"char") AND (n.nspname = 'public'::name));


ALTER TABLE public.enstore_tables OWNER TO enstore;

--
-- Name: event; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE event (
    tag character varying(48) NOT NULL,
    name character varying(32) NOT NULL,
    node character varying(32) NOT NULL,
    username character varying(32) NOT NULL,
    "start" timestamp without time zone NOT NULL,
    finish timestamp without time zone,
    status integer,
    "comment" character varying(64)
);


ALTER TABLE public.event OWNER TO enstore;

--
-- Name: lock_status; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW lock_status AS
    SELECT (SELECT pg_class.relname FROM pg_class WHERE (pg_class.oid = pg_locks.relation)) AS "table", (SELECT pg_database.datname FROM pg_database WHERE (pg_database.oid = pg_locks."database")) AS "database", pg_locks."transaction", (SELECT pg_stat_activity.usename FROM pg_stat_activity WHERE (pg_stat_activity.procpid = pg_locks.pid)) AS "user", pg_locks."mode", pg_locks."granted" FROM pg_locks;


ALTER TABLE public.lock_status OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: mover; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE mover (
    name character varying NOT NULL,
    max_rate double precision,
    max_buffer bigint,
    check_written_file integer,
    max_failures integer,
    library character varying,
    host character varying,
    max_consecutive_failures integer,
    max_time_in_state integer,
    device character varying,
    norestart character varying,
    driver character varying,
    port integer,
    send_stats integer,
    mc_device character varying,
    compression integer,
    statistics_path character varying,
    mount_delay integer,
    check_first_written_file integer,
    data_ip character varying,
    logname character varying,
    media_changer character varying,
    hostip character varying,
    do_cleaning character varying,
    update_interval integer,
    syslog_entry character varying,
    min_buffer bigint,
    noupdown character varying,
    inq_ignore character varying,
    dismount_delay integer,
    max_dismount_delay integer,
    max_in_state_cnt integer,
    include_thread_name character varying
);


ALTER TABLE public.mover OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: old_bytes_per_day; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE old_bytes_per_day (
    date date,
    "read" bigint,
    "write" bigint
);


ALTER TABLE public.old_bytes_per_day OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: rate; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE rate (
    "time" timestamp with time zone NOT NULL,
    "read" bigint,
    "write" bigint,
    read_null bigint,
    write_null bigint
);


ALTER TABLE public.rate OWNER TO enstore;

--
-- Name: tape_library_slots_usage; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE tape_library_slots_usage (
    "time" timestamp with time zone NOT NULL,
    tape_library character varying NOT NULL,
    "location" character varying NOT NULL,
    media_type character varying,
    total integer,
    free integer,
    used integer,
    disabled integer
);


ALTER TABLE public.tape_library_slots_usage OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: tape_mounts; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE tape_mounts (
    node character varying(32) NOT NULL,
    volume character varying(64) NOT NULL,
    "type" character varying(32) NOT NULL,
    logname character varying(16) NOT NULL,
    "start" timestamp without time zone NOT NULL,
    finish timestamp without time zone,
    state character(1) NOT NULL
);


ALTER TABLE public.tape_mounts OWNER TO enstore;

--
-- Name: tape_mounts_tmp; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE tape_mounts_tmp (
    volume character varying(64) NOT NULL,
    state character varying(1) NOT NULL,
    id bigint
);


ALTER TABLE public.tape_mounts_tmp OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: time; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE "time" (
    date_part double precision
);


ALTER TABLE public."time" OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: tmp_xfer_by_day; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE tmp_xfer_by_day (
    date date NOT NULL,
    storage_group character varying NOT NULL,
    "read" bigint,
    "write" bigint
);


ALTER TABLE public.tmp_xfer_by_day OWNER TO enstore;

--
-- Name: write_protect_summary; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE write_protect_summary (
    date timestamp without time zone DEFAULT now() NOT NULL,
    total integer,
    should integer,
    not_yet integer,
    done integer
);


ALTER TABLE public.write_protect_summary OWNER TO enstore;

--
-- Name: write_protect_summary_by_library; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE write_protect_summary_by_library (
    date timestamp without time zone DEFAULT now() NOT NULL,
    library character varying NOT NULL,
    total integer,
    should integer,
    not_yet integer,
    done integer
);


ALTER TABLE public.write_protect_summary_by_library OWNER TO enstore;

--
-- Name: xfer_by_month; Type: TABLE; Schema: public; Owner: enstore; Tablespace: 
--

CREATE TABLE xfer_by_month (
    date date NOT NULL,
    storage_group character varying NOT NULL,
    "read" bigint,
    "write" bigint
);


ALTER TABLE public.xfer_by_month OWNER TO enstore;

--
-- Name: drive_utilization_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

--
-- ALTER TABLE ONLY drive_utilization
--     ADD CONSTRAINT drive_utilization_pkey PRIMARY KEY ("time", "type");
-- 

--
-- Name: event_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY event
    ADD CONSTRAINT event_pkey PRIMARY KEY (tag);


--
-- Name: mover_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY mover
    ADD CONSTRAINT mover_pkey PRIMARY KEY (name);


--
-- Name: rate_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY rate
    ADD CONSTRAINT rate_pkey PRIMARY KEY ("time");


--
-- Name: reamin_blanks_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY blanks
    ADD CONSTRAINT reamin_blanks_pkey PRIMARY KEY (date, media_type);


--
-- Name: tape_library_slots_usage_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY tape_library_slots_usage
    ADD CONSTRAINT tape_library_slots_usage_pkey PRIMARY KEY ("time", tape_library, "location");


--
-- Name: tape_mounts_tmp_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY tape_mounts_tmp
    ADD CONSTRAINT tape_mounts_tmp_pkey PRIMARY KEY (volume, state);


--
-- Name: write_protect_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY write_protect_summary
    ADD CONSTRAINT write_protect_pkey PRIMARY KEY (date);


--
-- Name: xfer_by_date_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY xfer_by_day
    ADD CONSTRAINT xfer_by_date_pkey PRIMARY KEY (date, storage_group);


--
-- Name: xfer_by_day_by_mover_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY xfer_by_day_by_mover
    ADD CONSTRAINT xfer_by_day_by_mover_pkey PRIMARY KEY (date, mover);


--
-- Name: xfer_by_month_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace: 
--

ALTER TABLE ONLY xfer_by_month
    ADD CONSTRAINT xfer_by_month_pkey PRIMARY KEY (date, storage_group);


--
-- Name: blanks_date_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX blanks_date_idx ON blanks USING btree (date);


--
-- Name: blanks_media_type_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX blanks_media_type_idx ON blanks USING btree (media_type);


--
-- Name: drive_utilization_tape_library_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX drive_utilization_tape_library_idx ON drive_utilization USING btree (tape_library);


--
-- Name: drive_utilization_time_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX drive_utilization_time_idx ON drive_utilization USING btree ("time");


--
-- Name: drive_utilization_type_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX drive_utilization_type_idx ON drive_utilization USING btree ("type");


--
-- Name: encp_xfer_average_by_storage_group_date_index; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX encp_xfer_average_by_storage_group_date_index ON encp_xfer_average_by_storage_group USING btree (date);


--
-- Name: encp_xfer_average_by_storage_group_from_date_index; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX encp_xfer_average_by_storage_group_from_date_index ON encp_xfer_average_by_storage_group USING btree (from_date);


--
-- Name: encp_xfer_average_by_storage_group_rw_index; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX encp_xfer_average_by_storage_group_rw_index ON encp_xfer_average_by_storage_group USING btree (rw);


--
-- Name: encp_xfer_average_by_storage_group_storage_group_index; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX encp_xfer_average_by_storage_group_storage_group_index ON encp_xfer_average_by_storage_group USING btree (storage_group);


--
-- Name: encp_xfer_average_by_storage_group_to_date_index; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX encp_xfer_average_by_storage_group_to_date_index ON encp_xfer_average_by_storage_group USING btree (to_date);


--
-- Name: encp_xfer_average_by_storage_group_unix_time_index; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX encp_xfer_average_by_storage_group_unix_time_index ON encp_xfer_average_by_storage_group USING btree (unix_time);


--
-- Name: error_date_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX error_date_idx ON encp_error USING btree (date);


--
-- Name: error_file_family_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX error_file_family_idx ON encp_error USING btree (file_family);


--
-- Name: error_oid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX error_oid_idx ON encp_error USING btree (oid);


--
-- Name: error_storage_group_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX error_storage_group_idx ON encp_error USING btree (storage_group);


--
-- Name: error_volume_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX error_volume_idx ON encp_error USING btree (volume);


--
-- Name: error_wrapper_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX error_wrapper_idx ON encp_error USING btree (wrapper);


--
-- Name: event_name_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX event_name_idx ON event USING btree (name);


--
-- Name: event_node_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX event_node_idx ON event USING btree (node);


--
-- Name: event_oid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX event_oid_idx ON event USING btree (oid);


--
-- Name: event_start_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX event_start_idx ON event USING btree ("start");


--
-- Name: mover_logname_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX mover_logname_idx ON mover USING btree (logname);


--
-- Name: mover_media_changer_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX mover_media_changer_idx ON mover USING btree (media_changer);


--
-- Name: tape_library_slots_usage_location_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_library_slots_usage_location_idx ON tape_library_slots_usage USING btree ("location");


--
-- Name: tape_library_slots_usage_media_type_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_library_slots_usage_media_type_idx ON tape_library_slots_usage USING btree (media_type);


--
-- Name: tape_library_slots_usage_tape_library_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_library_slots_usage_tape_library_idx ON tape_library_slots_usage USING btree (tape_library);


--
-- Name: tape_library_slots_usage_time_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_library_slots_usage_time_idx ON tape_library_slots_usage USING btree ("time");


--
-- Name: tape_mnts_node_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_mnts_node_idx ON tape_mounts USING btree (node);


--
-- Name: tape_mnts_oid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_mnts_oid_idx ON tape_mounts USING btree (oid);


--
-- Name: tape_mnts_start_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_mnts_start_idx ON tape_mounts USING btree ("start");


--
-- Name: tape_mnts_type_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_mnts_type_idx ON tape_mounts USING btree ("type");


--
-- Name: tape_mnts_volume_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_mnts_volume_idx ON tape_mounts USING btree (volume);


--
-- Name: tape_mounts_logname_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tape_mounts_logname_idx ON tape_mounts USING btree (logname);


--
-- Name: tmt_oid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX tmt_oid_idx ON tape_mounts_tmp USING btree (oid);


--
-- Name: write_protect_summary_by_library_library_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX write_protect_summary_by_library_library_idx ON write_protect_summary_by_library USING btree (library);


--
-- Name: xfr_date_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_date_idx ON encp_xfer USING btree (date);


--
-- Name: xfr_file_family_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_file_family_idx ON encp_xfer USING btree (file_family);


--
-- Name: xfr_media_changer_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_media_changer_idx ON encp_xfer USING btree (media_changer);


--
-- Name: xfr_mover_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_mover_idx ON encp_xfer USING btree (mover);


--
-- Name: xfr_node_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_node_idx ON encp_xfer USING btree (node);


--
-- Name: xfr_oid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_oid_idx ON encp_xfer USING btree (oid);


--
-- Name: xfr_pid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_pid_idx ON encp_xfer USING btree (pid);


--
-- Name: xfr_storage_group_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_storage_group_idx ON encp_xfer USING btree (storage_group);


--
-- Name: xfr_user_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_user_idx ON encp_xfer USING btree (username);


--
-- Name: xfr_volume_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_volume_idx ON encp_xfer USING btree (volume);


--
-- Name: xfr_wrapper_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace: 
--

CREATE INDEX xfr_wrapper_idx ON encp_xfer USING btree (wrapper);


--
-- Name: write_protect_summary_by_library_date_fkey; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY write_protect_summary_by_library
    ADD CONSTRAINT write_protect_summary_by_library_date_fkey FOREIGN KEY (date) REFERENCES write_protect_summary(date);


--
-- PostgreSQL database dump complete
--

