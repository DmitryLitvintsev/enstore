--
-- PostgreSQL database dump
--

SET statement_timeout = 0;
SET client_encoding = 'UTF8';
SET standard_conforming_strings = off;
SET check_function_bodies = false;
SET client_min_messages = warning;
SET escape_string_warning = off;

--
-- Name: plpgsql; Type: PROCEDURAL LANGUAGE; Schema: -; Owner: products
--

CREATE PROCEDURAL LANGUAGE plpgsql;


ALTER PROCEDURAL LANGUAGE plpgsql OWNER TO products;

SET search_path = public, pg_catalog;

--
-- Name: tr; Type: TYPE; Schema: public; Owner: enstore
--

CREATE TYPE tr AS (
	media_type character varying,
	recycled integer
);


ALTER TYPE public.tr OWNER TO enstore;

--
-- Name: trb; Type: TYPE; Schema: public; Owner: enstore
--

CREATE TYPE trb AS (
	storage_group character varying,
	recycled_bytes bigint
);


ALTER TYPE public.trb OWNER TO enstore;

--
-- Name: all_deleted(integer); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION all_deleted(integer) RETURNS integer
    LANGUAGE plpgsql
    AS $_$
begin
        if (select bfid from file where volume = $1 and deleted = 'n' limit 1) is null and
           (select bfid from file where volume = $1 and deleted = 'u' limit 1) is null and
           not (select bfid from file where volume = $1 and deleted = 'y' limit 1) is null
        then
                return 1;
        else
                return 0;
        end if;
end;
$_$;


ALTER FUNCTION public.all_deleted(integer) OWNER TO enstore;

--
-- Name: bytes_deleted(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION bytes_deleted(timestamp without time zone) RETURNS SETOF trb
    LANGUAGE sql
    AS $_$
select
        storage_group,
        sum(size)::bigint as recycled_bytes
from
        volume,
        state left join file on (file.volume = state.volume)
where
        value = 'DELETED' and
        state.volume = volume.id and
        time >= $1::timestamp
group by storage_group
order by storage_group;
$_$;


ALTER FUNCTION public.bytes_deleted(timestamp without time zone) OWNER TO enstore;

--
-- Name: bytes_deleted(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION bytes_deleted(timestamp without time zone, timestamp without time zone) RETURNS SETOF trb
    LANGUAGE sql
    AS $_$
select
        storage_group,
        sum(size)::bigint as recycled_bytes
from
        volume,
        state left join file on (file.volume = state.volume)
where
        value = 'DELETED' and
        state.volume = volume.id and
        time >= $1::timestamp and
        time < $2::timestamp
group by storage_group
order by storage_group;
$_$;


ALTER FUNCTION public.bytes_deleted(timestamp without time zone, timestamp without time zone) OWNER TO enstore;

--
-- Name: bytes_deleted_last_7days(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION bytes_deleted_last_7days() RETURNS SETOF trb
    LANGUAGE sql
    AS $$
select
        storage_group,
        sum(size)::bigint as recycled_bytes
from
        volume,
        state left join file on (file.volume = state.volume)
where
        value = 'DELETED' and
        state.volume = volume.id and
        time >= current_date - 8 and
        time < current_date
group by storage_group
order by storage_group;
$$;


ALTER FUNCTION public.bytes_deleted_last_7days() OWNER TO enstore;

--
-- Name: bytes_recycled(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION bytes_recycled(timestamp without time zone, timestamp without time zone) RETURNS SETOF trb
    LANGUAGE sql
    AS $_$
select
        storage_group,
        sum(size)::bigint as recycled_bytes
from
        volume,
        state left join file on (file.volume = state.volume)
where
        value = 'RECYCLED' and
        state.volume = volume.id and
        time >= $1::timestamp and
        time < $2::timestamp
group by storage_group
order by storage_group;
$_$;


ALTER FUNCTION public.bytes_recycled(timestamp without time zone, timestamp without time zone) OWNER TO enstore;

--
-- Name: bytes_recycled(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION bytes_recycled(timestamp without time zone) RETURNS SETOF trb
    LANGUAGE sql
    AS $_$
select
        storage_group,
        sum(size)::bigint as recycled_bytes
from
        volume,
        state left join file on (file.volume = state.volume)
where
        value = 'RECYCLED' and
        state.volume = volume.id and
        time >= $1::timestamp
group by storage_group
order by storage_group;
$_$;


ALTER FUNCTION public.bytes_recycled(timestamp without time zone) OWNER TO enstore;

--
-- Name: bytes_recycled_last_7days(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION bytes_recycled_last_7days() RETURNS SETOF trb
    LANGUAGE sql
    AS $$
select
        storage_group,
        sum(size)::bigint as recycled_bytes
from
        volume,
        state left join file on (file.volume = state.volume)
where
        value = 'RECYCLED' and
        state.volume = volume.id and
        time >= current_date - 8 and
        time < current_date
group by storage_group
order by storage_group;
$$;


ALTER FUNCTION public.bytes_recycled_last_7days() OWNER TO enstore;

--
-- Name: get_media_type(character varying, bigint); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION get_media_type(character varying, bigint) RETURNS character varying
    LANGUAGE plpgsql
    AS $_$
DECLARE
MT VARCHAR;
BEGIN
         IF  $1 = '3480' and $2 = 107374182400 THEN
         MT = 'LTO1';
         ELSEIF  $1 = '3480' and $2 = 214748364800 THEN
         MT = 'LTO2';
         ELSEIF  $1 = '3480' and $2 < 100 THEN
         MT = NULL;
         ELSE
         MT=$1;
 END IF;
 return MT;
END;
$_$;


ALTER FUNCTION public.get_media_type(character varying, bigint) OWNER TO enstore;

--
-- Name: lookup_stype(character varying); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION lookup_stype(character varying) RETURNS integer
    LANGUAGE sql
    AS $_$select id from state_type where name = $1;$_$;


ALTER FUNCTION public.lookup_stype(character varying) OWNER TO enstore;

--
-- Name: lookup_vol(character varying); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION lookup_vol(character varying) RETURNS integer
    LANGUAGE sql
    AS $_$select id from volume where label = $1;$_$;


ALTER FUNCTION public.lookup_vol(character varying) OWNER TO enstore;

--
-- Name: plpgsql_call_handler(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION plpgsql_call_handler() RETURNS language_handler
    LANGUAGE c
    AS '$libdir/plpgsql', 'plpgsql_call_handler';


ALTER FUNCTION public.plpgsql_call_handler() OWNER TO enstore;

--
-- Name: plpgsql_validator(oid); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION plpgsql_validator(oid) RETURNS void
    LANGUAGE c
    AS '$libdir/plpgsql', 'plpgsql_validator';


ALTER FUNCTION public.plpgsql_validator(oid) OWNER TO enstore;

--
-- Name: populate_file_table(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION populate_file_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
--      IF(TG_OP='INSERT') THEN
        -- NEW.cache_status='CREATED';
	-- NEW.cache_mod_time=LOCALTIMESTAMP(0);
IF (TG_OP='UPDATE') THEN
        IF (OLD.cache_status<>NEW.cache_status) THEN
		NEW.cache_mod_time=LOCALTIMESTAMP(0);
	END IF;
        IF (OLD.archive_status<>NEW.archive_status) THEN
		NEW.archive_mod_time=LOCALTIMESTAMP(0);
	END IF;
	IF (NEW.deleted<>OLD.deleted) THEN
	   IF (OLD.deleted='n') THEN
	   	   IF (NEW.deleted='y' OR NEW.deleted='u') THEN
		      ---
		      --- Updating package counters
		      ---
		      IF (OLD.bfid <> OLD.package_id and OLD.package_id IS NOT NULL) THEN
		          BEGIN
	      	      	    update file set active_package_files_count=active_package_files_count-1 where bfid=OLD.package_id;
			  END;
		      END IF;
	   	   END IF;
           ELSE
	   	   IF (NEW.deleted='n') THEN
		      ---
		      --- Updating package counters
		      ---
		      IF (OLD.bfid <> OLD.package_id and OLD.package_id IS NOT NULL) THEN
		         BEGIN
		      	    update file set active_package_files_count=active_package_files_count+1 where bfid=OLD.package_id;
		         END;
                      END IF;
	   	   END IF;
	   END IF;
	END IF;
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION public.populate_file_table() OWNER TO enstore;

--
-- Name: populate_files_in_transition_table(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION populate_files_in_transition_table() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF(TG_OP='INSERT') THEN
        IF NEW.original_library IS NOT NULL THEN
	   BEGIN
		INSERT INTO files_in_transition values (NEW.bfid);
	   END;
        END IF;
ELSEIF (TG_OP='UPDATE') THEN
	IF (OLD.bfid<>NEW.bfid) THEN
		BEGIN
			UPDATE files_in_transition set bfid=NEW.bfid where bfid=OLD.bfid;
		END;
	END IF;
	IF (NEW.archive_status = 'ARCHIVED' OR NEW.deleted = 'y' ) THEN
		BEGIN
			DELETE FROM files_in_transition WHERE bfid=NEW.bfid;
		END;
	END IF;
	IF (OLD.cache_status<>NEW.cache_status) THEN
	   IF (NEW.cache_status = 'CACHED') THEN
	      	BEGIN
			INSERT INTO cached_files values (NEW.bfid);
		END;
	   ELSE
             BEGIN
	            DELETE FROM cached_files WHERE bfid=NEW.bfid;
	     END;
	   END IF;
        END IF;

END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION public.populate_files_in_transition_table() OWNER TO enstore;

--
-- Name: print_volume_update(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION print_volume_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF(TG_OP='INSERT') THEN
ELSEIF (TG_OP='INSERT') THEN
       RAISE NOTICE 'INSERT volume record label=% id=% active_files=% deleted_files=% unknown_files=%',NEW.label,NEW.id,NEW.active_files,NEW.deleted_files,NEW.unknown_files;
       RETURN NEW;
ELSEIF (TG_OP='UPDATE') THEN
       RAISE NOTICE 'UPDATE volume record label=% id=% active_files=% deleted_files=% unknown_files=% (old values active_files=% deleted_files=% unknown_files=%)',NEW.label,NEW.id,NEW.active_files,NEW.deleted_files,NEW.unknown_files,OLD.active_files,OLD.deleted_files,OLD.unknown_files;
       RETURN NEW;
ELSEIF (TG_OP='DELETE') THEN
       RETURN OLD;
END IF;
END;
$$;


ALTER FUNCTION public.print_volume_update() OWNER TO enstore;

SET default_tablespace = '';

SET default_with_oids = true;

--
-- Name: qa; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE qa (
    media_type character varying,
    library character varying,
    storage_group character varying,
    monthly numeric,
    weekly numeric,
    daily numeric,
    projected_daily numeric,
    quota integer,
    allocated integer,
    days_surviving numeric,
    alert character varying
);


ALTER TABLE public.qa OWNER TO enstore;

--
-- Name: quota_alert(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION quota_alert() RETURNS SETOF qa
    LANGUAGE sql
    AS $$
select *,
	case
		when m1.days_surviving < 3 then 'less than 3 days'
		when m1.days_surviving < 7 then 'less than 1 week'
	end :: varchar as alert
	from
	(select *,
		trunc((m.quota - m.allocated)/(
			case
				when m.projected_daily = 0 then null
				else m.projected_daily
			end)) as days_surviving
	from
		(select
			u.media_type, u.library, u.storage_group, u.monthly,
			u.weekly, u.daily,
			case
				when u.weekly/7 > u.daily or u.daily is null
					then round(u.weekly/7, 5)
				else u.daily
			end as projected_daily,
			quota.quota, sg_count.count as allocated
		from quota, sg_count,
			(select monthly.media_type, monthly.library,
				monthly.storage_group, monthly.volumes as monthly,
				dw.weekly, dw.daily
			from
				tape_consumption('1 month', 'n') as monthly
				full outer join
				(select weekly.media_type, weekly.storage_group, daily.volumes as daily , weekly.volumes as weekly
				from
					tape_consumption('1 day', 'r') as daily
					full outer join
					tape_consumption('1 week', 'r') as weekly
					on (daily.media_type = weekly.media_type and daily.storage_group = weekly.storage_group)) as dw
				on (monthly.media_type = dw.media_type and monthly.storage_group = dw.storage_group)
			order by media_type, storage_group) as u
		where
			u.library = quota.library and
			u.storage_group = quota.storage_group and
			sg_count.library = u.library and
			sg_count.storage_group = u.storage_group) as m
	) as m1;
$$;


ALTER FUNCTION public.quota_alert() OWNER TO enstore;

--
-- Name: set_update(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION set_update() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
declare
begin
    new.update = now();
    return new;
end;
$$;


ALTER FUNCTION public.set_update() OWNER TO enstore;

--
-- Name: swap_package(character varying, character varying); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION swap_package(old_bfid character varying, new_bfid character varying) RETURNS void
    LANGUAGE plpgsql
    AS $$
DECLARE
	old_record RECORD;
	new_record RECORD;
BEGIN
      IF ( new_bfid is NULL ) THEN
          RAISE EXCEPTION 'destination package bfid is not specified';
	  RETURN;
      END IF;
      select into old_record * from file where bfid=old_bfid;
      select into new_record * from file where bfid=new_bfid;
      IF ( old_record is NULL ) THEN
          RAISE EXCEPTION 'source package % does not exist', old_bfid;
	  RETURN;
      END IF;
      IF ( new_record is NULL ) THEN
          RAISE EXCEPTION 'destination package % does not exist', new_bfid;
	  RETURN;
      END IF;
      IF ( old_record.package_id is NULL ) THEN
          RAISE EXCEPTION '% is not a package file',old_bfid;
	  RETURN;
      END IF;
      update file set package_id=new_bfid where package_id=old_bfid and package_id <> bfid;
      update file set package_files_count=package_files_count+old_record.package_files_count, active_package_files_count=active_package_files_count+old_record.active_package_files_count,package_id=new_bfid where bfid=new_bfid;
      update file set package_files_count=0, active_package_files_count=0 where bfid=old_bfid;
END;
$$;


ALTER FUNCTION public.swap_package(old_bfid character varying, new_bfid character varying) OWNER TO enstore;

--
-- Name: tc; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE tc (
    media_type character varying,
    library character varying,
    storage_group character varying,
    volumes numeric
);


ALTER TABLE public.tc OWNER TO enstore;

--
-- Name: tape_consumption(interval, character); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION tape_consumption(interval, character) RETURNS SETOF tc
    LANGUAGE sql
    AS $_$
select media_type, library, storage_group, sum(volumes)
from
	(select media_type, library, storage_group, file_family,
		sum(size),
		case
			when $2 = 'r' then
				round(sum(size)/media_capacity.capacity, 5)
			else
				trunc((sum(size)-1)/media_capacity.capacity)+1
		end as volumes
	from file, volume, media_capacity
	where
		file.volume = volume.id and
		media_capacity.type = volume.media_type and
		volume.media_type != 'null' and
		bfid > 'CDMS' || to_char(trunc(date_part('epoch', now() - $1)), 'FM99999999999999') || '00000' and
		bfid < 'CDMS' || to_char(trunc(date_part('epoch', now() + interval '1 day')), 'FM99999999999999') || '00000'
		group by media_type, library, storage_group,
			file_family, capacity) as foo
group by media_type, library, storage_group;
$_$;


ALTER FUNCTION public.tape_consumption(interval, character) OWNER TO enstore;

--
-- Name: tapes_recycled(timestamp without time zone, timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION tapes_recycled(timestamp without time zone, timestamp without time zone) RETURNS SETOF tr
    LANGUAGE sql
    AS $_$
select
        media_type,
        count(*)::int as recycled
from
        state,
        volume
where
        state.volume = volume.id and
        value = 'RECYCLED' and
        time >= $1::timestamp and
        time < $2::timestamp
group by media_type
order by media_type;
$_$;


ALTER FUNCTION public.tapes_recycled(timestamp without time zone, timestamp without time zone) OWNER TO enstore;

--
-- Name: tapes_recycled(timestamp without time zone); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION tapes_recycled(timestamp without time zone) RETURNS SETOF tr
    LANGUAGE sql
    AS $_$
select
        media_type,
        count(*)::int as recycled
from
        state,
        volume
where
        state.volume = volume.id and
        value = 'RECYCLED' and
        time >= $1::timestamp
group by media_type
order by media_type;
$_$;


ALTER FUNCTION public.tapes_recycled(timestamp without time zone) OWNER TO enstore;

--
-- Name: tapes_recycled_last_7days(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION tapes_recycled_last_7days() RETURNS SETOF tr
    LANGUAGE sql
    AS $$
select
        media_type,
        count(*)::int as recycled
from
        state,
        volume
where
        state.volume = volume.id and
        value = 'RECYCLED' and
        time >= current_date - 8 and
        time < current_date
group by media_type
order by media_type;
$$;


ALTER FUNCTION public.tapes_recycled_last_7days() OWNER TO enstore;

--
-- Name: update_volume_file_counters(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION update_volume_file_counters() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
DECLARE
delta bigint;
BEGIN
IF(TG_OP='INSERT') THEN
	IF(NEW.deleted='u') THEN
		update volume set unknown_files=unknown_files+1, unknown_bytes=unknown_bytes+NEW.size,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
	ELSEIF (NEW.deleted='y') THEN
		update volume set deleted_files=deleted_files+1, deleted_bytes=deleted_bytes+NEW.size,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
	ELSEIF (NEW.deleted='n') THEN
		update volume set active_files=active_files+1, active_bytes=active_bytes+NEW.size,modification_time=LOCALTIMESTAMP(0)  where volume.id=NEW.volume;
	END IF;
ELSEIF (TG_OP='UPDATE') THEN
	delta := NEW.size-OLD.size;
	IF(NEW.deleted<>OLD.deleted) THEN
		IF(OLD.deleted='y') THEN
			update volume set deleted_files=deleted_files-1, deleted_bytes=deleted_bytes-OLD.size,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		ELSEIF (OLD.deleted='n') THEN
			update volume set active_files= active_files-1, active_bytes=active_bytes-OLD.size,modification_time=LOCALTIMESTAMP(0)  where volume.id=NEW.volume;
		ELSEIF (OLD.deleted='u') THEN
			update volume set unknown_files= unknown_files-1, unknown_bytes=unknown_bytes-OLD.size,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		END IF;
		IF(NEW.deleted='u') THEN
			update volume set unknown_files= unknown_files+1, unknown_bytes=unknown_bytes+OLD.size+delta,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		ELSEIF (NEW.deleted='y') THEN
			update volume set deleted_files= deleted_files+1, deleted_bytes=deleted_bytes+OLD.size+delta,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		ELSEIF (NEW.deleted='n') THEN
			update volume set active_files= active_files+1, active_bytes=active_bytes+OLD.size+delta,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		END IF;
	ELSEIF (OLD.size<>NEW.size) THEN
		IF(OLD.deleted='y') THEN
			update volume set deleted_bytes=deleted_bytes+delta,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		ELSEIF (OLD.deleted='n') THEN
			update volume set active_bytes=active_bytes+delta,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		ELSEIF (OLD.deleted='u') THEN
			update volume set unknown_bytes=unknown_bytes+delta,modification_time=LOCALTIMESTAMP(0) where volume.id=NEW.volume;
		END IF;
	END IF;
ELSEIF (TG_OP='DELETE') THEN
	IF(OLD.deleted='y') THEN
		update volume set  deleted_files=deleted_files-1, deleted_bytes=deleted_bytes-OLD.size,modification_time=LOCALTIMESTAMP(0)  where volume.id=OLD.volume;
	ELSEIF (OLD.deleted='n') THEN
		update volume set active_files= active_files-1, active_bytes=active_bytes-OLD.size,modification_time=LOCALTIMESTAMP(0) where volume.id=OLD.volume;
	ELSEIF (OLD.deleted='u') THEN
		update volume set unknown_files= unknown_files-1, unknown_bytes=unknown_bytes-OLD.size,modification_time=LOCALTIMESTAMP(0) where volume.id=OLD.volume;
	END IF;
	RETURN OLD;
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION public.update_volume_file_counters() OWNER TO enstore;

--
-- Name: volume_audit(); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION volume_audit() RETURNS trigger
    LANGUAGE plpgsql
    AS $$
BEGIN
IF (TG_OP='INSERT') THEN
      INSERT into volume_audit_counter select 0,NEW.volume where not exists (select volume from volume_audit_counter where volume=NEW.volume);
      UPDATE volume_audit_counter SET counter=counter+1 where volume=NEW.volume;
END IF;
RETURN NEW;
END;
$$;


ALTER FUNCTION public.volume_audit() OWNER TO enstore;

--
-- Name: write_protect_status(character varying); Type: FUNCTION; Schema: public; Owner: enstore
--

CREATE FUNCTION write_protect_status(character varying) RETURNS character
    LANGUAGE sql
    AS $_$
select
    case value
        when 'ON' then 'y'
        when 'OFF' then 'n'
        else 'u'
    end
from state, state_type, volume
where
    state.type = state_type.id and
    state_type.name = 'write_protect' and
    state.volume = volume.id and
    volume.label = $1
order by time desc limit 1;
$_$;


ALTER FUNCTION public.write_protect_status(character varying) OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: active_file_copying; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE active_file_copying (
    bfid character varying NOT NULL,
    remaining integer,
    "time" timestamp with time zone DEFAULT now()
);


ALTER TABLE public.active_file_copying OWNER TO enstore;

--
-- Name: archive_statuses; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE archive_statuses (
    status character varying(32) NOT NULL,
    explanation character varying(256)
);


ALTER TABLE public.archive_statuses OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: bad_file; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE bad_file (
    bfid character varying,
    path character varying
);


ALTER TABLE public.bad_file OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: cache_statuses; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE cache_statuses (
    status character varying(32) NOT NULL,
    explanation character varying(256)
);


ALTER TABLE public.cache_statuses OWNER TO enstore;

--
-- Name: cached_files; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE cached_files (
    bfid character varying(32) NOT NULL
);


ALTER TABLE public.cached_files OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: volume; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE volume (
    id integer DEFAULT nextval(('volume_seq'::text)::regclass) NOT NULL,
    label character varying,
    block_size integer DEFAULT 0,
    capacity_bytes bigint DEFAULT 0,
    declared timestamp without time zone,
    eod_cookie character varying,
    first_access timestamp without time zone,
    last_access timestamp without time zone,
    library character varying,
    media_type character varying,
    non_del_files integer DEFAULT 0,
    remaining_bytes bigint DEFAULT 0,
    sum_mounts integer DEFAULT 0,
    sum_rd_access integer DEFAULT 0,
    sum_rd_err integer DEFAULT 0,
    sum_wr_access integer DEFAULT 0,
    sum_wr_err integer DEFAULT 0,
    system_inhibit_0 character varying,
    system_inhibit_1 character varying,
    si_time_0 timestamp without time zone,
    si_time_1 timestamp without time zone,
    user_inhibit_0 character varying,
    user_inhibit_1 character varying,
    storage_group character varying,
    file_family character varying,
    wrapper character varying,
    comment character varying,
    write_protected character(1) DEFAULT 'u'::bpchar,
    active_files integer DEFAULT 0,
    deleted_files integer DEFAULT 0,
    unknown_files integer DEFAULT 0,
    active_bytes bigint DEFAULT 0,
    deleted_bytes bigint DEFAULT 0,
    unknown_bytes bigint DEFAULT 0,
    modification_time timestamp without time zone,
    CONSTRAINT volume_write_protected_check CHECK ((((write_protected = 'u'::bpchar) OR (write_protected = 'y'::bpchar)) OR (write_protected = 'n'::bpchar)))
);


ALTER TABLE public.volume OWNER TO enstore;

--
-- Name: cms_volume_with_only_deleted_files; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW cms_volume_with_only_deleted_files AS
    SELECT volume.label, volume.storage_group, volume.file_family, volume.system_inhibit_1 AS state, volume.media_type, volume.library FROM volume WHERE (((((volume.storage_group)::text = 'cms'::text) AND ((volume.system_inhibit_0)::text = 'none'::text)) AND ((volume.active_files + volume.unknown_files) = 0)) AND (volume.deleted_files > 0));


ALTER TABLE public.cms_volume_with_only_deleted_files OWNER TO enstore;

--
-- Name: file; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE file (
    bfid character varying NOT NULL,
    crc bigint DEFAULT (-1),
    deleted character(1) DEFAULT 'u'::bpchar,
    drive character varying,
    volume integer,
    location_cookie character varying,
    pnfs_path character varying,
    pnfs_id character varying,
    sanity_size bigint DEFAULT (-1),
    sanity_crc bigint DEFAULT (-1),
    size bigint DEFAULT 0,
    uid integer DEFAULT (-1),
    gid integer DEFAULT (-1),
    update timestamp without time zone,
    package_id character varying(32),
    active_package_files_count integer,
    package_files_count integer,
    cache_status character varying(32),
    archive_status character varying(32),
    cache_mod_time timestamp without time zone,
    archive_mod_time timestamp without time zone,
    cache_location character varying,
    original_library character varying,
    file_family_width integer
);


ALTER TABLE public.file OWNER TO enstore;

--
-- Name: file_copies_map; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE file_copies_map (
    bfid character varying,
    alt_bfid character varying
);


ALTER TABLE public.file_copies_map OWNER TO enstore;

--
-- Name: duplicates; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW duplicates AS
    SELECT m.bfid AS "primary", m.alt_bfid AS copy, f.deleted, f.pnfs_path FROM file_copies_map m, file f WHERE ((f.bfid)::text = (m.bfid)::text);


ALTER TABLE public.duplicates OWNER TO enstore;

--
-- Name: file2; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW file2 AS
    SELECT file.bfid, file.crc, file.deleted, file.drive, file.volume, file.location_cookie, file.pnfs_path, file.pnfs_id, file.sanity_size, file.sanity_crc, file.size, file.uid, file.gid, CASE WHEN (file.deleted = 'y'::bpchar) THEN 1 ELSE 0 END AS n_deleted, CASE WHEN (file.deleted = 'y'::bpchar) THEN file.size ELSE (0)::bigint END AS size_deleted, CASE WHEN (file.deleted = 'n'::bpchar) THEN 1 ELSE 0 END AS n_active, CASE WHEN (file.deleted = 'n'::bpchar) THEN file.size ELSE (0)::bigint END AS size_active, CASE WHEN ((file.deleted <> 'y'::bpchar) AND (file.deleted <> 'n'::bpchar)) THEN 1 ELSE 0 END AS n_unknown, CASE WHEN ((file.deleted <> 'y'::bpchar) AND (file.deleted <> 'n'::bpchar)) THEN file.size ELSE (0)::bigint END AS size_unknown FROM file;


ALTER TABLE public.file2 OWNER TO enstore;

--
-- Name: file_info; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW file_info AS
    SELECT f.bfid, f.crc AS complete_crc, CASE WHEN (f.deleted = 'y'::bpchar) THEN 'deleted'::text WHEN (f.deleted = 'n'::bpchar) THEN 'active'::text ELSE 'unknown'::text END AS deleted, v.label AS external_label, f.location_cookie, v.storage_group, v.file_family, v.library, v.media_type, f.size, f.gid, f.uid, f.pnfs_id AS pnfsid, f.pnfs_path AS pnfs_name0, f.sanity_size, f.sanity_crc, f.drive, f.update FROM file f, volume v WHERE (f.volume = v.id);


ALTER TABLE public.file_info OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: files_in_transition; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE files_in_transition (
    bfid character varying(32) NOT NULL
);


ALTER TABLE public.files_in_transition OWNER TO enstore;

--
-- Name: historic_tape_bytes; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE historic_tape_bytes (
    date timestamp without time zone NOT NULL,
    storage_group character varying NOT NULL,
    active_bytes bigint,
    unknown_bytes bigint,
    deleted_bytes bigint,
    active_files bigint,
    unknown_files bigint,
    deleted_files bigint
);


ALTER TABLE public.historic_tape_bytes OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: media_capacity; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE media_capacity (
    type character varying NOT NULL,
    capacity bigint
);


ALTER TABLE public.media_capacity OWNER TO enstore;

--
-- Name: migration; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE migration (
    src_bfid character varying NOT NULL,
    dst_bfid character varying NOT NULL,
    copied timestamp without time zone,
    swapped timestamp without time zone,
    checked timestamp without time zone,
    closed timestamp without time zone,
    remark character varying
);


ALTER TABLE public.migration OWNER TO enstore;

--
-- Name: migration_history; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE migration_history (
    src character varying NOT NULL,
    dst character varying NOT NULL,
    "time" timestamp without time zone DEFAULT now(),
    src_vol_id integer DEFAULT (-1) NOT NULL,
    dst_vol_id integer DEFAULT (-1) NOT NULL,
    closed_time timestamp without time zone
);


ALTER TABLE public.migration_history OWNER TO enstore;

--
-- Name: no_flipping_file_family; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE no_flipping_file_family (
    storage_group character varying,
    file_family character varying
);


ALTER TABLE public.no_flipping_file_family OWNER TO enstore;

--
-- Name: no_flipping_storage_group; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE no_flipping_storage_group (
    storage_group character varying
);


ALTER TABLE public.no_flipping_storage_group OWNER TO enstore;

--
-- Name: option; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE option (
    key character varying,
    value character varying
);


ALTER TABLE public.option OWNER TO enstore;

--
-- Name: quota; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE quota (
    library character varying NOT NULL,
    storage_group character varying NOT NULL,
    requested integer DEFAULT 0,
    authorized integer DEFAULT 0,
    quota integer DEFAULT 0,
    significance character(1) DEFAULT 'y'::bpchar
);


ALTER TABLE public.quota OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: quotas; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE quotas (
    "time" timestamp with time zone DEFAULT now() NOT NULL,
    library character varying NOT NULL,
    storage_group character varying NOT NULL,
    allocated integer,
    blank integer NOT NULL,
    written integer NOT NULL,
    requested integer,
    authorized integer,
    quota integer
);


ALTER TABLE public.quotas OWNER TO enstore;

--
-- Name: remaining_blanks; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW remaining_blanks AS
    SELECT volume.media_type, count(*) AS blanks FROM volume WHERE ((((volume.storage_group)::text = 'none'::text) AND ((volume.file_family)::text = 'none'::text)) AND ((volume.wrapper)::text = 'none'::text)) GROUP BY volume.media_type;


ALTER TABLE public.remaining_blanks OWNER TO enstore;

SET default_with_oids = true;

--
-- Name: sg_count; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE sg_count (
    library character varying NOT NULL,
    storage_group character varying NOT NULL,
    count integer
);


ALTER TABLE public.sg_count OWNER TO enstore;

--
-- Name: state; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE state (
    "time" timestamp without time zone DEFAULT now(),
    volume integer NOT NULL,
    type integer,
    value character varying
);


ALTER TABLE public.state OWNER TO enstore;

--
-- Name: state_type; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE state_type (
    id integer DEFAULT nextval(('state_type_seq'::text)::regclass) NOT NULL,
    name character varying NOT NULL
);


ALTER TABLE public.state_type OWNER TO enstore;

--
-- Name: state_type_seq; Type: SEQUENCE; Schema: public; Owner: enstore
--

CREATE SEQUENCE state_type_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.state_type_seq OWNER TO enstore;

SET default_with_oids = false;

--
-- Name: volume_audit; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE volume_audit (
    id bigint NOT NULL,
    volume integer NOT NULL,
    start timestamp with time zone NOT NULL,
    finish timestamp with time zone NOT NULL,
    bfid character varying,
    result integer NOT NULL,
    error character varying
);


ALTER TABLE public.volume_audit OWNER TO enstore;

--
-- Name: volume_audit_counter; Type: TABLE; Schema: public; Owner: enstore; Tablespace:
--

CREATE TABLE volume_audit_counter (
    counter integer,
    volume integer NOT NULL
);


ALTER TABLE public.volume_audit_counter OWNER TO enstore;

--
-- Name: volume_audit_id_seq; Type: SEQUENCE; Schema: public; Owner: enstore
--

CREATE SEQUENCE volume_audit_id_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.volume_audit_id_seq OWNER TO enstore;

--
-- Name: volume_audit_id_seq; Type: SEQUENCE OWNED BY; Schema: public; Owner: enstore
--

ALTER SEQUENCE volume_audit_id_seq OWNED BY volume_audit.id;


--
-- Name: volume_seq; Type: SEQUENCE; Schema: public; Owner: enstore
--

CREATE SEQUENCE volume_seq
    START WITH 1
    INCREMENT BY 1
    NO MAXVALUE
    NO MINVALUE
    CACHE 1;


ALTER TABLE public.volume_seq OWNER TO enstore;

--
-- Name: volume_summary; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW volume_summary AS
    SELECT volume.label, volume.capacity_bytes, sum(file2.size) AS used, sum(file2.n_active) AS n_active, sum(file2.size_active) AS active, sum(file2.n_deleted) AS n_deleted, sum(file2.size_deleted) AS deleted, sum(file2.n_unknown) AS n_unknown, sum(file2.size_unknown) AS unknown, volume.remaining_bytes, (((volume.capacity_bytes - volume.remaining_bytes))::numeric - sum(file2.size)) AS unaccountable, volume.declared, volume.eod_cookie, volume.first_access, volume.last_access, volume.library, volume.media_type, volume.sum_mounts, volume.sum_rd_access, volume.sum_rd_err, volume.sum_wr_access, volume.sum_wr_err, volume.system_inhibit_0, volume.system_inhibit_1, volume.si_time_0, volume.si_time_1, volume.user_inhibit_0, volume.user_inhibit_1, volume.storage_group, volume.file_family, volume.wrapper, volume.comment FROM file2, volume WHERE (file2.volume = volume.id) GROUP BY volume.label, volume.capacity_bytes, volume.remaining_bytes, volume.declared, volume.eod_cookie, volume.first_access, volume.last_access, volume.library, volume.media_type, volume.sum_mounts, volume.sum_rd_access, volume.sum_rd_err, volume.sum_wr_access, volume.sum_wr_err, volume.system_inhibit_0, volume.system_inhibit_1, volume.si_time_0, volume.si_time_1, volume.user_inhibit_0, volume.user_inhibit_1, volume.storage_group, volume.file_family, volume.wrapper, volume.comment;


ALTER TABLE public.volume_summary OWNER TO enstore;

--
-- Name: volume_summary2; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW volume_summary2 AS
    SELECT volume.label, volume.capacity_bytes, sum(CASE WHEN (file.size IS NULL) THEN (0)::bigint ELSE file.size END) AS used, count(CASE WHEN (file.deleted = 'n'::bpchar) THEN 1 ELSE NULL::integer END) AS n_active, sum(CASE WHEN ((file.deleted = 'n'::bpchar) AND (file.size IS NOT NULL)) THEN file.size ELSE (0)::bigint END) AS active, count(CASE WHEN (file.deleted = 'y'::bpchar) THEN 1 ELSE NULL::integer END) AS n_deleted, sum(CASE WHEN ((file.deleted = 'y'::bpchar) AND (file.size IS NOT NULL)) THEN file.size ELSE (0)::bigint END) AS deleted, count(CASE WHEN (file.deleted = 'u'::bpchar) THEN 1 ELSE NULL::integer END) AS n_unknown, sum(CASE WHEN ((file.deleted = 'u'::bpchar) AND (file.size IS NOT NULL)) THEN file.size ELSE (0)::bigint END) AS unknown, volume.remaining_bytes, (((volume.capacity_bytes - volume.remaining_bytes))::numeric - sum(file.size)) AS unaccountable, volume.declared, volume.eod_cookie, volume.first_access, volume.last_access, volume.library, volume.media_type, volume.sum_mounts, volume.sum_rd_access, volume.sum_rd_err, volume.sum_wr_access, volume.sum_wr_err, volume.system_inhibit_0, volume.system_inhibit_1, volume.si_time_0, volume.si_time_1, volume.user_inhibit_0, volume.user_inhibit_1, volume.storage_group, volume.file_family, volume.wrapper, volume.comment FROM (volume LEFT JOIN file ON ((file.volume = volume.id))) GROUP BY volume.label, volume.capacity_bytes, volume.remaining_bytes, volume.declared, volume.eod_cookie, volume.first_access, volume.last_access, volume.library, volume.media_type, volume.sum_mounts, volume.sum_rd_access, volume.sum_rd_err, volume.sum_wr_access, volume.sum_wr_err, volume.system_inhibit_0, volume.system_inhibit_1, volume.si_time_0, volume.si_time_1, volume.user_inhibit_0, volume.user_inhibit_1, volume.storage_group, volume.file_family, volume.wrapper, volume.comment;


ALTER TABLE public.volume_summary2 OWNER TO enstore;

--
-- Name: volume_with_only_deleted_files; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW volume_with_only_deleted_files AS
    SELECT foo.label, foo.storage_group, foo.file_family, foo.state, foo.media_type, foo.library, foo.n_active, foo.n_deleted, foo.n_unknown FROM (SELECT volume.label, volume.storage_group, volume.file_family, volume.system_inhibit_1 AS state, volume.media_type, volume.library, count(CASE WHEN (file.deleted = 'n'::bpchar) THEN 1 ELSE NULL::integer END) AS n_active, count(CASE WHEN (file.deleted = 'y'::bpchar) THEN 1 ELSE NULL::integer END) AS n_deleted, count(CASE WHEN (file.deleted = 'u'::bpchar) THEN 1 ELSE NULL::integer END) AS n_unknown FROM (volume LEFT JOIN file ON ((file.volume = volume.id))) WHERE (NOT ((volume.label)::text ~~ '%.deleted'::text)) GROUP BY volume.label, volume.storage_group, volume.file_family, volume.system_inhibit_1, volume.media_type, volume.library) foo WHERE ((foo.n_active = 0) AND (foo.n_deleted > 0));


ALTER TABLE public.volume_with_only_deleted_files OWNER TO enstore;

--
-- Name: write_protection_audit; Type: VIEW; Schema: public; Owner: enstore
--

CREATE VIEW write_protection_audit AS
    SELECT volume.id, volume.label, volume.block_size, volume.capacity_bytes, volume.declared, volume.eod_cookie, volume.first_access, volume.last_access, volume.library, volume.media_type, volume.non_del_files, volume.remaining_bytes, volume.sum_mounts, volume.sum_rd_access, volume.sum_rd_err, volume.sum_wr_access, volume.sum_wr_err, volume.system_inhibit_0, volume.system_inhibit_1, volume.si_time_0, volume.si_time_1, volume.user_inhibit_0, volume.user_inhibit_1, volume.storage_group, volume.file_family, volume.wrapper, volume.comment, volume.write_protected FROM volume WHERE ((NOT ((volume.label)::text ~~ '%.deleted'::text)) AND ((((volume.system_inhibit_1)::text <> 'none'::text) AND (volume.write_protected <> 'y'::bpchar)) OR (((volume.system_inhibit_1)::text = 'none'::text) AND (volume.write_protected <> 'n'::bpchar))));


ALTER TABLE public.write_protection_audit OWNER TO enstore;

--
-- Name: id; Type: DEFAULT; Schema: public; Owner: enstore
--

ALTER TABLE volume_audit ALTER COLUMN id SET DEFAULT nextval('volume_audit_id_seq'::regclass);


--
-- Name: active_file_copying_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY active_file_copying
    ADD CONSTRAINT active_file_copying_pkey PRIMARY KEY (bfid);


--
-- Name: file_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY file
    ADD CONSTRAINT file_pkey PRIMARY KEY (bfid);


--
-- Name: media_capacity_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY media_capacity
    ADD CONSTRAINT media_capacity_pkey PRIMARY KEY (type);


--
-- Name: migration_history_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY migration_history
    ADD CONSTRAINT migration_history_pkey PRIMARY KEY (src_vol_id, dst_vol_id);


--
-- Name: migration_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY migration
    ADD CONSTRAINT migration_pkey PRIMARY KEY (src_bfid, dst_bfid);


--
-- Name: pk_archive_statuses; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY archive_statuses
    ADD CONSTRAINT pk_archive_statuses PRIMARY KEY (status);


--
-- Name: pk_cache_statuses; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY cache_statuses
    ADD CONSTRAINT pk_cache_statuses PRIMARY KEY (status);


--
-- Name: pk_cached_files; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY cached_files
    ADD CONSTRAINT pk_cached_files PRIMARY KEY (bfid);


--
-- Name: pk_files_in_transition; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY files_in_transition
    ADD CONSTRAINT pk_files_in_transition PRIMARY KEY (bfid);


--
-- Name: pk_historic_tape_bytes; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY historic_tape_bytes
    ADD CONSTRAINT pk_historic_tape_bytes PRIMARY KEY (date, storage_group);


--
-- Name: quota_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY quota
    ADD CONSTRAINT quota_pkey PRIMARY KEY (library, storage_group);


--
-- Name: quotas_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY quotas
    ADD CONSTRAINT quotas_pkey PRIMARY KEY ("time", library, storage_group);


--
-- Name: sg_count_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY sg_count
    ADD CONSTRAINT sg_count_pkey PRIMARY KEY (library, storage_group);


--
-- Name: state_type_name_key; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY state_type
    ADD CONSTRAINT state_type_name_key UNIQUE (name);


--
-- Name: state_type_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY state_type
    ADD CONSTRAINT state_type_pkey PRIMARY KEY (id);


--
-- Name: volume_audit_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY volume_audit
    ADD CONSTRAINT volume_audit_pkey PRIMARY KEY (id);


--
-- Name: volume_label_key; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY volume
    ADD CONSTRAINT volume_label_key UNIQUE (label);


--
-- Name: volume_pkey; Type: CONSTRAINT; Schema: public; Owner: enstore; Tablespace:
--

ALTER TABLE ONLY volume
    ADD CONSTRAINT volume_pkey PRIMARY KEY (id);


--
-- Name: archive_status_fk_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX archive_status_fk_idx ON file USING btree (archive_status);


--
-- Name: bad_file_bfid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX bad_file_bfid_idx ON bad_file USING btree (bfid);


--
-- Name: cache_location_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX cache_location_idx ON file USING btree (cache_location);


--
-- Name: cache_status_fk_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX cache_status_fk_idx ON file USING btree (cache_status);


--
-- Name: file_copies_map_alt_bfid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_copies_map_alt_bfid_idx ON file_copies_map USING btree (alt_bfid);


--
-- Name: file_copies_map_bfid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_copies_map_bfid_idx ON file_copies_map USING btree (bfid);


--
-- Name: file_crc_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_crc_idx ON file USING btree (crc);


--
-- Name: file_deleted_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_deleted_idx ON file USING btree (deleted);


--
-- Name: file_family_width_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_family_width_idx ON file USING btree (file_family_width);


--
-- Name: file_location_cookie_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_location_cookie_idx ON file USING btree (location_cookie);


--
-- Name: file_pnfs_id_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_pnfs_id_idx ON file USING btree (pnfs_id);


--
-- Name: file_pnfs_path_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_pnfs_path_idx ON file USING btree (pnfs_path);


--
-- Name: file_sanity_crc_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_sanity_crc_idx ON file USING btree (sanity_crc);


--
-- Name: file_sanity_size_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_sanity_size_idx ON file USING btree (sanity_size);


--
-- Name: file_size_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_size_idx ON file USING btree (size);


--
-- Name: file_volume_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX file_volume_idx ON file USING btree (volume);


--
-- Name: migration_dst_bfid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX migration_dst_bfid_idx ON migration USING btree (dst_bfid);


--
-- Name: migration_history_dst_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX migration_history_dst_idx ON migration_history USING btree (dst);


--
-- Name: migration_history_src_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX migration_history_src_idx ON migration_history USING btree (src);


--
-- Name: migration_src_bfid_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX migration_src_bfid_idx ON migration USING btree (src_bfid);


--
-- Name: original_library_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX original_library_idx ON file USING btree (original_library);


--
-- Name: package_id_fk_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX package_id_fk_idx ON file USING btree (package_id);


--
-- Name: quota_library_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX quota_library_idx ON quota USING btree (library);


--
-- Name: quota_storage_group_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX quota_storage_group_idx ON quota USING btree (storage_group);


--
-- Name: state_time_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX state_time_idx ON state USING btree ("time");


--
-- Name: state_type_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX state_type_idx ON state USING btree (type);


--
-- Name: state_value_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX state_value_idx ON state USING btree (value);


--
-- Name: state_volume_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX state_volume_idx ON state USING btree (volume);


--
-- Name: volume_declared_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_declared_idx ON volume USING btree (declared);


--
-- Name: volume_eod_cookie_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_eod_cookie_idx ON volume USING btree (eod_cookie);


--
-- Name: volume_file_family_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_file_family_idx ON volume USING btree (file_family);


--
-- Name: volume_label_key_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_label_key_idx ON volume USING btree (label);


--
-- Name: volume_last_access_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_last_access_idx ON volume USING btree (last_access);


--
-- Name: volume_library_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_library_idx ON volume USING btree (library);


--
-- Name: volume_media_type_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_media_type_idx ON volume USING btree (media_type);


--
-- Name: volume_modification_time_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_modification_time_idx ON volume USING btree (modification_time);


--
-- Name: volume_remaining_bytes_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_remaining_bytes_idx ON volume USING btree (remaining_bytes);


--
-- Name: volume_storage_group_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_storage_group_idx ON volume USING btree (storage_group);


--
-- Name: volume_system_inhibit_0_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_system_inhibit_0_idx ON volume USING btree (system_inhibit_0);


--
-- Name: volume_system_inhibit_1_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_system_inhibit_1_idx ON volume USING btree (system_inhibit_1);


--
-- Name: volume_user_inhibit_0_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_user_inhibit_0_idx ON volume USING btree (user_inhibit_0);


--
-- Name: volume_user_inhibit_1_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_user_inhibit_1_idx ON volume USING btree (user_inhibit_1);


--
-- Name: volume_wrapper_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_wrapper_idx ON volume USING btree (wrapper);


--
-- Name: volume_write_protected_idx; Type: INDEX; Schema: public; Owner: enstore; Tablespace:
--

CREATE INDEX volume_write_protected_idx ON volume USING btree (write_protected);


--
-- Name: populate_file_table; Type: TRIGGER; Schema: public; Owner: enstore
--

CREATE TRIGGER populate_file_table
    BEFORE INSERT OR UPDATE ON file
    FOR EACH ROW
    EXECUTE PROCEDURE populate_file_table();


--
-- Name: populate_files_in_transition_table; Type: TRIGGER; Schema: public; Owner: enstore
--

CREATE TRIGGER populate_files_in_transition_table
    AFTER INSERT OR UPDATE ON file
    FOR EACH ROW
    EXECUTE PROCEDURE populate_files_in_transition_table();


--
-- Name: set_update; Type: TRIGGER; Schema: public; Owner: enstore
--

CREATE TRIGGER set_update
    BEFORE INSERT OR UPDATE ON file
    FOR EACH ROW
    EXECUTE PROCEDURE set_update();


--
-- Name: update_volume_counters; Type: TRIGGER; Schema: public; Owner: enstore
--

CREATE TRIGGER update_volume_counters
    AFTER INSERT OR DELETE OR UPDATE ON file
    FOR EACH ROW
    EXECUTE PROCEDURE update_volume_file_counters();


--
-- Name: volume_audit_counter; Type: TRIGGER; Schema: public; Owner: enstore
--

CREATE TRIGGER volume_audit_counter
    AFTER INSERT OR UPDATE ON volume_audit
    FOR EACH ROW
    EXECUTE PROCEDURE volume_audit();


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY file
    ADD CONSTRAINT "$1" FOREIGN KEY (volume) REFERENCES volume(id);


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY state
    ADD CONSTRAINT "$1" FOREIGN KEY (volume) REFERENCES volume(id) ON DELETE CASCADE;


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY bad_file
    ADD CONSTRAINT "$1" FOREIGN KEY (bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY migration
    ADD CONSTRAINT "$1" FOREIGN KEY (src_bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY files_in_transition
    ADD CONSTRAINT "$1" FOREIGN KEY (bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY cached_files
    ADD CONSTRAINT "$1" FOREIGN KEY (bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY volume_audit
    ADD CONSTRAINT "$1" FOREIGN KEY (volume) REFERENCES volume(id) ON DELETE CASCADE;


--
-- Name: $1; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY volume_audit_counter
    ADD CONSTRAINT "$1" FOREIGN KEY (volume) REFERENCES volume(id) ON DELETE CASCADE;


--
-- Name: $2; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY state
    ADD CONSTRAINT "$2" FOREIGN KEY (type) REFERENCES state_type(id);


--
-- Name: $2; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY migration
    ADD CONSTRAINT "$2" FOREIGN KEY (dst_bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: archive_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY file
    ADD CONSTRAINT archive_status_fk FOREIGN KEY (archive_status) REFERENCES archive_statuses(status);


--
-- Name: cache_status_fk; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY file
    ADD CONSTRAINT cache_status_fk FOREIGN KEY (cache_status) REFERENCES cache_statuses(status);


--
-- Name: file_copies_map_alt_bfid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY file_copies_map
    ADD CONSTRAINT file_copies_map_alt_bfid_fkey FOREIGN KEY (alt_bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: file_copies_map_bfid_fkey; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY file_copies_map
    ADD CONSTRAINT file_copies_map_bfid_fkey FOREIGN KEY (bfid) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: package_id_fk; Type: FK CONSTRAINT; Schema: public; Owner: enstore
--

ALTER TABLE ONLY file
    ADD CONSTRAINT package_id_fk FOREIGN KEY (package_id) REFERENCES file(bfid) ON DELETE CASCADE;


--
-- Name: public; Type: ACL; Schema: -; Owner: products
--

REVOKE ALL ON SCHEMA public FROM PUBLIC;
REVOKE ALL ON SCHEMA public FROM products;
GRANT ALL ON SCHEMA public TO PUBLIC;


--
-- Name: qa; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE qa FROM PUBLIC;
REVOKE ALL ON TABLE qa FROM enstore;
GRANT ALL ON TABLE qa TO enstore;
GRANT SELECT ON TABLE qa TO enstore_reader;


--
-- Name: tc; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE tc FROM PUBLIC;
REVOKE ALL ON TABLE tc FROM enstore;
GRANT ALL ON TABLE tc TO enstore;
GRANT SELECT ON TABLE tc TO enstore_reader;


--
-- Name: archive_statuses; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE archive_statuses FROM PUBLIC;
REVOKE ALL ON TABLE archive_statuses FROM enstore;
GRANT ALL ON TABLE archive_statuses TO enstore;
GRANT SELECT ON TABLE archive_statuses TO enstore_reader;


--
-- Name: bad_file; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE bad_file FROM PUBLIC;
REVOKE ALL ON TABLE bad_file FROM enstore;
GRANT ALL ON TABLE bad_file TO enstore;
GRANT SELECT ON TABLE bad_file TO enstore_reader;


--
-- Name: cache_statuses; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE cache_statuses FROM PUBLIC;
REVOKE ALL ON TABLE cache_statuses FROM enstore;
GRANT ALL ON TABLE cache_statuses TO enstore;
GRANT SELECT ON TABLE cache_statuses TO enstore_reader;


--
-- Name: volume; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE volume FROM PUBLIC;
REVOKE ALL ON TABLE volume FROM enstore;
GRANT ALL ON TABLE volume TO enstore;
GRANT SELECT ON TABLE volume TO enstore_reader;


--
-- Name: file; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE file FROM PUBLIC;
REVOKE ALL ON TABLE file FROM enstore;
GRANT ALL ON TABLE file TO enstore;
GRANT SELECT ON TABLE file TO enstore_reader;


--
-- Name: file_copies_map; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE file_copies_map FROM PUBLIC;
REVOKE ALL ON TABLE file_copies_map FROM enstore;
GRANT ALL ON TABLE file_copies_map TO enstore;
GRANT SELECT ON TABLE file_copies_map TO enstore_reader;


--
-- Name: file2; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE file2 FROM PUBLIC;
REVOKE ALL ON TABLE file2 FROM enstore;
GRANT ALL ON TABLE file2 TO enstore;
GRANT SELECT ON TABLE file2 TO enstore_reader;


--
-- Name: files_in_transition; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE files_in_transition FROM PUBLIC;
REVOKE ALL ON TABLE files_in_transition FROM enstore;
GRANT ALL ON TABLE files_in_transition TO enstore;
GRANT SELECT ON TABLE files_in_transition TO enstore_reader;


--
-- Name: historic_tape_bytes; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE historic_tape_bytes FROM PUBLIC;
REVOKE ALL ON TABLE historic_tape_bytes FROM enstore;
GRANT ALL ON TABLE historic_tape_bytes TO enstore;
GRANT SELECT ON TABLE historic_tape_bytes TO enstore_reader;


--
-- Name: media_capacity; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE media_capacity FROM PUBLIC;
REVOKE ALL ON TABLE media_capacity FROM enstore;
GRANT ALL ON TABLE media_capacity TO enstore;
GRANT SELECT ON TABLE media_capacity TO enstore_reader;


--
-- Name: migration; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE migration FROM PUBLIC;
REVOKE ALL ON TABLE migration FROM enstore;
GRANT ALL ON TABLE migration TO enstore;
GRANT SELECT ON TABLE migration TO enstore_reader;


--
-- Name: migration_history; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE migration_history FROM PUBLIC;
REVOKE ALL ON TABLE migration_history FROM enstore;
GRANT ALL ON TABLE migration_history TO enstore;
GRANT SELECT ON TABLE migration_history TO enstore_reader;


--
-- Name: no_flipping_file_family; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE no_flipping_file_family FROM PUBLIC;
REVOKE ALL ON TABLE no_flipping_file_family FROM enstore;
GRANT ALL ON TABLE no_flipping_file_family TO enstore;
GRANT SELECT ON TABLE no_flipping_file_family TO enstore_reader;


--
-- Name: no_flipping_storage_group; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE no_flipping_storage_group FROM PUBLIC;
REVOKE ALL ON TABLE no_flipping_storage_group FROM enstore;
GRANT ALL ON TABLE no_flipping_storage_group TO enstore;
GRANT SELECT ON TABLE no_flipping_storage_group TO enstore_reader;


--
-- Name: option; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE option FROM PUBLIC;
REVOKE ALL ON TABLE option FROM enstore;
GRANT ALL ON TABLE option TO enstore;
GRANT SELECT ON TABLE option TO enstore_reader;


--
-- Name: quota; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE quota FROM PUBLIC;
REVOKE ALL ON TABLE quota FROM enstore;
GRANT ALL ON TABLE quota TO enstore;
GRANT SELECT ON TABLE quota TO enstore_reader;


--
-- Name: remaining_blanks; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE remaining_blanks FROM PUBLIC;
REVOKE ALL ON TABLE remaining_blanks FROM enstore;
GRANT ALL ON TABLE remaining_blanks TO enstore;
GRANT SELECT ON TABLE remaining_blanks TO enstore_reader;


--
-- Name: sg_count; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE sg_count FROM PUBLIC;
REVOKE ALL ON TABLE sg_count FROM enstore;
GRANT ALL ON TABLE sg_count TO enstore;
GRANT SELECT ON TABLE sg_count TO enstore_reader;


--
-- Name: state; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE state FROM PUBLIC;
REVOKE ALL ON TABLE state FROM enstore;
GRANT ALL ON TABLE state TO enstore;
GRANT SELECT ON TABLE state TO enstore_reader;


--
-- Name: state_type; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE state_type FROM PUBLIC;
REVOKE ALL ON TABLE state_type FROM enstore;
GRANT ALL ON TABLE state_type TO enstore;
GRANT SELECT ON TABLE state_type TO enstore_reader;


--
-- Name: state_type_seq; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON SEQUENCE state_type_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE state_type_seq FROM enstore;
GRANT ALL ON SEQUENCE state_type_seq TO enstore;
GRANT SELECT ON SEQUENCE state_type_seq TO enstore_reader;


--
-- Name: volume_seq; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON SEQUENCE volume_seq FROM PUBLIC;
REVOKE ALL ON SEQUENCE volume_seq FROM enstore;
GRANT ALL ON SEQUENCE volume_seq TO enstore;
GRANT SELECT ON SEQUENCE volume_seq TO enstore_reader;


--
-- Name: volume_summary; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE volume_summary FROM PUBLIC;
REVOKE ALL ON TABLE volume_summary FROM enstore;
GRANT ALL ON TABLE volume_summary TO enstore;
GRANT SELECT ON TABLE volume_summary TO enstore_reader;


--
-- Name: volume_summary2; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE volume_summary2 FROM PUBLIC;
REVOKE ALL ON TABLE volume_summary2 FROM enstore;
GRANT ALL ON TABLE volume_summary2 TO enstore;
GRANT SELECT ON TABLE volume_summary2 TO enstore_reader;


--
-- Name: volume_with_only_deleted_files; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE volume_with_only_deleted_files FROM PUBLIC;
REVOKE ALL ON TABLE volume_with_only_deleted_files FROM enstore;
GRANT ALL ON TABLE volume_with_only_deleted_files TO enstore;
GRANT SELECT ON TABLE volume_with_only_deleted_files TO enstore_reader;


--
-- Name: write_protection_audit; Type: ACL; Schema: public; Owner: enstore
--

REVOKE ALL ON TABLE write_protection_audit FROM PUBLIC;
REVOKE ALL ON TABLE write_protection_audit FROM enstore;
GRANT ALL ON TABLE write_protection_audit TO enstore;
GRANT SELECT ON TABLE write_protection_audit TO enstore_reader;


--
-- PostgreSQL database dump complete
--

INSERT into state_type (name) select 'system_inhibit_0' as name  where not exists (select state_type.name from state_type where state_type.name='system_inhibit_0');
INSERT into state_type (name) select 'system_inhibit_1' as name  where not exists (select state_type.name from state_type where state_type.name='system_inhibit_1');
INSERT into state_type (name) select 'user_inhibit_1'   as name  where not exists (select state_type.name from state_type where state_type.name='user_inhibit_0');
INSERT into state_type (name) select 'user_inhibit_1'   as name  where not exists (select state_type.name from state_type where state_type.name='user_inhibit_1');
INSERT into state_type (name) select 'write_protect'    as name  where not exists (select state_type.name from state_type where state_type.name='write_protect');
INSERT into state_type (name) select 'other'            as name  where not exists (select state_type.name from state_type where state_type.name='other');
INSERT into state_type (name) select 'modified'         as name  where not exists (select state_type.name from state_type where state_type.name='modified');
INSERT into state_type (name) select 'set_comment'      as name  where not exists (select state_type.name from state_type where state_type.name='set_comment');
INSERT into state_type (name) select 'new_library'      as name  where not exists (select state_type.name from state_type where state_type.name='new_library');

INSERT into media_capacity select '9840',        21474836480 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='9840'     and  media_capacity.capacity=21474836480);
INSERT into media_capacity select '9940',        64424509440 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='9940'     and  media_capacity.capacity=64424509440);
INSERT into media_capacity select '9940B',      214748364800 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='9940B'    and  media_capacity.capacity=214748364800);
INSERT into media_capacity select 'DECDLT',      21474836480 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='DECDLT'   and  media_capacity.capacity=21474836480);
INSERT into media_capacity select 'null',       214748364800 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='null'     and  media_capacity.capacity=214748364800);
INSERT into media_capacity select 'LTO2',       214748364800 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='LTO2'     and  media_capacity.capacity=214748364800);
INSERT into media_capacity select 'LTO3',       429496729600 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='LTO3'     and  media_capacity.capacity=429496729600);
INSERT into media_capacity select 'LTO4',       858993459200 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='LTO4'     and  media_capacity.capacity=858993459200);
INSERT into media_capacity select 'T10000T2',  5401000000000 where not exists (select media_capacity.type, media_capacity.capacity from media_capacity where media_capacity.type='T10000T2' and  media_capacity.capacity=5401000000000);

INSERT into cache_statuses select 'CREATED','file was written to cache' where not exists (select status, explanation from cache_statuses where status='CREATED' and explanation='file was written to cache');
INSERT into cache_statuses select 'PURGING','file is being purged' where not exists (select status, explanation from cache_statuses where status='PURGING' and explanation='file is being purged');
INSERT into cache_statuses select 'PURGED','file wad deleted in cache' where not exists (select status, explanation from cache_statuses where status='PURGED' and explanation='file was deleted in cache');
INSERT into cache_statuses select 'STAGING','file is being staged to cache from tape' where not exists (select status, explanation from cache_statuses where status='STAGING' and explanation='file is being staged to cache from tape');
INSERT into cache_statuses select 'CACHED','file is in cache' where not exists (select status, explanation from cache_statuses where status='CACHED' and explanation='file is in cache');
INSERT into cache_statuses select 'STAGING_REQUESTED','staging of file has been requested' where not exists (select status, explanation from cache_statuses where status='STAGING_REQUESTED' and explanation='staging of file has been requested');
INSERT into cache_statuses select 'PURGING_REQUESTED','purging of file has been requested' where not exists (select status, explanation from cache_statuses where status='PURGING_REQUESTED' and explanation='purging of file has been requested');
INSERT into cache_statuses select 'STAGED','file is in cache' where not exists (select status, explanation from cache_statuses where status='STAGED' and explanation='file is in cache');
INSERT into cache_statuses select 'FAILED','staging has failed' where not exists (select status, explanation from cache_statuses where status='FAILED' and explanation='staging has failed');

INSERT into archive_statuses select 'ARCHIVED','file was written to tape' where not exists (select status, explanation from archive_statuses where status='ARCHIVED' and explanation='file was written to tape');
INSERT into archive_statuses select 'ARCHIVING','file is being written to tape. This state is useful for the recovery from failure' where not exists (select status, explanation from archive_statuses where status='ARCHIVING' and explanation='file is being written to tape. This state is useful for the recovery from failure');
INSERT into archive_statuses select 'FAILED','archival has failed' where not exists (select status, explanation from archive_statuses where status='FAILED' and explanation='archival has failed');
INSERT into option select 'quota','disabled'  where not exists (select key, value from option where key='quota' and value='disabled');
