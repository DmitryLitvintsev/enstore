#! /bin/sh --posix

# $Id$

#Sourced from encp_test_script to run encp regression tests.
#
# Requires $ENSTORE_DIR/tools/encp_create_tests to work.
# Requires $LOCAL_DIR and $PNFS_DIR to be set.
#
# It creates directories test_files_for_${username} and
# encp_test_for_${username} in both $LOCAL_DIR AND $PNFS_DIR.

#These variables can be overridden from the encp_test_script command line.
encp_cmd=${encp_cmd:-`which encp`}
debug=${debug:-1}

#LOCAL_DIR is set by the user in their environment.
if [ ! -d "$LOCAL_DIR" ]; then
    echo "\$LOCAL_DIR not set.  Stopping test." 1>&2
    exit 1
fi
#PNFS_DIR is set by the user in their environment.
if [ ! -d "$PNFS_DIR" ]; then
    echo "\$PNFS_DIR not set.  Stopping test." 1>&2
    exit 1
fi

#Note: REMOTE_ENCP is an environmental variable that tells encp to use
# pnfs_agent instead of PNFS directly.  We check for the same variable here to
# handle running these tests through the pnfs agent too.

if [ -n "$REMOTE_ENCP" ]; then
    enstore pnfs_agent --timeout 10 --retries 3 --alive
    if [ $? -ne 0 ]; then
        echo 'pnfs_agent is not running and $REMOTE_ENCP is set.' \
             'Stopping test.' 1>&2
        exit 1
    fi
fi

username=`id -u -n`
hostname=`uname -n`

DEBUG_EXECUTIVE_SUMMARY=0
DEBUG_SUMMARY=1
DEBUG_DETAILED_SUMMARY=2
DEBUG_CLEANUP=3
DEBUG_ENCP_OUTPUT=4  #Lots of output.
DEBUG_CLEANUP_MORE=5  #Lots of output when the tests deadlock.

#############################################################################

find_command()
{
# $1 = The name of the command to find.
# Likely names are: enstore, get, put, volume_assert, ensync

    #Substitute in the name where encp is.  This preserves looking for
    # names like enstore_admin when encp_admin was listed on the command
    # line.
    this_cmd=`dirname $encp_cmd`/`basename $encp_cmd | sed "s/encp/$1/"`
    if [ -x "$this_cmd" ]; then
	export ${1}_cmd=$this_cmd
	return
    fi
    #Try again looking to see if there is a .py file instead.
    this_cmd=${this_cmd}.py
    if [ -x "$this_cmd" ]; then
        export ${1}_cmd=$this_cmd
        return
    fi
    #Simple replace the name this time.
    this_cmd=`dirname $encp_cmd`/$1
    if [ -x "$this_cmd" ]; then
	export ${1}_cmd=$this_cmd
	return
    fi
    #Try again looking to see if there is a .py file instead.
    this_cmd=${this_cmd}.py
    if [ -x "$this_cmd" ]; then
	export ${1}_cmd=$this_cmd
	return
    fi
}

#Either correct or append ENSTORE_CONFIG_[HOST|PORT] in the enstore.conf file.
correct_config_file()
{
    line_name=$1  #The string ENSTORE_CONFIG_HOST or ENSTORE_CONFIG_PORT.
    config_file_name=$2  #/tmp/enstore.conf

    #Get the value of the variable name stored in $line_name.
    value=$(eval echo \$$(echo $line_name))

    if [ -z "$value" ]; then
	grep ${line_name}= "$config_file_name" > /dev/null
	if [ $? -eq 0 ]; then
	    #The test copy of the enstore.conf file has this line already
	    # set and no environmental variable to override it was found.
	    return 0
	else
	    #The line was not in the enstore.conf config file already.
	    return 1
        fi
    fi

    #Make a temporary copy.
    tmp_config_file_name=${config_file_name}.tmp

    grep ${line_name}= "$config_file_name" > /dev/null
    if [ $? -eq 0 ]; then
	#We found an alrady present line; replace it.
	sed "s/$line_name=.*/$line_name=$value/" "$config_file_name" > "$tmp_config_file_name"
	if [ $? -ne 0 ]; then
            return 1
	fi
	mv $tmp_config_file_name $config_file_name
	if [ $? -ne 0 ]; then
            return 1
	fi
    else
	#No line found, add one at the end.
	env | grep $line_name >> "$config_file_name"
	if [ $? -ne 0 ]; then
            return 1
	fi
    fi

    return 0  #Success
}
#############################################################################

#Return true (zero) if the requested directory is a PNFS directory.
is_pnfs()
{
    if [ -n "$REMOTE_ENCP" ]; then
	enstore pnfs_agent --exists "$1"
    else
	#It would be simple if frozen versions of the enstore command
	# had the command
	#enstore sfs --database "$1"
	# Since they all don't we need to do this the hard way.
	cat "$1/.(tags)()" > /dev/null 2>&1
    fi
    return $?
}

#Make a non-PNFS or PNFS file.
make_file()
{
    is_pnfs `dirname "$1"`
    if [ $? -eq 0 ]; then
	make_pnfs_file "$1"
    else
	touch "$1"
    fi
    return $?
}

#Make a regular PNFS file.
make_pnfs_file()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --touch "$1"
        rc=$?
    else
        for lc in 1 2 3; do
	    #PNFS gives false ENOENT errors.  Retry them for a while.
            touch "$1" 2> /dev/null
            rc=$?
            if [ $rc -eq 0 ]; then
                break
            fi
            sleep 1
        done
        if [ $rc -ne 0 ]; then
	    # One last time to give the user the error.
            touch "$1"
            rc=$?
        fi
    fi
    return $rc
}

#Handle making files in PNFS through mountpoint or pnfs_agent.
make_pnfs_dir()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --mkdirs "$1"
    else
        mkdir -p "$1"
    fi
    return $?
}

#Handle removing a PNFS or non-PNFS file.
rm_file()
{
    is_pnfs `dirname "$1"`
    if [ $? -eq 0 ]; then
	rm_pnfs_file "$1"
    else
	rm -f "$1"
    fi
    return $?
}

#Handle removing a pnfs file.
rm_pnfs_file()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --remove "$1"
    else
        rm -f "$1"
    fi
    return $?
}

#Handle cleanup of files (both normal and in pnfs).
cleanup_files()
{
    #The list of files is called with '$cleanup' so we need to perform
    # the substitution here with eval.  $cleanup changes during the tests,
    # evaluting it here guarantees we have the latest list.
    for file in `eval echo $*`; do
        if [ "$file" = "/dev/null" ]; then
            continue
        fi

	#Automatically, remove lock files.
	if [ `basename "$file" | cut -c 1-6` = ".lock." ]; then
	    #Handle the case where the lock file is one of the target files.
	    # This will happen for tests that only read files from a volume.
	    lock_file=$file
	    file=
	else
	    lock_file=`get_lock_file_name "$file"`
	fi

	#First, the normal file.
	if [ -f "$file" -o -n "$REMOTE_ENCP" ]; then
	    if [ $debug -ge $DEBUG_CLEANUP ]; then
		echo "REMOVING FILE $file"
	    fi
	    rm_file "$file"
	fi

	#Next, the lock file.
	if [ -f "$lock_file" -o -n "$REMOTE_ENCP" ]; then
	    if [ $debug -ge $DEBUG_CLEANUP ]; then
		echo "REMOVING LOCK FILE $lock_file"
	    fi
	    rm_file "$lock_file"
	fi
    done
}

#Remove the files in the directories passed in.  Leave the directories.
cleanup_dir()
{
    for dir in `eval echo $*`; do
        if [ -d "$dir" ]; then
	    #TO DO:  Cleanup any non-regular files too.
	    cleanup_files `get_file_list "$dir"`
        fi
    done
}

#Return zero if the file exists, and one otherwise.
does_file_exist()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --exists "$1"
    else
        test -f "$1"
    fi
    return $?
}

#Return zero if the file is old, and one otherwise.
is_file_old()
{
    if [ -n "$REMOTE_ENCP" ]; then
	rc=1  #Say it is recent.  Might need to fix this sometime.
    else
	#We consider a file old after a day (-mtime +1).  Either another
	# test is hung while holding the lock file or another test
	# was killed and the locks not cleaned up.  Either way return
	# true (0) so we can move on.
	line_count=`find "$1" -mtime +1 2> /dev/null | wc -l`
	if [ $line_count -gt 0 ]; then
	    rc=0
	else
	    rc=1
	fi
    fi
    return $rc
}

get_lock_file_name()
{
    rc=0
    for pathname in "$@"; do
	if [ -n "$pathname" ]; then
	    dname=`dirname $pathname`
	    fname=`basename $pathname`
	    lock_file="$dname/.lock.$fname"
	    echo $lock_file
	    rc=`expr $rc + 0`
	else
	    rc=`expr $rc + 1`
	fi
    done
    return $rc
}

#############################################################################

setup_log_file()
{
    ENCP_OUTPUT=/tmp/encp_test_output_for_${username}
    output_lock_file=`get_lock_file_name $ENCP_OUTPUT`
    output_lock_file_temp=${output_lock_file}_tmp$$

    touch ${output_lock_file_temp} 2> /dev/null
    ln ${output_lock_file_temp} ${output_lock_file} 2> /dev/null
    rc=$?
    rm -f ${output_lock_file_temp}  #Cleanup.
    if [ $rc -eq 0 ]; then
        #We have the lock file.
	trap "all_done;" HUP INT QUIT ABRT ALRM TERM
	trap "all_done;" EXIT
    
        #We have the common name of the output file since only this copy of
        # the script is running.
	all_done()
	{
	    rc=$?
	    if [ -n "$1" ]; then
		rc=$1  #Force error condition.
	    fi
	    ending_message $rc
	    rm -f "${output_lock_file}"  
	    trap "" HUP INT QUIT ABRT ALRM TERM  #clear the trap
	    trap "" EXIT
	    exit $rc
	}
    else
        #Grab the current process id.  In a subshell, $$ and $PPID give the
        # same answer as the current shell, thus the need to get the parent of
        # a child process to get the correct value.
	MYPID=$(sh -c 'echo $PPID')
        #Another test script is running.  Use a different filename.
	ENCP_OUTPUT=${ENCP_OUTPUT}_${hostname}_$MYPID

        #We have a private version of the output file.
	all_done()
	{
	    rc=$?
	    if [ -n "$1" ]; then
		rc=$1
	    fi
	    ending_message $rc
	    exit $rc
	}
    fi
    if [ $debug -ge $DEBUG_CLEANUP ]; then
	echo ENCP_OUTPUT $ENCP_OUTPUT
    fi
    rm -f $ENCP_OUTPUT
    if [ $? -ne 0 ]; then
        #Use rm error message.
	all_done 1
    fi
    touch $ENCP_OUTPUT
    if [ $? -ne 0 ]; then
        #Use touch error message.
	all_done 1
    fi
}

truncate_encp_output()
{
    #If the user wants all the tests attempted, then keep all of the output
    # in the output file from all the tests.  If the user only picked a
    # few tests, then truncate the output file to keep the output to
    # be looked at smaller.
    if [ $truncate_output = yes ]; then
        > $ENCP_OUTPUT    #truncate output file
        #rm -f $ENCP_OUTPUT
        #touch $ENCP_OUTPUT
    fi
}

cleanup_encp_output()
{
    #Remove all existing encp regression test output.
    for file in `ls /tmp/encp_test_output_for_${username}* 2>/dev/null`; do
	if [ $debug -ge $DEBUG_CLEANUP ]; then
	    echo "Removing previous output file: $file"
        fi
	rm -f $file
    done
}

#############################################################################

#Print the start of the test.
print_test_name()
{
    test_name="STARTING $* TEST"

    if [ $debug -ge $DEBUG_SUMMARY ]; then
        echo $test_name | tee -a $ENCP_OUTPUT 2>&1
    else
        echo $test_name >> $ENCP_OUTPUT 2>&1
    fi
}

print_test_end()
{
# $1 = return value of the transfer function.
# $2 = expected exit status of the transfer function.

    use_rtn=$1
    use_expected_exit_status=$2

    if [ $use_rtn -ne $use_expected_exit_status ]; then
        if [ $debug -ge $DEBUG_SUMMARY ]; then
            echo "$message TEST FAILED WITH $use_rtn " \
                 "INSTEAD OF $use_expected_exit_status ON $direction"
        fi
        if [ $debug -ge $DEBUG_ENCP_OUTPUT ]; then
	    cat $ENCP_OUTPUT
        fi
	cleanup_files "$cleanup"
	all_done 1
    else
        if [ $debug -ge $DEBUG_SUMMARY ]; then
            echo "$message TEST SUCCEEDED WITH $use_rtn ON $direction"
        fi
	if [ $debug -ge $DEBUG_ENCP_OUTPUT ]; then
	    #Only output this if they really want it.
	    cat $ENCP_OUTPUT
	fi
    fi
}

#This function preserves the value of $? after it is called.  This is called
# all tests in a single pass within a single concurrent set of tests.
ending_message()
{
    rc=$?
    if [ -n "$1" ]; then
	rc="$1"
    fi
    if [ $debug -ge $DEBUG_EXECUTIVE_SUMMARY ]; then
        if [ $rc -ne 0 ]; then
            echo "See $ENCP_OUTPUT for full error."
        else
            echo "Only successes for $ENCP_OUTPUT found."
        fi
    fi
    return $rc
}

#############################################################################

has_scanfiles_command()
{
    help=`$enstore_cmd --help`

    echo "$help" | awk '{print $1}' | grep 'scanfiles' > /dev/null
    #If a match was found it has the command.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the command is not available.
    return 0
}

has_pnfs_agent_command()
{
    help=`$enstore_cmd --help`

    echo "$help" | awk '{print $1}' | grep 'pnfs_agent' > /dev/null
    #If a match was found it has the command.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the command is not available.
    return 0
}

has_mount_point_switch()
{
    if [ -n "$REMOTE_ENCP" ]; then
        #Current "enstore pnfs_agent --mount-point" is not defined.
	return 0
    else
	help=`$enstore_cmd sfs --help`
    fi

    echo "$help" | awk '{print $1}' | grep '\-\-mount-point' > /dev/null
    #If a match was found it has the command.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the command is not available.
    return 0
}

has_library_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-library' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

has_volume_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-volume' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

has_cache_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-get-cache' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

has_max_resubmits_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-max-resubmit' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

is_admin_encp()
{
    version=`$encp_cmd --help`

    #This check only works for as long as --storage-group remains an
    # administator only option.
    echo "$version" | awk '{print $1}' | grep '\-\-storage-group' > /dev/null

    #If a match was found it is an admin version.
    if [ $? -eq 0 ]; then
	return 1
    fi

    return 0
}

is_user_encp()
{
    version=`$encp_cmd --help`

    #This check only works for as long as --get-cache remains an
    # dcache encp and above option.
    echo "$version" | awk '{print $1}' | grep '\-\-get-cache' > /dev/null

    #If a match was not found it is an user version.
    if [ $? -ne 0 ]; then
	return 1
    fi

    return 0
}

#The dcache version of encp (for pool nodes) is at times also called
# the user2 version of encp.
is_user2_encp()
{
    version=`$encp_cmd --help`

    #This check only works for as long as --get-cache remains an
    # dcache encp and above option.
    echo "$version" | awk '{print $1}' | grep '\-\-get-cache' > /dev/null

    #If a match was found it might be a dcache version.
    if [ $? -eq 0 ]; then
	echo "$version" | awk '{print $1}' | grep '\-\-storage-group' > /dev/null

        #If a match was not found it is a dcache version.
	if [ $? -ne 0 ]; then
	    return 1
	fi
    fi

    return 0
}

#############################################################################

setup_test_paths()
{
    #Include the username so multiple users' can run their own regression tests
    # on the same node at the same time.
    LOCAL_INPUT_DIR=$LOCAL_DIR/test_files_for_${username}
    LOCAL_OUTPUT_DIR=$LOCAL_DIR/encp_test_for_${username}
    PNFS_INPUT_DIR=$PNFS_DIR/test_files_for_${username}
    PNFS_OUTPUT_DIR=$PNFS_DIR/encp_test_for_${username}
    PNFS_AGENT_OUTPUT_DIR=$PNFS_OUTPUT_DIR
    
    ENSYNC_INPUT_DIR=$LOCAL_INPUT_DIR/ensync_test
    ENSYNC_OUTPUT_DIR=$PNFS_OUTPUT_DIR/ensync_test

    mkdir -p $LOCAL_OUTPUT_DIR
    mkdir -p $ENSYNC_INPUT_DIR
    make_pnfs_dir $PNFS_INPUT_DIR
    make_pnfs_dir $PNFS_OUTPUT_DIR
    make_pnfs_dir $ENSYNC_OUTPUT_DIR

    #Make sure we have correct permissions for these directories.
    for dir_to_check in "$LOCAL_INPUT_DIR" "$LOCAL_OUTPUT_DIR" \
	"$PNFS_INPUT_DIR" "$PNFS_OUTPUT_DIR" "$PNFS_OUTPUT_DIR"; do
        if [ ! -x "$dir_to_check" ]; then
	    echo "No execute permissions for directory: $dir_to_check" 1>&2
	    all_done 1
	fi
	if [ ! -r "$dir_to_check" ]; then
	    echo "No read permissions for directory: $dir_to_check" 1>&2
	    all_done 1
	fi
	if [ ! -w "$dir_to_check" ]; then
	    echo "No write permissions for directory: $dir_to_check" 1>&2
	    all_done 1
	fi
    done
}

#Find and cleanup leftover files from previous abnormally terminated tests.
cleanup_test_paths()
{
    #Cleanup failed output files in test PNFS directory.
    if [ -n "$REMOTE_ENCP" ]; then
	filelist=`enstore pnfs_agent --just-files --list-dir "$PNFS_OUTPUT_DIR"`
    else
        filelist=`find "$PNFS_OUTPUT_DIR" -maxdepth 1 -type f 2> /dev/null`
    fi
    echo "$filelist" |
    while read line; do
        if [ $debug -ge $DEBUG_CLEANUP ]; then
	    echo "Removing previous test file: $line"
        fi
	rm_pnfs_file "$line"  #Use function for pnfs_agent cases.
    done

    #Cleanup failed output files in local test directory.
    filelist=`find "$LOCAL_OUTPUT_DIR" -maxdepth 1 -type f 2> /dev/null`
    echo "$filelist" |
    while read line; do
        if [ $debug -ge $DEBUG_CLEANUP ]; then
	    echo "Removing previous test file: $line"
        fi
	rm -f "$line"
    done

    #Cleanup the local .lock. files still lying around.
    filelist=$(find "$LOCAL_INPUT_DIR" -maxdepth 1 -type f -name '.lock.*' 2> /dev/null)
    echo "$filelist" |
    while read line; do
        if [ $debug -ge $DEBUG_CLEANUP ]; then
	    echo "Removing lock file: $line"
        fi
	rm -f "$line"
    done

    #Cleanup the PNFS/Chimera .lock. files still lying around.
    if [ -n "$REMOTE_ENCP" ]; then
	filelist=$(enstore pnfs_agent --just-files --list-dir "$PNFS_INPUT_DIR" | grep .lock.)
    else
        filelist=$(find "$PNFS_INPUT_DIR" -maxdepth 1 -type f -name '.lock.*' 2> /dev/null)
    fi
    echo "$filelist" |
    while read line; do
        if [ $debug -ge $DEBUG_CLEANUP ]; then
	    echo "Removing lock file: $line"
        fi
	rm_pnfs_file "$line"  #Use function for pnfs_agent cases.
    done
}

#Use encp to copy any local test files into the PNFS directory where these
# test files should be copied to for the read-only tests to work.
copy_test_files()
{
    #Copy local test files into PNFS/Chimera.
    for fname in `ls $LOCAL_INPUT_DIR`; do
        #Handle using mounted pnfs filesystem or using pnfs agent.
	if [ -n "$REMOTE_ENCP" ]; then
	    enstore pnfs_agent --exists $PNFS_INPUT_DIR/$fname
	    pnfs_test=$?
	else
	    test -f $PNFS_INPUT_DIR/$fname
	    pnfs_test=$?
	fi
	if [ -f $LOCAL_INPUT_DIR/$fname -a $pnfs_test -ne 0 ]; then
	    #We set the file family to volume_read_test for the benifit of the
	    # volume read test.
	    echo encp --file-family volume_read_test $LOCAL_INPUT_DIR/$fname $PNFS_INPUT_DIR/$fname
	    encp --file-family volume_read_test $LOCAL_INPUT_DIR/$fname $PNFS_INPUT_DIR/$fname
	fi
    done
}

#############################################################################

get_file_list()
{
#$1 = directory of file to choose from

    #Restrict this to files less than 100MB in size and non-hidden files.
    # Only consider files in this directory first; go recurisive if the
    # first list is empty.
    if [ -d $1 ]; then
        filenames=`find $1 -maxdepth 1 -size -104857600c -type f 2> /dev/null`
        if [ -z "$filenames" ]; then
	    filenames=`find $1 -size -104857600c -type f ! -name ".*" 2> /dev/null`
        fi
    elif [ -n "$REMOTE_ENCP" -a `is_pnfs $1"` ]; then
        filenames=`enstore pnfs_agent --just-files --list-dir "$1"`
    fi

    echo "$filenames"
}

get_pnfs_file_list()
{
#$1 = directory of file to choose from

    #Restrict this to files less than 100MB in size and non-hidden files.
    # Only consider files in this directory first; go recurisive if the
    # first list is empty.
    if [ -n "$REMOTE_ENCP" ]; then
	filenames=`enstore pnfs_agent --just-files --list-dir $1`
    else
        filenames=`find $1 -maxdepth 1 -size -104857600c -type f ! -name ".*" 2> /dev/null`
	if [ -z "$filenames" ]; then
	    filenames=`find $1 -size -104857600c -type f ! -name ".*" 2> /dev/null`
	fi
    fi

    echo "$filenames"
}

get_volume_from_filename()
{
#$1 = pnfs filename to get the volume
    filename=$1
    
    
    if [ -n "$REMOTE_ENCP" ]; then
	#Rip just the volume out of the layer 4.
	volume=`enstore pnfs_agent --layer 4 $filename | sed -n '1p'`
    else
        #Determine the layer 4 filename.
	layer4_filename=`dirname $filename; echo "/.(use)(4)("; basename $filename; echo ")"`
	layer4_filename=`echo $layer4_filename | tr -d " "`
	
        #Rip just the volume out of the layer 4.
	volume=`cat $layer4_filename | sed -n '1p'`
    fi

    echo $volume
}


#Make sure any debuging echos do not go to standard out.  This function returns
# volume labels that way any random output will give errors.
#
#It is possible that this function returns less than the requested number
# of volume labels depending on availability.
pick_random_volumes()
{
    number=$1  #First argument is number of volumes. Rest of arguments are volumes.
    shift
    rnd=`expr $RANDOM + 1`
    #Between 9 and number of volumes, pick the lesser.
    if [ 9 -lt $# ]; then
	i=9
    else
	i=$#
    fi
    rand=`expr $rnd % $i`
    rand=`expr $rand + 1`
    i=1
    while [ $i -le $number ]; do
        eval echo \$$rand
	shift
	i=`expr $i + 1`
    done
}


#Make sure any debuging echos do not go to standard out.  This function returns
# filenames that way any random output will give errors.
#
#It is possible that this function returns less than the requested number
# of files when multiple test are running at once to avoid deadlocks.
pick_random_files()
{
    number=$1  #First argument is number of files. Rest of arguments are files.
    shift

    if [ $# -eq 0 ]; then
	echo "No files available for selection." 1>&2
	return 0
    fi

    rnd=`expr $RANDOM + 1`
    rand=`expr $rnd % $#`
    rand=`expr $rand + 1`
    current=$rand  #Seed the current position with the random number.
    i=0  #Number of files choosen for locking.

    #This outer loop is to make sure that as long as one file is locked when
    # more than one file needs to be picked, that we can return the shorter
    # list.  If we haven't gotten at least one file already then we keep
    # looping.
    while [ $i -eq 0 ]; do
      loop_count=0  #Number of passes over the list of files.
      while [ $i -lt $number -a $loop_count -lt 3 ]; do

	if [ $current -eq 0 ]; then
	    #Skip the executable in $0.
            loop_count=`expr $loop_count + 1`
	    current=1
	    sleep 1 #Give other encps a chance.
	fi

	filename=$(eval echo \$\{"${current}"\})
	dname=`dirname $filename`
	fname=`basename $filename`
	if [ `echo "$fname" | cut -c 1` = "." ]; then
	    #We found a hidden file.  Skip it.
	    current=`echo \( $current + 1 \) % $# | bc`
	    continue
	fi
	lock_file="$dname/.lock.$fname"
	lock_file_temp="$dname/.lock.temp$$.$fname"
	make_file "$lock_file_temp"  1>&2 #touch $lock_file_temp
	
	#Determine if the file exists.
	ln "$lock_file_temp" "$lock_file" 2> /dev/null
	rc=$?
	rm -f "$lock_file_temp"  #Cleanup.
	if [ $rc -eq 0 ]; then
	    #The lock file does not exist.
	    current=`echo \( $current + 1 \) % $# | bc`
	    i=`expr $i + 1`  #Up to number of files found.
	    echo "$filename"
	    if [ $debug -ge $DEBUG_CLEANUP ]; then
		echo "MAKING LOCK FILE $lock_file" 1>&2
	    fi
	    make_file "$lock_file"   #touch $lock_file_temp
	else
	    #Determine if the file is new and should be skipped.  Or old
	    # and should be removed.
	    is_file_old "$lock_file"
	    if [ $? -eq 0 ]; then
		if [ $debug -ge $DEBUG_CLEANUP ]; then
		    echo "Found old lock file.  Removing.  $lock_file" 1>&2
		fi
		rm -f "lock_file"
		current=`echo \( $current + 1 \) % $# | bc`
		i=`expr $i + 1`  #Up to number of files found.
		echo "$filename"
	    else
		#This test file is in use, get another one.
                if [ $debug -ge $DEBUG_CLEANUP_MORE ]; then
		    echo "Found recent lock file.  Skipping.  $lock_file" 1>&2
                fi
		current=`echo \( $current + 1 \) % $# | bc`
		sleep 1  #Give other encps a moment to complete.
	    fi
	fi
      done
    done
    return $i
}

#First argument is the directory to place before every other argument.
absfile()
{
    dir=$1
    shift
    for s in $*
    do
	s=`basename $s`
	abs_filenames=`echo $abs_filenames; echo $dir/$s`
    done

    echo $abs_filenames
}

#############################################################################

#transfer file
transfer()
{
    encp_command=`eval echo $1`
    infile=`eval echo $2`
    outfile=`eval echo $3`
    cleanup=`eval echo $4`
    options=`eval echo $5`
    message=`eval echo $6`
    direction=`eval echo $7`
    if [ -z "$8" ]; then  #This allows us to check for failures too.
        expected_exit_status=0
    else
        expected_exit_status=`eval echo $8`
    fi

    #
    #Send this debugging output to the file, or the file and terminal.
    #

    header_info=$( echo "ENCP: $encp_command"
        echo INPUT: $infile
        echo OUTPUT: $outfile
        echo INCLEANUP: $cleanup
        echo OPTIONS: $options
        echo MESSAGE: $message
        echo DIRECTION: $direction
        echo EXPECTED_EXIT_STATUS: $expected_exit_status
        #Output the type of encp that we are running.
	is_admin_encp
	if [ $? -eq 1 ]; then
            echo TYPE: "admin encp version"
        else
	    is_user2_encp
	    if [ $? -eq 1 ]; then
                echo TYPE: "dcache encp version"
            else
	        is_user_encp
	        if [ $? -eq 1 ]; then
                    echo TYPE: "user encp version"
                else
                    echo TYPE: "<unknown>"
                fi
           fi
        fi
        echo CWD: `uname -n`:`pwd`
	)
    #Note: print_test_name() output logged from print_test_name().
    if [ $debug -ge $DEBUG_DETAILED_SUMMARY ]; then
	echo "$header_info" | tee -a $ENCP_OUTPUT 2>&1
        #Only include the command line header if -d was specified.  We
        # still include the command being tested with just one -d.
        echo -n COMMAND: "" | tee -a $ENCP_OUTPUT 2>&1
    else
	echo "$header_info" >> $ENCP_OUTPUT 2>&1
	echo -n COMMAND: "" >> $ENCP_OUTPUT 2>&1
    fi

    more_header_info=$(
	#Output the command line that will be executed.
	echo "$encp_command $verbose $options $infile $outfile >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT"
	)
    if [ $debug -ge $DEBUG_DETAILED_SUMMARY ]; then
	echo "$more_header_info" | tee -a $ENCP_OUTPUT 2>&1
    else
        echo "$more_header_info" >> $ENCP_OUTPUT 2>&1
    fi

    #
    # Run the command.
    #
    eval $encp_command $verbose $options $infile $outfile >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT

    #
    # Did it work correctly?  (This calls exit on error.)
    #
    rtn=$?
    print_test_end $rtn $expected_exit_status
}

#############################################################################

#Test if the original input and the final output files are the same.
###
### This does does not work with pnfs_agent.
###
test_diff()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`

    i=1
    count=`echo $infiles | wc -w`
    while [ $i -le $count ]; do
	ifile=`echo $infiles | cut -d" " -f$i`
	ofile=`echo $outfiles | cut -d" " -f$i`
	i=`expr $i + 1`

	diff_output=`diff --brief $ifile $ofile 2>&1`

	rtn=$?
	if [ "$rtn" -gt 0 ]; then
	    #The files are not the same.  This might be correct if we used
	    # a null mover.

	    o_ls_size=`ls -l "$ofile" | awk '{print $5}'`
	    i_ls_size=`ls -l "$ifile" | awk '{print $5}'`
	    if [ $i_ls_size -eq $o_ls_size ]; then
		non_null_word_count=`cat "$ofile" | tr -d "\000" | wc -c`
		if [ $non_null_word_count -eq 0 ]; then
		    #We have a NULL file.  Let's assume this is from a
		    # null mover.
		    return 0
		fi
	    fi

	    echo $message "TEST FAILED ON DIFF"
	    echo "$diff_output"
	    cat $ENCP_OUTPUT
	    cleanup_files '$cleanupfiles'
	    all_done 1
	fi
    done
}

#Test that the layer info is correct.
test_layer()
{
    pnfsfiles=`eval echo $1`
    message=`eval echo $2`
    
    for file in $pnfsfiles; do
	if [ -n "$REMOTE_ENCP" ]; then
            enstore pnfs_agent --layer 1 $file > /dev/null
        else
	    enstore sfs --layer $file 1 > /dev/null
	fi
	if [ $? -ne 0 ]; then
	    echo $message "TEST FAILED ON LAYER"
	    echo No bfid value: $result: $file
	    all_done 1
	fi
	if [ -n "$REMOTE_ENCP" ]; then
	    result=`enstore pnfs_agent --layer 4 $file`
	else
	    result=`enstore sfs --layer $file 4`
	fi
	for line in result; do
	    if [ $line = "unknown" ]; then
		echo $message "TEST FAILED ON LAYER"
		echo Layer 4 contains unknown value: $file
		echo $result
		all_done 1
	    fi
	done
    done
}

#Test that the permissions are the same.
###
### This does does not work with pnfs_agent.
###
permissions_test()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`

    i=1
    count=`echo $infiles | wc -w`
    while [ $i -le $count ]; do
	ifile=`echo $infiles | cut -d" " -f$i`
	ofile=`echo $outfiles | cut -d" " -f$i`
	i=`expr $i + 1`

	result1=`ls -l $ifile | cut -c1-10`
	result2=`ls -l $ofile | cut -c1-10`
	
	if [ $result1 != $result2 ]; then
	    echo $message "TEST FAILED ON PERMISSIONS"
	    echo $result1 != $result2
	    rm -f $cleanupfiles
	    all_sone 1
	fi
    done
}

#Test that the sizes are the same.
###
### This does does not work with pnfs_agent.
###
size_test()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`

    i=1
    count=`echo $infiles | wc -w`
    while [ $i -le $count ]; do
	ifile=`echo $infiles | cut -d" " -f$i`
	ofile=`echo $outfiles | cut -d" " -f$i`
	i=`expr $i + 1`

	result1=`ls -l $ifile | sed 's/ \{1,30\}/ /g' | cut -f 5 "-d "`
	result2=`ls -l $ofile | sed 's/ \{1,30\}/ /g' | cut -f 5 "-d "`
	if [ $result1 != $result2 ]; then
	    echo $message "TEST FAILED ON SIZE"
	    echo $result1 != $result2
	    rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	    all_done 1
	fi
    done
}

#Test that the data access layer is correct.
data_access_layer_test()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`
    volume1=`get_volume_from_filename "$infiles" 2> /dev/null`
    volume2=`get_volume_from_filename "$outfiles" 2> /dev/null`
    volume=`echo $volume1 $volume2`

    #If the INFILE data access output line does not specify the filename,
    # exit with error.
    grep INFILE "$ENCP_OUTPUT" | grep "$infiles" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON INFILE"
	grep INFILE "$ENCP_OUTPUT"
	echo Expected: "$infiles"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi

    #If the OUTFILE data access output line does not specify the filename,
    # exit with error.
    grep OUTFILE "$ENCP_OUTPUT" | grep "$outfiles" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON OUTFILE"
	grep OUTFILE "$ENCP_OUTPUT"
	echo Expected: "$outfiles"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi

    #If the VOLUME data access output line does not specify the volume,
    # exit with error.
    grep LABEL "$ENCP_OUTPUT" | grep "$volume" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON VOLUME"
	grep LABEL "$ENCP_OUTPUT"
	echo Expected: "$volume"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi

    #If the LOCATION data access output line does not specify the position,
    # exit with error.
    lc=`grep LOCATION "$ENCP_OUTPUT" | tail -n 1 | sed 's/LOCATION=//' | wc -m`
    if [ $lc -eq 0 ]; then
	echo $message "TEST FAILED ON LOCATION"
	grep LOCATION "$ENCP_OUTPUT"
	echo Expected: non-empty string
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi
}

enstore_check_test()
{
    pnfsfiles=`eval echo $1`
    cleanupfiles=`eval echo $2`
    message=`eval echo $3`

    en_check "$pnfsfiles"
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON ENSTORE CHECK"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi
}

#Run the enstore scan test on a list of files.
scan_test()
{
    has_scanfiles_command
    if [ $? -eq 0 ]; then
        # skip the test since "enstore scan" is not available.
        if [ $debug -ge $DEBUG_DETAILED_SUMMARY ]; then
           echo "'enstore scan' test is not available.  Continueing." 2>&1
        fi
	return
    fi

    pnfsfiles=`eval echo $1`
    message=`eval echo $2`

    results=0
echo "$pnfsfiles" > /dev/tty
    for scan_filename in `echo "$pnfsfiles"`; do
echo "$enstore_cmd scan $scan_filename | grep ' ... OK'" > /dev/tty
        scan_output=${scan_output}`$enstore_cmd scan $scan_filename | grep ' ... OK'`
        results=$((results + $?))
    done
    if [ $results -ne 0 ]; then
        echo $message "TEST FAILED ON SCAN CHECK"
	echo "$scan_output"
        all_done $results
    fi
}

##############################################################################
# The functions defined here are helper functions for running the tests.
##############################################################################

__read_test()
{
# $1 = read command; encp or get
# $2 = number of files to transfer
# $3 = test specific options
# $4 = expected test exit status

    print_test_name $section

    read_cmd=${1:-encp}  #Default to encp.
    number_of_files=${2:-1} #Default of 1.
    use_options=$3
    test_expected_exit_status=${4:-0} #Default of success.

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
	return
    fi
    #Specify file paths.
    filename=`pick_random_files $number_of_files $filelist`
    outname=/dev/null
    cleanup="$outname `get_lock_file_name $filename`"

    transfer "$read_cmd" '$filename' '$outname' '$cleanup' "$use_options" "$section" READ $test_expected_exit_status

    cleanup_files '$cleanup'
}

__write_test()
{
# $1 = write command; encp or put
# $2 = number of files to transfer
# $3 = test specific options
# $4 = expected test exit status

    print_test_name $section

    read_cmd=${1:-encp}  #Default to encp.
    number_of_files=${2:-1} #Default of 1.
    use_options=$3
    test_expected_exit_status=${4:-0} #Default of success.

    #Snag a random file.
    filelist=`get_pnfs_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
	return
    fi
    #Specify file paths.
    filename=`pick_random_files $number_of_files $filelist`
    basename=`basename $filename`
    pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"

    transfer "$read_cmd" '$filename' '$pnfsname' '$cleanup' "$use_options" "$section" WRITE $test_expected_exit_status

    if [ $test_expected_exit_status -eq 0 ]; then
	scan_test '$pnfsname' "$section"
    fi

    cleanup_files '$cleanup'
}

__read_write_test()
{
# $1 = read command; encp or get
# $2 = write command; encp or put
# $3 = number of files to transfer
# $4 = test specific options
# $5 = expected test exit status

    print_test_name $section

    read_cmd=${1:-encp}  #Default to encp.
    write_cmd=${2:-encp}  #Dfault to encp.
    number_of_files=${3:-1} #Default of 1.
    use_options=$4
    test_expected_exit_status=${5:-0} #Default of success.

    #Snag random files.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
	return
    fi
    filenames=`pick_random_files $number_of_files $filelist`
    pnfsnames=`absfile $PNFS_OUTPUT_DIR $filenames`
    cleanup="$pnfsnames `get_lock_file_name $filenames`"

    transfer $write_cmd '$filenames' '$PNFS_OUTPUT_DIR' '$cleanup' "$use_options" "$section" WRITE $test_expected_exit_status

    test_layer '$pnfsnames' "$section"
    scan_test '$pnfsnames' "$section"
    
    #Add the second direction.
    outnames=`absfile $LOCAL_OUTPUT_DIR $filenames`
    cleanup="$cleanup $outnames"

    transfer $read_cmd '$pnfsnames' '$LOCAL_OUTPUT_DIR' '$cleanup' "$use_options" "$section" READ

    test_diff '$filenames' '$outnames' '$cleanup' "$section"
    permissions_test '$filenames' '$outnames' '$cleanup' "$section"
    size_test '$filenames' '$outnames' '$cleanup' "$section"

    cleanup_files '$cleanup'
}

#Helper function for all of the dcache tests.
__dcache_read_write_test()
{
    print_test_name $section

    #Test the version of encp.
    has_cache_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --get-cache switch.  Skipping test and continuing." 1>&2
	return
    fi

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
	return
    fi
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`absfile $PNFS_OUTPUT_DIR $basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"

    #Create the output file, set the size and get the pnfs id.
    size=`ls -l $filename | sed 's/ \{1,30\}/ /g' | cut -f 5 "-d "`
    if [ -n "$REMOTE_ENCP" ]; then
	enstore pnfs_agent --touch $pnfsname
	enstore pnfs_agent --size "${pnfsname}" "${size}"
	pnfsid=`enstore pnfs_agent --id $pnfsname`
    else
        touch $pnfsname
	enstore sfs --size "${pnfsname}" "${size}"
	pnfsid=`enstore sfs --id $pnfsname`
    fi

    #Shorten some things for readability.
    options=`eval echo "$@"`
    put_id="--put-cache $pnfsid"
    get_id="--get-cache $pnfsid"

    #Do the write transfer and test for correctness.
    transfer $encp_cmd '$put_id' '$filename' '$cleanup' '$options' "$section" WRITE
    
    test_layer '$pnfsname' "$section"
    scan_test '$pnfsname' "$section"

    #Add the second direction.
    outname=`absfile $LOCAL_OUTPUT_DIR $basename`
    cleanup="$cleanup $outname"

    #Do the read transfer and test for correctness.
    transfer $encp_cmd '$get_id' '$outname' '$cleanup' '$options' "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    #Test the version of encp.
    is_admin_encp
    if [ $? -ne 0 ]; then
	#Only the admin version of encp has the --bfid switch.
        rm -f $outname

        #Do the read transfer and test by BFID instead of PNFSID.
	bfid=`enstore sfs --bfid $pnfsname`
        get_bfid="--get-bfid $bfid"
        transfer $encp_cmd '$get_bfid' '$outname' '$cleanup' '$options' "$section" READ

        test_diff '$filename' '$outname' '$cleanup' "$section"
        permissions_test '$filename' '$outname' '$cleanup' "$section"
        size_test '$filename' '$outname' '$cleanup' "$section"
     fi
     
     cleanup_files '$cleanup'
}

__volume_read_test()
{
# $1 = encp/get command to use

    section="VOLUME READ"
    print_test_name $section

    #Test the version of encp.
    has_volume_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --volume switch.  Skipping test and continuing." 1>&2
        return
    fi 

    encp="$1"

    #Snag a volume_read_test volume.
    volumes=`enstore info --query "select label from volume where file_family = 'volume_read_test' and label not like '%.deleted' ;" | sed '1,2d'`
    if [ -z "$volumes" ]; then
	echo "No suitable volumes found.  Skipping test and continuing." 1>&2
    else
	#Pick a random volume.
	volume=`pick_random_volumes 1 $volumes`

	outname=/dev/null

	transfer "$encp" '' '$outname' "" "--skip-deleted-files --volume $volume" "$section" READ
    fi
}

##############################################################################
# The functions defined here to the end of the file execute the actuall tests.
#
# First are the encp tests.
#
##############################################################################

single_read_test()
{
    section="SINGLE READ"
    #Run the basic read test.
    __read_test "$encp_cmd" 1 ""
}

single_read_write_test()
{
    section="SINGLE READ AND WRITE"
    #Use encp for read and write tests.  Copy 1 file.  No options.
    __read_write_test "$encp_cmd" "$encp_cmd" 1 ""
}

multiple_read_write_test()
{
    section="MULITPLE READ AND WRITE"
    # Use encp for read and write tests.
    __read_write_test "$encp_cmd" "$encp_cmd" 3
}

dcache_read_write_test()
{
    section="DCACHE READ AND WRITE"

    has_mount_point_switch
    if [ $? -eq 0 ]; then
	print_test_name $section
        echo "The 'enstore [sfs|pnfs_agent] --mount-point' command is not available.  Skipping test and continuing." 1>&2
	return
    fi

    pnfs_mount_point=`enstore sfs --mount-point $PNFS_DIR`

    #Otherwise run the test.
    __dcache_read_write_test '--pnfs-mount "$pnfs_mount_point"'
}

dcache_shortcut_read_write_test()
{
    section="DCACHE SHORTCUT READ AND WRITE"

    has_mount_point_switch
    if [ $? -eq 0 ]; then
	print_test_name $section
        echo "The 'enstore [sfs|pnfs_agent] --mount-point' command is not available.  Skipping test and continuing." 1>&2
	return
    fi

    pnfs_mount_point=`enstore sfs --mount-point $PNFS_DIR`

    #Otherwise run the test.
    __dcache_read_write_test '--shortcut --pnfs-mount "$pnfs_mount_point"'
}

dcache_override_path_read_write_test()
{
    section="DCACHE OVERRIDE PATH READ AND WRITE"
    #Use single quotes so that we can expand $pnfsname after we know it.
    __dcache_read_write_test '--shortcut --override-path "$pnfsname"'
}

dcache_dirpath_read_write_test()
{
    section="DCACHE DIRNAME READ AND WRITE"
    #Use single quotes so that we can expand $PNFS_DIR after we know it.
    __dcache_read_write_test '--pnfs-mount "$PNFS_DIR"'
}

dcache_dirpath_shortcut_read_write_test()
{
    section="DCACHE DIRNAME SHORTCUT READ AND WRITE"
    #Use single quotes so that we can expand $PNFS_DIR after we know it.
    __dcache_read_write_test '--shortcut --pnfs-mount "$PNFS_DIR"'
}

enstore_conf_read_write_test()
{
    section="ENSTORE.CONF READ AND WRITE"

    #Once the first test sets the contents of this file, any additional tests
    # should just use it.
    temp_config_file=/tmp/enstore.conf

    if [ ! -f "$temp_config_file" ]; then
        #Hack up the temporary enstore.conf file.
        if [ -f "$ENSTORE_CONF" ]; then
            #If we already have a valid $ENSTORE_CONF file, use it.
            cp "$ENSTORE_CONF" "$temp_config_file"	
        elif [ -f "/etc/enstore.conf" ]; then
            cp /etc/enstore.conf "$temp_config_file"
        else
            env | grep ENSTORE_CONFIG_HOST > "$temp_config_file"
            env | grep ENSTORE_CONFIG_PORT >> "$temp_config_file"
        fi
    fi

    #It is possible that the user has modified the environmental variables
    # from what is in the normal enstore.conf file.  Correct the temp copy.
    correct_config_file ENSTORE_CONFIG_HOST "$temp_config_file" && \
    correct_config_file ENSTORE_CONFIG_PORT "$temp_config_file"
    if [ $? -ne 0 ]; then
	print_test_name $section
	echo "Failed to set $temp_config_file.  Skipping test and continuing." 1>&2
	return
    fi

    #Override environment for this test.
    use_encp="env ENSTORE_CONFIG_HOST= ENSTORE_CONFIG_PORT= ENSTORE_CONF=$temp_config_file $encp_cmd"

    __read_write_test '$use_encp' '$use_encp' 1 ""
}	

single_threaded_read_write_test()
{
    section="SINGLE THREADED READ AND WRITE"
    #Transfer 1 file in threaded mode.
    __read_write_test "$encp_cmd" "$encp_cmd" 3 "--threaded"
}

multiple_threaded_read_write_test()
{
    section="MULITPLE THREADED READ AND WRITE"
    #Transfer 3 files in threaded mode.
    __read_write_test "$encp_cmd" "$encp_cmd" 3 "--threaded"
}

single_ecrc_read_write_test()
{
    section="SINGLE ECRC READ AND WRITE"
    #Transfer 1 file in threaded mode.
    __read_write_test "$encp_cmd" "$encp_cmd" 1 "--ecrc"
}

single_relative_path_read_write_test()
{
    section="SINGLE RELATIVE PATH READ AND WRITE"
    print_test_name $section

    if [ -n "$REMOTE_ENCP" ]; then
	echo "Detected using pnfs_agent.  Skipping test and continuing." 1>&2
    else
	cwd=`pwd`

        #Snag a random file.
	filelist=`get_file_list "$LOCAL_INPUT_DIR"`
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo $basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"

	cd ${PNFS_OUTPUT_DIR}/

	transfer $encp_cmd '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE
	
	test_layer '$pnfsname' "$section"
	scan_test '$pnfsname' "$section"
	
        #Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer $encp_cmd '$pnfsname' '$outname' '$cleanup' "" "$section" READ

	test_diff '$filename' '$outname' '$cleanup' "$section"
	permissions_test '$filename' '$outname' '$cleanup' "$section"
	size_test '$filename' '$outname' '$cleanup' "$section"
	
	cleanup_files '$cleanup'
	
	cd $cwd
    fi
}

single_local_pnfs_path_read_test()
{
    section="SINGLE LOCAL PNFS PATH READ"
    print_test_name $section

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	#Insert the directory name "pnfs" into the local path.
	outdir=$LOCAL_OUTPUT_DIR/pnfs/
	outname=${outdir}/${basename}
	cleanup="$outname `get_lock_file_name $filename`"

	#If this does not exist, create it.
	mkdir -p $outdir
	
	transfer $encp_cmd '$filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

single_no_brand_read_test()
{
    section="SINGLE NO BRAND READ"
    print_test_name $section

    #Snag the specific test file.
    filelist="$PNFS_INPUT_DIR/special_files/no_brand"
    if [ -z "$filelist" -o ! -f "$filelist" ]; then
	echo "Input file not found.  Skipping test and continuing." 1>&2
    elif [ `enstore sfs --bfid $filelist | tr -d '[0-9]\n' | wc -c` -gt 0 ]; then
	#We should only get here if the bfid contains more than just
	# digits (and a newline).
	echo "$filelist bfid contains brand.  Skipping test and continuing." 1>&2
    else
	filename=`pick_random_files 1 $filelist`
	if [ -z "$filename" ]; then
	    echo "Input file not available.  Skipping test and continuing." 1>&2
	    return
	fi
	outname=/dev/null
	cleanup="$outname `get_lock_file_name $filename`"

	transfer $encp_cmd '$filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

volume_read_test()
{
    section="VOLUME READ"
    #Use single quotes so that we can expand $PNFS_DIR after we know it.
    __volume_read_test "$encp_cmd"
}

single_fs_path_read_test()
{
    section="SINGLE FS PATH READ"
    print_test_name $section

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
    else
	filename=`pick_random_files 1 $filelist`
	#Turn this path into the dcache prefered /pnfs/fs/usr/... path.
	# Encp should be able to determine the /pnfs/... path.
	encp_filename=`echo $filename | cut -c1-6`fs/usr`echo $filename | cut -c6-`
	outname=/dev/null
	cleanup="$outname `get_lock_file_name $filename`"

	transfer $encp_cmd '$encp_filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

data_access_layer_read_write_test()
{
    section="DATA ACCESS LAYER READ WRITE"
    print_test_name $section

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"
    encp="$encp_cmd --data-access-layer"

    transfer '$encp' '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsname' "$section"
    data_access_layer_test '$filename' '$pnfsname' '$cleanup' "$section"
    scan_test '$pnfsname' "$section"
    
    #Add the second direction.
    outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
    cleanup="$cleanup $outname"

    transfer '$encp' '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    data_access_layer_test '$pnfsname' '$outname' '$cleanup' "$section"
    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    cleanup_files '$cleanup'
}

multiple_copies_read_write_test()
{
    section="MULTIPLE COPIES READ WRITE"
    print_test_name $section

    #Test the version of encp.
    has_library_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --library switch.  Skipping test and continuing." 1>&2
	return
    fi

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	library=`cd ${PNFS_OUTPUT_DIR}; enstore sfs --library`
	encp="$encp_cmd --copies 1 --library $library,$library"
	
	#Write the original and one copy to tape.
	transfer '$encp' '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE
	test_layer '$pnfsname' "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"

	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`	
	cleanup="$cleanup $outname"

	#Do the read transfer and test for correctness of the original.
	transfer $encp_cmd '$pnfsname' '$outname' '$cleanup' "" "$section" READ
	scan_test '$pnfsname' "$section"   #TO DO: scan copy bfid

	rm -f $outname

	#Now read back the copy via bfid.
	bfid=`enstore sfs --bfid $pnfsname`
	get_bfid="--get-bfid `enstore file --find-copies $bfid`"
	transfer $encp_cmd '$get_bfid' '$outname' '$cleanup' "" "$section" READ

	rm -f $outname

	#Now read back the copy via copy number.
	transfer "$encp_cmd --copy 1" '$pnfsname' '$outname' '$cleanup' "" "$section" READ

        cleanup_files '$cleanup'
    fi
}

pnfs_agent_read_write_test()
{
    section="PNFS AGENT READ WRITE"
    print_test_name $section

    #Test the version of encp.
    is_admin_encp
    if [ $? -eq 0 ]; then
        echo "Encp is user version.  Skipping test and continuing." 1>&2
	return
    fi

    #Test if pnfs agent is configured.
    if [ -z "$PNFS_HOSTNAME" ]; then
	    echo "pnfs_agent is not configured.  Skipping test and continuing." 1>&2
	    return
    fi

    #This gets set to true if we temporarily enable $REMOTE_ENCP for encp
    # to use pnfs_agent.
    clear_remote_encp=0

    if [ -z "$REMOTE_ENCP" ]; then
	enstore pnfs_agent --alive --timeout 3 --retries 3
	if [ $? -eq 0 ]; then
	    #We detected that the pnfs_agent is running, lets use it.
	    export REMOTE_ENCP=only_pnfs_agent
	    clear_remote_encp=1
	else
	    echo "pnfs_agent is not running.  Skipping test and continuing." 1>&2
	    return
	fi
    fi

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_AGENT_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	encp="$encp_cmd"
	
	transfer "$encp" '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

	### These two tests need to be made pnfs_agent aware.
	test_layer '$pnfsname' "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"

	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer "$encp" '$pnfsname' '$outname' '$cleanup' "" "$section" READ
    fi
    
    cleanup_files '$cleanup'
    if [ $clear_remote_encp -eq 1 ]; then
        unset REMOTE_ENCP
    fi
}

setuid_read_write_test()
{
#Having a suitable setuid executable for this test is a security issue.
    return  #This test is disabled.

    section="SETUID READ AND WRITE"
    print_test_name $section
    
    which setuid > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo "Unable to find setuid.  Skipping test and continuing." 1>&2
	return
    fi

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    for file in $filelist; do      #remove non-group permission files.
        if [ `ls -l $file | cut -c5` = "r" ] ; then
	    filelist2=`echo $filelist2 $file`
	fi
    done
    RANDOM=`date +s`
    filename=`pick_random_files 1 $filelist2`
    basename=`basename $filename`
    pnfsname=`absfile $PNFS_OUTPUT_DIR $filename`
    cleanup="$pnfsname `get_lock_file_name $filename`"
    
    transfer "setuid $encp_cmd" '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    #Test if an error occured or if an error is what we expect.
    setuid test_layer '$pnfsname' "$section"
    rtn=$?
    #If we have read permissions and an error did occure.
    test -r $pnfsname -a $rtn -ne 0
    val1=$?
    #If an error did not occur but we do not have read permission.
    test ! -r $pnfsname -a $rtn -eq 0
    val2=$?
    if [ $val1 -o $val2 ]; then
	if [ $rtn -eq 1 ]; then
	    echo "Read permissions exist, yet pnfs layer read failure." 1>&2
	    setuid rm -f $outname
	    setuid rm -f $pnfsname
	    exit
	fi
    fi

    #Add the second direction.
    outname=`absfile $LOCAL_OUTPUT_DIR $filename`
    cleanup="$cleanup $outname"

    transfer "setuid $encp_cmd" '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    setuid cleanup_files '$cleanup' 
}

pipe_write_test()
{
#The library mananager expects the encp ticket value, size_bytes, to 
# contain a number.  This is not possible for pipe writes and thus
# the test will always fail.  Bugzilla number ???
    return  #This test is disabled.

    section="PIPE WRITE"
    print_test_name $section

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	encp="echo tttt | $encp_cmd"
	
        #First test that encp ingnores the standard in pipe when simulating
        # a cron environment.
        # (Note that $encp is in single quotes to delay the shells expansion
        # to the eval in transfer().)
	transfer '$encp' "$filename" "$pnfsname" "$cleanup" "" "$section" WRITE

	test_layer "$pnfsname" "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"

	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer "$encp_cmd" "$pnfsname" '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
	cleanup="$pnfsname `get_lock_file_name $filename`"

	#Second test that encp reads from standard in when there is not
	# an input file on the command line and standard in is a pipe.
        # (Note that $encp is in single quotes to delay the shells expansion
        # to the eval in transfer().)
	transfer '$encp' "" "$pnfsname" "$cleanup" "" "$section" WRITE

	test_layer '$pnfsname' "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"
	
	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer "$encp_cmd" "$pnfsname" '$outname' '$cleanup' "" "$section" READ

        cleanup_files '$cleanup'
    fi
}

source_file_does_not_exist_write_test()
{
    section="SOURCE FILE DOES NOT EXIST WRITE"
    print_test_name $section

    #Make up a bogus source file.
    filename=/tmp/i_dont_exist/i_dont_exist
    pnfsname=${PNFS_OUTPUT_DIR}/i_dont_exist
    cleanup="$pnfsname `get_lock_file_name $filename`"

    #Test if encp returns an error.
    transfer "$encp_cmd" "$filename" "$pnfsname" "$cleanup" "" "$section" WRITE 1
    
    cleanup_files '$cleanup'
}

library_does_not_exist_write_test()
{
    section="LIBRARY DOES NOT EXIST WRITE"

    #Test the version of encp.
    has_library_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --library switch.  Skipping test and continuing." 1>&2
	return
    fi

    #This test is expected to fail.
    __write_test "$encp_cmd" 1 "--library this_library_does_not_exist" 1
}

too_many_resubmits_write_test()
{
    section="TOO MANY RESUBMITS WRITE"
    print_test_name $section

    #Test the version of encp.
    has_max_resubmits_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --max-resubmits switch.  Skipping test and continuing." 1>&2
	return
    fi

    #This test is expected to fail.
    __write_test "$encp_cmd" 1 "--resubmit-timeout 0 --max-resubmit 0" 1
}

##############################################################################
#
# Next are the other tests.
#
##############################################################################

single_assert_test()
{
    section="SINGLE ASSERT"
    print_test_name $section

    if [ -z "$volume_assert_cmd" ]; then
        echo "Unable to find volume_assert.  Skipping test and continuing." 1>&2
	return
    fi

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing." 1>&2
    else
	filename=`pick_random_files 1 $filelist`

	#Grab that file's volume info.
	volume=`get_volume_from_filename "$filename"`
	if [ -z "$volume" ]; then
            echo "No suitable volume found." 1>&2
            return
        fi
        media_type=`enstore info --gvol $volume | grep media_type | awk '{print $2}' | tr -d "',"`
        if [ -z $media_type ]; then
            echo "No media type found." 1>&2
            return
        elif [ $media_type = "disk" -o $media_type = "null" ]; then
            # ees stands for Expected Exit Status.
            ees=1  #Disk and null volumes are not assertable.
        else
            ees=0  #Tape volumes are assertable.
        fi

	transfer '$volume_assert_cmd' '--volume $volume' '' '' '' "SINGLE ASSERT" READ $ees
    fi
}

ensync_test()
{
    section="ENSYNC"
    print_test_name $section

    if [ -z "$ensync_cmd" ]; then
        echo "Unable to find ensyc.  Skipping test and continuing." 1>&2
	return
    fi

    #Snag a directory, not a file or multiple files.
    input_dir=`pick_random_files 1 "$ENSYNC_INPUT_DIR"`  #lock it from others
    output_dir=$ENSYNC_OUTPUT_DIR
    #Remember to cleanup the lock for the directory, not the files.  It is
    # important to note that the lock file 
    cleanup=`get_lock_file_name $input_dir`

    if [ ! -d $input_dir ]; then
	echo "Input directory does not exist.  Skipping test and continuing." 1>&2
    elif [ ! -d $output_dir ]; then
	echo "Output directory does not exist.  Skipping test and continuing." 1>&2
    else
	transfer '$ensync_cmd' '$input_dir' '$output_dir' '$cleanup' '' '$section' WRITE 
    fi

    cleanup_dir '$output_dir'  #Remove the test files before the lock file.
    cleanup_files '$cleanup'
}


get_put_test()
{
#The get executable has bugzilla ticket #459 open.  This bug prevents a get
# command from having its requests given to movers if the tape is already
# mounted.
#
#The put executable has never worked.  Bugzilla #525.
    return  #This test is disabled.

    section="GET AND PUT"

    if [ -z "$get_cmd" ]; then
        print_test_name $section
        echo "Unable to find get.  Skipping test and continuing." 1>&2
	return
    fi
    if [ -z "$put_cmd" ]; then
        print_test_name $section
        echo "Unable to find put.  Skipping test and continuing." 1>&2
	return
    fi

    #Use get and put for read and write tests.
    __read_write_test "$get_cmd" "$put_cmd" 3 
}

get_volume_test()
{
#The get executable has bugzilla ticket #459 open.  This bug prevents a get
# command from having its requests given to movers if the tape is already
# mounted.
    return  #This test is disabled.

    section="GET VOLUME"

    if [ -z "$get_cmd" ]; then
        print_test_name $section
        echo "Unable to find get.  Skipping test and continuing." 1>&2
	return
    fi

    __volume_read_test "$get_cmd"
}

enmv_test()
{
    section="ENMV"

    if [ -z "$enmv_cmd" ]; then
        print_test_name $section
        echo "Unable to find enmv.  Skipping test and continuing." 1>&2
	return
    fi
    
    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
        print_test_name $section
	echo "Input directory empty.  Skipping test and continuing." 1>&2
	return
    else
	pnfsname=`pick_random_files 1 $filelist`

	#Rename a file to itself.  Enmv supports it.  This usage also has
        # some side-effects, like updating the path in the Enstore DB.
	transfer '$enmv_cmd' "$pnfsname" "$pnfsname" "" "" "$section" MOVE

	scan_test "$pnfsname" "$section"

        #Note: Since we are moving the file to itself, only remove the
	# lock file.
        cleanup_files `get_lock_file_name $pnfsname`
    fi
}
