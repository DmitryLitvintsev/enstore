#! /bin/sh

# $Id$

#Sourced from encp_test_script to run encp regression tests.
#
# Requires $ENSTORE_DIR/tools/encp_create_tests to work.
# Requires $LOCAL_DIR and $PNFS_DIR to be set.
#
# It creates directories test_files_for_${username} and
# encp_test_for_${username} in both $LOCAL_DIR AND $PNFS_DIR.

#These variables can be overridden from the encp_test_script command line.
encp_cmd=`which encp`
debug=0

#LOCAL_DIR is set by the user in their environment.
if [ ! -d "$LOCAL_DIR" ]; then
    echo "\$LOCAL_DIR not set.  Stopping test." 1>&2
    exit 1
fi
#PNFS_DIR is set by the user in their environment.
if [ ! -d "$PNFS_DIR" ]; then
    echo "\$PNFS_DIR not set.  Stopping test." 1>&2
    exit 1
fi

#Note: REMOTE_ENCP is an environmental variable that tells encp to use
# pnfs_agent instead of PNFS directly.  We check for the same variable here to
# handle running these tests through the pnfs agent too.

if [ -n "$REMOTE_ENCP" ]; then
    enstore pnfs_agent --timeout 10 --retries 3 --alive
    if [ $? -ne 0 ]; then
        echo 'pnfs_agent is not running and $REMOTE_ENCP is set.' \
             'Stopping test.' 1>&2
        exit 1.
    fi
fi

#############################################################################

#Return true (zero) if the requested directory is a PNFS directory.
is_pnfs()
{
    if [ -n "$REMOTE_ENCP" ]; then
	enstore pnfs_agent --exists "$1"
    else
	#It would be simple if frozen versions of the enstore command
	# had the command
	#enstore sfs --database "$1"
	# Since they all don't we need to do this the hard way.
	cat "$1/.(tags)()" > /dev/null 2>&1
    fi
    return $?
}

#Make a non-PNFS or PNFS file.
make_file()
{
    is_pnfs `dirname "$1"`
    if [ $? -eq 0 ]; then
	make_pnfs_file "$1"
    else
	touch "$1"
    fi
    return $?
}

#Make a regular PNFS file.
make_pnfs_file()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --touch "$1"
    else
        touch "$1"
    fi
    return $?
}

#Handle making files in PNFS through mountpoint or pnfs_agent.
make_pnfs_dir()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --mkdirs "$1"
    else
        mkdir -p "$1"
    fi
    return $?
}

#Handle removing a PNFS or non-PNFS file.
rm_file()
{
    is_pnfs `dirname "$1"`
    if [ $? -eq 0 ]; then
	rm_pnfs_file "$1"
    else
	rm -f "$1"
    fi
    return $?
}

#Handle removing a pnfs file.
rm_pnfs_file()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --remove "$1"
    else
        rm -f "$1"
    fi
    return $?
}

#Handle cleanup of files (both normal and in pnfs).
cleanup_files()
{
    #The list of files is called with '$cleanup' so we need to perform
    # the substitution here with eval.  $cleanup changes during the tests,
    # evaluting it here guarantees we have the latest list.
    for file in `eval echo $*`; do
        if [ "$file" = "/dev/null" ]; then
            continue
        fi

	#Automatically, remove lock files.
	if [ `basename "$file" | cut -c 1-6` = ".lock." ]; then
	    #Handle the case where the lock file is one of the target files.
	    # This will happen for tests that only read files from a volume.
	    lock_file=$file
	    file=
	else
	    lock_file=`get_lock_file_name "$file"`
	fi

	#First, the normal file.
	if [ -f "$file" -o -n "$REMOTE_ENCP" ]; then
	    if [ $debug -gt 0 ]; then
		echo "REMOVING FILE $file"
	    fi
	    rm_file "$file"
	fi

	#Next, the lock file.
	if [ -f "$lock_file" -o -n "$REMOTE_ENCP" ]; then
	    if [ $debug -gt 0 ]; then
		echo "REMOVING LOCK FILE $lock_file"
	    fi
	    rm_file "$lock_file"
	fi
    done
}

#Return zero if the file exists, and one otherwise.
does_file_exist()
{
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --exists "$1"
    else
        test -f "$1"
    fi
    return $?
}

#Return zero if the file is old, and one otherwise.
is_file_old()
{
    if [ -n "$REMOTE_ENCP" ]; then
	rc=1  #Say it is recent.  Might need to fix this sometime.
    else
	#We consider a file old after a day (-mtime +1).  Either another
	# test is hung while holding the lock file or another test
	# was killed and the locks not cleaned up.  Either way return
	# true (0) so we can move on.
	line_count=`find "$1" -mtime +1 2> /dev/null | wc -l`
	if [ $line_count -gt 0 ]; then
	    rc=0
	else
	    rc=1
	fi
    fi
    return $rc
}

get_lock_file_name()
{
    rc=0
    for pathname in "$@"; do
	if [ -n "$pathname" ]; then
	    dname=`dirname $pathname`
	    fname=`basename $pathname`
	    lock_file="$dname/.lock.$fname"
	    echo $lock_file
	    rc=`expr $rc + 0`
	else
	    rc=`expr $rc + 1`
	fi
    done
    return $rc
}

#############################################################################

truncate_encp_output()
{
    rm -f $ENCP_OUTPUT
    touch $ENCP_OUTPUT
}

print_test_name()
{
    echo STARTING $* TEST
}

#############################################################################

has_library_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-library' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

has_volume_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-volume' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

has_shortcut_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-shortcut' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

has_max_resubmits_switch()
{
    help=`$encp_cmd --help`

    echo "$help" | awk '{print $1}' | grep '\-\-max-resubmit' > /dev/null

    #If a match was found it has the switch.
    if [ $? -eq 0 ]; then
	return 1
    fi

    #Return zero if the switch is not available.
    return 0
}

is_admin_encp()
{
    version=`$encp_cmd --help`

    #This check only works for as long as --storage-group remains an
    # administator only option.
    echo "$version" | awk '{print $1}' | grep '\-\-storage-group' > /dev/null

    #If a match was found it is an admin version.
    if [ $? -eq 0 ]; then
	return 1
    fi

    return 0
}

is_user_encp()
{
    version=`$encp_cmd --help`

    #This check only works for as long as --get-cache remains an
    # dcache encp and above option.
    echo "$version" | awk '{print $1}' | grep '\-\-get-cache' > /dev/null

    #If a match was not found it is an user version.
    if [ $? -ne 0 ]; then
	return 1
    fi

    return 0
}

#The dcache version of encp (for pool nodes) is at times also called
# the user2 version of encp.
is_user2_encp()
{
    version=`$encp_cmd --help`

    #This check only works for as long as --get-cache remains an
    # dcache encp and above option.
    echo "$version" | awk '{print $1}' | grep '\-\-get-cache' > /dev/null

    #If a match was found it might be a dcache version.
    if [ $? -eq 0 ]; then
	echo "$version" | awk '{print $1}' | grep '\-\-storage-group' > /dev/null

        #If a match was not found it is a dcache version.
	if [ $? -ne 0 ]; then
	    return 1
	fi
    fi

    return 0
}

#############################################################################

username=`id -u -n`
hostname=`uname -n`

#This function preserves the value of $? after it is called.
ending_message()
{
    rc=$?
    if [ -n "$1" ]; then
	rc="$1"
    fi
    if [ $rc -ne 0 ]; then
	echo "See $ENCP_OUTPUT for full error."
    else
	echo "There were no errors.  See $ENCP_OUTPUT for more info."
    fi
    return $rc
}

#Include the username so multiple users' can run their own regression tests
# on the same node at the same time.
LOCAL_INPUT_DIR=$LOCAL_DIR/test_files_for_${username}
LOCAL_OUTPUT_DIR=$LOCAL_DIR/encp_test_for_${username}
PNFS_INPUT_DIR=$PNFS_DIR/test_files_for_${username}
PNFS_OUTPUT_DIR=$PNFS_DIR/encp_test_for_${username}
PNFS_AGENT_OUTPUT_DIR=$PNFS_OUTPUT_DIR

is_admin_encp
if [ $? -eq 1 ]; then
    PNFS_HOSTNAME=`enstore conf --retries 3 --timeout 3 --show pnfs_agent | grep hostip | cut -f 4 -d "'"`

    if [ -z "$PNFS_HOSTNAME" ]; then
        echo "Unable to obtain pnfs_agent information from configuration server."
        exit 1
    fi
fi

ENSYNC_INPUT_DIR=$LOCAL_INPUT_DIR/ensync_test
ENSYNC_OUTPUT_DIR=$PNFS_DIR/NULL/ensync_test

ENCP_OUTPUT=/tmp/encp_test_output_for_${username}
output_lock_file=`get_lock_file_name $ENCP_OUTPUT`
output_lock_file_temp=${output_lock_file}_tmp$$

touch ${output_lock_file_temp}
ln ${output_lock_file_temp} ${output_lock_file} 2> /dev/null
rc=$?
rm -f ${output_lock_file_temp}  #Cleanup.
if [ $rc -eq 0 ]; then
    #We have the lock file.
    trap "all_done;" HUP INT QUIT ABRT ALRM TERM
    trap "all_done;" EXIT
    
    #We have the common name of the output file since only this copy of
    # the script is running.
    all_done()
    {
	rc=$?
	if [ -n "$1" ]; then
	    rc=$1  #Force error condition.
	fi
	ending_message $rc
	rm -f "${output_lock_file}"  
	trap "" HUP INT QUIT ABRT ALRM TERM  #clear the trap
	trap "" EXIT
	exit $rc
    }
else
    #Another test script is running.  Use a different file.
    ENCP_OUTPUT=${ENCP_OUTPUT}_${hostname}_$$

    #We have a private version of the output file.
    all_done()
    {
	rc=$?
	if [ -n "$1" ]; then
	    rc=$1
	fi
	ending_message $rc
	exit $rc
    }
fi
if [ $debug -gt 1 ]; then
    echo ENCP_OUTPUT $ENCP_OUTPUT
fi
rm -f $ENCP_OUTPUT
if [ $? -ne 0 ]; then
    #Use rm error message.
    all_done 1
fi
touch $ENCP_OUTPUT
if [ $? -ne 0 ]; then
    #Use touch error message.
    all_done 1
fi

encp_create_tests
mkdir -p $LOCAL_OUTPUT_DIR
make_pnfs_dir $PNFS_INPUT_DIR
make_pnfs_dir $PNFS_OUTPUT_DIR

#Make sure we have correct permissions for these directories.
for dir_to_check in "$LOCAL_INPUT_DIR" "$LOCAL_OUTPUT_DIR" \
                    "$PNFS_INPUT_DIR" "$PNFS_OUTPUT_DIR" "$PNFS_OUTPUT_DIR"; do
    if [ ! -x "$dir_to_check" ]; then
        echo "No execute permissions for directory: $dir_to_check" 1>&2
	all_done 1
    fi
    if [ ! -r "$dir_to_check" ]; then
	echo "No read permissions for directory: $dir_to_check" 1>&2
	all_done 1
    fi
    if [ ! -w "$dir_to_check" ]; then
	echo "No write permissions for directory: $dir_to_check" 1>&2
	all_done 1
    fi
done

#Make test pnfs files.
for fname in `ls $LOCAL_INPUT_DIR`; do
    #Handle using mounted pnfs filesystem or using pnfs agent.
    if [ -n "$REMOTE_ENCP" ]; then
        enstore pnfs_agent --exists $PNFS_INPUT_DIR/$fname
        pnfs_test=$?
    else
        test -f $PNFS_INPUT_DIR/$fname
        pnfs_test=$?
    fi
    if [ -f $LOCAL_INPUT_DIR/$fname -a ! $pnfs_test ]; then
	#We set the file family to volume_read_test for the benifit of the
	# volume read test.
        echo encp --file-family volume_read_test $LOCAL_INPUT_DIR/$fname $PNFS_INPUT_DIR/$fname
	encp --file-family volume_read_test $LOCAL_INPUT_DIR/$fname $PNFS_INPUT_DIR/$fname
    fi
done

#############################################################################

get_file_list()
{
#$1 = directory of file to choose from

    #Restrict this to files less than 100MB in size and non-hidden files.
    # Only consider files in this directory first; go recurisive if the
    # first list is empty.
    filenames=`find $1 -maxdepth 1 -size -104857600c -type f 2> /dev/null`
    if [ -z "$filenames" ]; then
	filenames=`find $1 -size -104857600c -type f ! -name ".*" 2> /dev/null`
    fi

    echo "$filenames"
}

get_pnfs_file_list()
{
#$1 = directory of file to choose from

    #Restrict this to files less than 100MB in size and non-hidden files.
    # Only consider files in this directory first; go recurisive if the
    # first list is empty.
    if [ -n "$REMOTE_ENCP" ]; then
	filenames=`enstore pnfs_agent --just-files --list-dir $1`
    else
        filenames=`find $1 -maxdepth 1 -size -104857600c -type f ! -name ".*" 2> /dev/null`
	if [ -z "$filenames" ]; then
	    filenames=`find $1 -size -104857600c -type f ! -name ".*" 2> /dev/null`
	fi
    fi

    echo "$filenames"
}

get_volume_from_filename()
{
#$1 = pnfs filename to get the volume
    filename=$1
    
    
    if [ -n "$REMOTE_ENCP" ]; then
	#Rip just the volume out of the layer 4.
	volume=`enstore pnfs_agent --layer 4 $filename | sed -n '1p'`
    else
        #Determine the layer 4 filename.
	layer4_filename=`dirname $filename; echo "/.(use)(4)("; basename $filename; echo ")"`
	layer4_filename=`echo $layer4_filename | tr -d " "`
	
        #Rip just the volume out of the layer 4.
	volume=`cat $layer4_filename | sed -n '1p'`
    fi

    echo $volume
}


#Make sure any debuging echos do not go to standard out.  This function returns
# volume labels that way any random output will give errors.
#
#It is possible that this function returns less than the requested number
# of volume labels depending on availability.
pick_random_volumes()
{
    number=$1  #First argument is number of volumes. Rest of arguments are volumes.
    shift
    rnd=`expr $RANDOM + 1`
    #Between 9 and number of volumes, pick the lesser.
    if [ 9 -lt $# ]; then
	i=9
    else
	i=$#
    fi
    rand=`expr $rnd % $i`
    rand=`expr $rand + 1`
    i=1
    while [ $i -le $number ]; do
        eval echo \$$rand
	shift
	i=`expr $i + 1`
    done
}


#Make sure any debuging echos do not go to standard out.  This function returns
# filenames that way any random output will give errors.
#
#It is possible that this function returns less than the requested number
# of files when multiple test are running at once to avoid deadlocks.
pick_random_files()
{
    number=$1  #First argument is number of files. Rest of arguments are files.
    shift

    if [ $# -eq 0 ]; then
	echo "No files available for selection." 1>&2
	return 0
    fi

    rnd=`expr $RANDOM + 1`
    rand=`expr $rnd % $#`
    rand=`expr $rand + 1`
    current=$rand  #Seed the current position with the random number.
    i=0  #Number of files choosen for locking.

    #This outer loop is to make sure that as long as one file is locked when
    # more than one file needs to be picked, that we can return the shorter
    # list.  If we haven't gotten at least one file already then we keep
    # looping.
    while [ $i -eq 0 ]; do
      loop_count=0  #Number of passes over the list of files.
      while [ $i -lt $number -a $loop_count -lt 3 ]; do

	if [ $current -eq 0 ]; then
	    #Skip the executable in $0.
            loop_count=`expr $loop_count + 1`
	    current=1
	    sleep 1 #Give other encps a chance.
	fi

	filename=$(eval echo \$\{"${current}"\})
	dname=`dirname $filename`
	fname=`basename $filename`
	if [ `echo "$fname" | cut -c 1` = "." ]; then
	    #We found a hidden file.  Skip it.
	    current=`echo \( $current + 1 \) % $# | bc`
	    continue
	fi
	lock_file="$dname/.lock.$fname"
	lock_file_temp="$dname/.lock.temp$$.$fname"
	make_file $lock_file_temp  1>&2 #touch $lock_file_temp
	
	#Determine if the file exists.
	ln "$lock_file_temp" "$lock_file" 2> /dev/null
	rc=$?
	rm -f "$lock_file_temp"  #Cleanup.
	if [ $rc -eq 0 ]; then
	    #The lock file does not exist.
	    current=`echo \( $current + 1 \) % $# | bc`
	    i=`expr $i + 1`  #Up to number of files found.
	    echo "$filename"

	    if [ $debug -gt 0 ]; then
		echo "MAKING LOCK FILE $lock_file" 1>&2
	    fi
	    make_file "$lock_file"   #touch $lock_file_temp
	else
	    #Determine if the file is new and should be skipped.  Or old
	    # and should be removed.
	    is_file_old "$lock_file"
	    if [ $? -eq 0 ]; then
		if [ $debug -gt 0 ]; then
		    echo "Found old lock file.  Removing.  $lock_file" 1>&2
		fi
		rm -f "lock_file"
		current=`echo \( $current + 1 \) % $# | bc`
		i=`expr $i + 1`  #Up to number of files found.
		echo "$filename"
	    else
		#This test file is in use, get another one.
                if [ $debug -gt 0 ]; then
		    echo "Found recent lock file.  Skipping.  $lock_file" 1>&2
                fi
		current=`echo \( $current + 1 \) % $# | bc`
		sleep 1  #Give other encps a moment to complete.
	    fi
	fi
      done
    done
    return $i
}

#First argument is the directory to place before every other argument.
absfile()
{
    dir=$1
    shift
    for s in $*
    do
	s=`basename $s`
	abs_filenames=`echo $abs_filenames; echo $dir/$s`
    done

    echo $abs_filenames
}

#############################################################################

#transfer file
transfer()
{
    encp_command=`eval echo $1`
    infile=`eval echo $2`
    outfile=`eval echo $3`
    cleanup=`eval echo $4`
    options=`eval echo $5`
    message=`eval echo $6`
    direction=`eval echo $7`
    if [ -z "$8" ]; then  #This allows us to check for failures too.
        expected_exit_status=0
    else
        expected_exit_status=`eval echo $8`
    fi

    > $ENCP_OUTPUT    #truncate output file

    if [ $debug -gt 2 ]; then
        echo ENCP $encp_command | tee -a $ENCP_OUTPUT 2>&1
        echo INPUT $infile | tee -a $ENCP_OUTPUT 2>&1
        echo OUTPUT $outfile | tee -a $ENCP_OUTPUT 2>&1
        echo INCLEANUP $cleanup | tee -a $ENCP_OUTPUT 2>&1
        echo OPTIONS $options | tee -a $ENCP_OUTPUT 2>&1
        echo MESSAGE $message | tee -a $ENCP_OUTPUT 2>&1
        echo DIRECTION $direction | tee -a $ENCP_OUTPUT 2>&1
        echo EXPECTED_EXIT_STATUS $expected_exit_status | tee -a $ENCP_OUTPUT 2>&1
        echo CWD `pwd` | tee -a $ENCP_OUTPUT 2>&1
    fi

    if [ $debug -gt 0 ]; then
        #Output the command line that will be executed.
	echo "$encp_command $verbose $options $infile $outfile >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT" | tee -a $ENCP_OUTPUT 2>&1

	#Output the type of encp that we are runnig.
	is_admin_encp
	if [ $? -eq 1 ]; then
            echo "type is admin encp version" | tee -a $ENCP_OUTPUT 2>&1
        fi
	is_user2_encp
	if [ $? -eq 1 ]; then
            echo "type is dcache encp version" | tee -a $ENCP_OUTPUT 2>&1
        fi
	is_user_encp
	if [ $? -eq 1 ]; then
            echo "type is user encp version" | tee -a $ENCP_OUTPUT 2>&1
        fi
    fi
    eval $encp_command $verbose $options $infile $outfile >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT

    rtn=$?
    if [ $rtn -ne $expected_exit_status ]; then
	echo "$message TEST FAILED WITH $rtn ON $direction"
	cat $ENCP_OUTPUT
	cleanup_files "$cleanup"
	all_done 1
    else
        echo "$message TEST SUCCEEDED WITH $rtn ON $direction"
	if [ $debug -gt 1 ]; then
	    #Only output this if they really want it.
	    cat $ENCP_OUTPUT
	fi
    fi
}

#test volume
volume_assert()
{
    assert=$1  #`eval echo $1`
    volume=`eval echo $2`
    message=`eval echo $3`
    if [ -z "$4" ]; then  #This allows us to check for failures too.
        expected_exit_status=0
    else
        expected_exit_status=`eval echo $4`
    fi

    if [ $debug -gt 2 ]; then
        echo ASSERT $assert
        echo VOLUME $volume
        echo MESSAGE $message
	echo EXPECTED_EXIT_STATUS $expected_exit_status
    fi
    
    if [ $debug -gt 0 ]; then
        echo "$assert --verbose 1 --volume $volume >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT" | tee $ENCP_OUTPUT 2>&1
    fi
    $assert --verbose 1 --volume $volume >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT

    rtn=$?
    if [ "$rtn" -ne $expected_exit_status ]; then
	echo "$message TEST FAILED WITH $rtn"
	cat $ENCP_OUTPUT
	for file in $cleanup; do
	    if [ "$file" != "/dev/null" ]; then
		rm -f $file
	    fi
	done
	all_done 1
    else
        echo "$message TEST SUCCEEDED WITH $rtn"
	if [ $debug -gt 1 ]; then
	    #Only output this if they really want it.
	    cat $ENCP_OUTPUT
	fi
    fi
}

#test ensync
ensync_transfer()
{
    ensync=`eval echo $1`
    input_dir=`eval echo $2`
    output_dir=`eval echo $3`
    message=`eval echo $4`
    if [ -z "$5" ]; then  #This allows us to check for failures too.
        expected_exit_status=0
    else
        expected_exit_status=`eval echo $5`
    fi

    if [ $debug -gt 2 ]; then
        echo ASSERT $assert
        echo VOLUME $volume
        echo MESSAGE $message
    fi

    if [ $debug -ne $expected_exit_status ]; then
	echo "$ensync --verbose 1 $input_dir $output_dir >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT" | tee $ENCP_OUTPUT 2>&1
    fi

    $ensync --verbose 1 $input_dir $output_dir >> $ENCP_OUTPUT 2>> $ENCP_OUTPUT

    rtn=$?
    if [ "$rtn" -gt 0 ]; then
	echo "$message TEST FAILED WITH $rtn"
	cat $ENCP_OUTPUT
	for file in $cleanup; do
	    if [ "$file" != "/dev/null" ]; then
		rm -f $file
	    fi
	done
	all_done 1
    else
        echo "$message TEST SUCCEEDED WITH $rtn"
	if [ $debug -gt 1 ]; then
	    #Only output this if they really want it.
	    cat $ENCP_OUTPUT
	fi
    fi
}

#############################################################################

#Test if the original input and the final output files are the same.
###
### This does does not work with pnfs_agent.
###
test_diff()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`

    i=1
    count=`echo $infiles | wc -w`
    while [ $i -le $count ]; do
	ifile=`echo $infiles | cut -d" " -f$i`
	ofile=`echo $outfiles | cut -d" " -f$i`
	i=`expr $i + 1`

	diff_output=`diff --brief $ifile $ofile 2>&1`

	rtn=$?
	if [ "$rtn" -gt 0 ]; then
	    #The files are not the same.  This might be correct if we used
	    # a null mover.

	    o_ls_size=`ls -l "$ofile" | awk '{print $5}'`
	    i_ls_size=`ls -l "$ifile" | awk '{print $5}'`
	    if [ $i_ls_size -eq $o_ls_size ]; then
		non_null_word_count=`cat "$ofile" | tr -d "\000" | wc -c`
		if [ $non_null_word_count -eq 0 ]; then
		    #We have a NULL file.  Let's assume this is from a
		    # null mover.
		    return 0
		fi
	    fi

	    echo $message "TEST FAILED ON DIFF"
	    echo "$diff_output"
	    cat $ENCP_OUTPUT
	    cleanup_files '$cleanupfiles'
	    all_done 1
	fi
    done
}

#Test that the layer info is correct.
test_layer()
{
    pnfsfiles=`eval echo $1`
    message=`eval echo $2`
    
    for file in $pnfsfiles; do
	if [ -n "$REMOTE_ENCP" ]; then
            enstore pnfs_agent --layer 1 $file > /dev/null
        else
	    enstore sfs --layer $file 1 > /dev/null
	fi
	if [ $? -ne 0 ]; then
	    echo $message "TEST FAILED ON LAYER"
	    echo No bfid value: $result: $file
	    all_done 1
	fi
	if [ -n "$REMOTE_ENCP" ]; then
	    result=`enstore pnfs_agent --layer 4 $file`
	else
	    result=`enstore sfs --layer $file 4`
	fi
	for line in result; do
	    if [ $line = "unknown" ]; then
		echo $message "TEST FAILED ON LAYER"
		echo Layer 4 contains unknown value: $file
		echo $result
		all_done 1
	    fi
	done
    done
}

#Test that the permissions are the same.
###
### This does does not work with pnfs_agent.
###
permissions_test()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`

    i=1
    count=`echo $infiles | wc -w`
    while [ $i -le $count ]; do
	ifile=`echo $infiles | cut -d" " -f$i`
	ofile=`echo $outfiles | cut -d" " -f$i`
	i=`expr $i + 1`

	result1=`ls -l $ifile | cut -c1-10`
	result2=`ls -l $ofile | cut -c1-10`
	
	if [ $result1 != $result2 ]; then
	    echo $message "TEST FAILED ON PERMISSIONS"
	    echo $result1 != $result2
	    rm -f $cleanupfiles
	    all_sone 1
	fi
    done
}

#Test that the sizes are the same.
###
### This does does not work with pnfs_agent.
###
size_test()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`

    i=1
    count=`echo $infiles | wc -w`
    while [ $i -le $count ]; do
	ifile=`echo $infiles | cut -d" " -f$i`
	ofile=`echo $outfiles | cut -d" " -f$i`
	i=`expr $i + 1`

	result1=`ls -l $ifile | sed 's/ \{1,30\}/ /g' | cut -f 5 "-d "`
	result2=`ls -l $ofile | sed 's/ \{1,30\}/ /g' | cut -f 5 "-d "`
	if [ $result1 != $result2 ]; then
	    echo $message "TEST FAILED ON SIZE"
	    echo $result1 != $result2
	    rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	    all_done 1
	fi
    done
}

#Test that the data access layer is correct.
data_access_layer_test()
{
    infiles=`eval echo $1`
    outfiles=`eval echo $2`
    cleanupfiles=`eval echo $3`
    message=`eval echo $4`
    volume1=`get_volume_from_filename "$infiles" 2> /dev/null`
    volume2=`get_volume_from_filename "$outfiles" 2> /dev/null`
    volume=`echo $volume1 $volume2`

    #If the INFILE data access output line does not specify the filename,
    # exit with error.
    grep INFILE "$ENCP_OUTPUT" | grep "$infiles" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON INFILE"
	grep INFILE "$ENCP_OUTPUT"
	echo Expected: "$infiles"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi

    #If the OUTFILE data access output line does not specify the filename,
    # exit with error.
    grep OUTFILE "$ENCP_OUTPUT" | grep "$outfiles" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON OUTFILE"
	grep OUTFILE "$ENCP_OUTPUT"
	echo Expected: "$outfiles"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi

    #If the VOLUME data access output line does not specify the volume,
    # exit with error.
    grep LABEL "$ENCP_OUTPUT" | grep "$volume" > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON VOLUME"
	grep LABEL "$ENCP_OUTPUT"
	echo Expected: "$volume"
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi

    #If the LOCATION data access output line does not specify the position,
    # exit with error.
    lc=`grep LOCATION "$ENCP_OUTPUT" | tail -n 1 | sed 's/LOCATION=//' | wc -m`
    if [ $lc -eq 0 ]; then
	echo $message "TEST FAILED ON LOCATION"
	grep LOCATION "$ENCP_OUTPUT"
	echo Expected: non-empty string
	rm -f $cleanupfiles || setuid rm -f $cleanupfiles
	all_done 1
    fi
}

enstore_check_test()
{
    pnfsfiles=`eval echo $1`
    cleanupfiles=`eval echo $2`
    message=`eval echo $3`

    en_check "$pnfsfiles"
    if [ $? -ne 0 ]; then
	echo $message "TEST FAILED ON ENSTORE CHECK"
	rm -f $cleanupfiles
	all_done 1
    fi
}

#############################################################################

single_read_test()
{
    section="SINGLE READ"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	#Specify file paths.
	filename=`pick_random_files 1 $filelist`
	outname=/dev/null
	cleanup="$outname `get_lock_file_name $filename`"

	transfer $encp_cmd '$filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

single_read_write_test()
{
    section="SINGLE READ AND WRITE"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"

    transfer $encp_cmd '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsname' "$section"

    #Add the second direction.
    outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
    cleanup="$cleanup $outname"

    transfer $encp_cmd '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    cleanup_files '$cleanup'
}


multiple_read_write_test()
{
    section="MULITPLE READ AND WRITE"
    print_test_name $section

    truncate_encp_output

    #Snag random files.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filenames=`pick_random_files 3 $filelist`
    pnfsnames=`absfile $PNFS_OUTPUT_DIR $filenames`
    cleanup="$pnfsnames `get_lock_file_name $filenames`"

    transfer $encp_cmd '$filenames' '$PNFS_OUTPUT_DIR' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsnames' "$section"
    
    #Add the second direction.
    outnames=`absfile $LOCAL_OUTPUT_DIR $filenames`
    cleanup="$cleanup $outnames"

    transfer $encp_cmd '$pnfsnames' '$LOCAL_OUTPUT_DIR' '$cleanup' "" "$section" READ

    test_diff '$filenames' '$outnames' '$cleanup' "$section"
    permissions_test '$filenames' '$outnames' '$cleanup' "$section"
    size_test '$filenames' '$outnames' '$cleanup' "$section"

    cleanup_files '$cleanup'
}


dcache_read_write_test()
{
    section="DCACHE READ AND WRITE"
    print_test_name $section

    #Test the version of encp.
    has_shortcut_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --shortcut switch.  Skipping test and continuing."
	return
    fi

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
	return
    fi
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`absfile $PNFS_OUTPUT_DIR $basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"

    #Create the output file, set the size and get the pnfs id.
    size=`ls -l $filename | sed 's/ \{1,30\}/ /g' | cut -f 5 "-d "`
    if [ -n "$REMOTE_ENCP" ]; then
	enstore pnfs_agent --touch $pnfsname
	enstore pnfs_agent --size "${pnfsname}" "${size}"
	pnfsid=`enstore pnfs_agent --id $pnfsname`
    else
        touch $pnfsname
	enstore sfs --size "${pnfsname}" "${size}"
	pnfsid=`enstore sfs --id $pnfsname`
    fi

    #Shorten some things for readability.
    mount="--shortcut --pnfs-mount $PNFS_DIR"
    put_id="--put-cache $pnfsid"
    get_id="--get-cache $pnfsid"

    #Do the write transfer and test for correctness.
    transfer $encp_cmd '$put_id' '$filename' '$cleanup' '$mount' "$section" WRITE
    
    test_layer '$pnfsname' "$section"

    #Add the second direction.
    outname=`absfile $LOCAL_OUTPUT_DIR $basename`
    cleanup="$cleanup $outname"

    #Do the read transfer and test for correctness.
    transfer $encp_cmd '$get_id' '$outname' '$cleanup' '$mount' "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    rm -f $outname

    #Do the read transfer and test with short cutting of extrapolating
    # the full file path enabled.
    get_id="--shortcut --get-cache $pnfsid"
    transfer $encp_cmd '$get_id' '$outname' '$cleanup' '$mount' "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"
     
    cleanup_files '$cleanup'
}

non_conf_read_write_test()
{
    section="NON-CONF READ AND WRITE"
    print_test_name $section
    
    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`absfile $PNFS_OUTPUT_DIR $filename`
    cleanup="$pnfsname `get_lock_file_name $filename`"

    #Override enstore.conf
    export ENSTORE_CONF=NULL #This is a string "NULL", not ((void*)NULL) in C.

    transfer $encp_cmd '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE
    
    test_layer '$pnfsname' "$section"

    #Add the second direction.
    outname=`absfile $LOCAL_OUTPUT_DIR $filename`
    cleanup="$cleanup $outname"

    transfer $encp_cmd '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    cleanup_files '$cleanup'
}

setuid_read_write_test()
{
    section="SETUID READ AND WRITE"
    print_test_name $section
    
    which setuid > /dev/null 2>&1
    if [ $? -ne 0 ]; then
	echo "Unable to find setuid.  Skipping test and continuing."
	return
    fi

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    for file in $filelist; do      #remove non-group permission files.
        if [ `ls -l $file | cut -c5` = "r" ] ; then
	    filelist2=`echo $filelist2 $file`
	fi
    done
    RANDOM=`date +s`
    filename=`pick_random_files 1 $filelist2`
    basename=`basename $filename`
    pnfsname=`absfile $PNFS_OUTPUT_DIR $filename`
    cleanup="$pnfsname `get_lock_file_name $filename`"
    
    transfer "setuid $encp_cmd" '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    #Test if an error occured or if an error is what we expect.
    setuid test_layer '$pnfsname' "$section"
    rtn=$?
    #If we have read permissions and an error did occure.
    test -r $pnfsname -a $rtn -ne 0
    val1=$?
    #If an error did not occur but we do not have read permission.
    test ! -r $pnfsname -a $rtn -eq 0
    val2=$?
    if [ $val1 -o $val2 ]; then
	if [ $rtn -eq 1 ]; then
	    echo "Read permissions exist, yet pnfs layer read failure."
	    setuid rm -f $outname
	    setuid rm -f $pnfsname
	    exit
	fi
    fi

    #Add the second direction.
    outname=`absfile $LOCAL_OUTPUT_DIR $filename`
    cleanup="$cleanup $outname"

    transfer "setuid $encp_cmd" '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    setuid cleanup_files '$cleanup' 
}

single_threaded_read_write_test()
{
    section="SINGLE THREADED READ AND WRITE"
    print_test_name $section

    truncate_encp_output
    
    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"
    encp="$encp_cmd --threaded"

    transfer "$encp" '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsname' "$section"

    #Add the second direction.
    outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
    cleanup="$cleanup $outname"

    transfer "$encp" '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    cleanup_files '$cleanup'
}

multiple_threaded_read_write_test()
{
    section="MULITPLE THREADED READ AND WRITE"
    print_test_name $section

    truncate_encp_output

    #Snag random files.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filenames=`pick_random_files 3 $filelist`
    pnfsnames=`absfile $PNFS_OUTPUT_DIR $filenames`
    cleanup="$pnfsnames `get_lock_file_name $filenames`"
    encp="$encp_cmd --threaded"

    transfer "$encp" '$filenames' '$PNFS_OUTPUT_DIR' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsnames' "$section"

    #Add the second direction.
    outnames=`absfile $LOCAL_OUTPUT_DIR $filenames`
    cleanup="$cleanup $outnames"
    
    transfer "$encp" '$pnfsnames' '$LOCAL_OUTPUT_DIR' '$cleanup' "" "$section" READ

    test_diff '$filenames' '$outnames' '$cleanup' "$section"
    permissions_test '$filenames' '$outnames' '$cleanup' "$section"
    size_test '$filenames' '$outnames' '$cleanup' "$section"

    cleanup_files '$cleanup'
}

single_ecrc_read_write_test()
{
    section="SINGLE ECRC READ AND WRITE"
    print_test_name $section

    truncate_encp_output
    
    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"
    encp="$encp_cmd --ecrc"

    transfer "$encp" '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsname' "$section"

    #Add the second direction.
    outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
    cleanup="$cleanup $outname"

    transfer "$encp" '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    cleanup_files '$cleanup'
}


single_assert_test()
{
    section="SINGLE ASSERT"
    print_test_name $section

    #Test the version of encp.
    is_admin_encp
    if [ $? -eq 0 ]; then
        echo "Encp is cut version.  Skipping test and continuing."
	return
    fi

    #Current volume_assert location.
    assert=`dirname $encp_cmd`/volume_assert
    if [ ! -f "$assert" ]; then
        echo "Unable to find $assert.  Skipping test and continuing."
	return
    fi

    wrapper=`cat "$PNFS_INPUT_DIR/.(tag)(file_family_wrapper)"`
    if [ "$wrapper" == "null" ]; then
	echo "Found null wrapper.  Skipping test and continuing."
	return
    fi

    truncate_encp_output
    
    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`

	volume=`get_volume_from_filename "$filename"`

	volume_assert "$assert" '$volume' '$section'
    fi
}

ensync_test()
{
    section="ENSYNC"
    print_test_name $section

    truncate_encp_output
    
    #Snag a directory.
    input_dir=$ENSYNC_INPUT_DIR
    output_dir=$ENSYNC_OUTPUT_DIR
    
    #Get the 
    #Current ensync location.
    ensync=`dirname $encp_cmd`/ensync
    if [ ! -f "$ensync" ]; then
        echo "Unable to find $ensync.  Skipping test and continuing."
	return
    fi

    if [ ! -d $input_dir ]; then
	echo "Input directory does not exist.  Skipping test and continuing."
    elif [ ! -d $output_dir ]; then
	echo "Output directory does not exist.  Skipping test and continuing."
    else
        ensync_transfer "$ensync" '$input_dir' '$output_dir' '$section'
    fi
}

single_relative_path_read_write_test()
{
    section="SINGLE RELATIVE PATH READ AND WRITE"
    print_test_name $section

    truncate_encp_output
    
    if [ -n "$REMOTE_ENCP" ]; then
	echo "Detected using pnfs_agent.  Skipping test and continuing."
    else
	cwd=`pwd`

        #Snag a random file.
	filelist=`get_file_list "$LOCAL_INPUT_DIR"`
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo $basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"

	cd ${PNFS_OUTPUT_DIR}/

	transfer $encp_cmd '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE
	
	test_layer '$pnfsname' "$section"
	
        #Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer $encp_cmd '$pnfsname' '$outname' '$cleanup' "" "$section" READ

	test_diff '$filename' '$outname' '$cleanup' "$section"
	permissions_test '$filename' '$outname' '$cleanup' "$section"
	size_test '$filename' '$outname' '$cleanup' "$section"
	
	cleanup_files '$cleanup'
	
	cd $cwd
    fi
}

single_local_pnfs_path_read_test()
{
    section="SINGLE LOCAL PNFS PATH READ"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	outdir=$LOCAL_OUTPUT_DIR/pnfs/
	outname=${outdir}/${basename}
	cleanup="$outname `get_lock_file_name $filename`"

	#If this does not exist, create it.
	mkdir -p $outdir
	
	transfer $encp_cmd '$filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

single_no_brand_read_test()
{
    section="SINGLE NO BRAND READ"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist="$PNFS_INPUT_DIR/special_files/no_brand"
    if [ -z "$filelist" -o ! -f "$filelist" ]; then
	echo "Input file not found.  Skipping test and continuing."
    elif [ `enstore sfs --bfid $filelist | tr -d '[0-9]\n' | wc -c` -gt 0 ]; then
	#We should only get here if the bfid contains more than just
	# digits (and a newline).
	echo "$filelist bfid contains brand.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	if [ -z "$filename" ]; then
	    echo "Input file not available.  Skipping test and continuing."
	    return
	fi
	outname=/dev/null
	cleanup="$outname `get_lock_file_name $filename`"

	transfer $encp_cmd '$filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

volume_read_test()
{
    section="VOLUME READ"
    print_test_name $section

    #Test the version of encp.
    has_volume_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --volume switch.  Skipping test and continuing."
        return
    fi 

    truncate_encp_output

    encp="$encp_cmd --skip-deleted-files"

    #Snag a volume_read_test volume.
    volumes=`enstore info --query "select label from volume where file_family = 'volume_read_test' and label not like '%.deleted' ;" | sed '1,2d'`
    if [ -z "$volumes" ]; then
	echo "No suitable volumes found.  Skipping test and continuing."
    else
	#Pick a random volume.
	volume=`pick_random_volumes 1 $volumes`

	outname=/dev/null

	transfer "$encp" '' '$outname' "" "--volume $volume" "$section" READ
    fi
}

single_fs_path_read_test()
{
    section="SINGLE FS PATH READ"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist=`get_pnfs_file_list "$PNFS_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	#Turn this path into the dcache prefered /pnfs/fs/usr/... path.
	# Encp should be able to determine the /pnfs/... path.
	encp_filename=`echo $filename | cut -c1-6`fs/usr`echo $filename | cut -c6-`
	outname=/dev/null
	cleanup="$outname `get_lock_file_name $filename`"

	transfer $encp_cmd '$encp_filename' '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
    fi
}

data_access_layer_read_write_test()
{
    section="DATA ACCESS LAYER READ WRITE"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    filename=`pick_random_files 1 $filelist`
    basename=`basename $filename`
    pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
    cleanup="$pnfsname `get_lock_file_name $filename`"
    encp="$encp_cmd --data-access-layer"

    transfer '$encp' '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

    test_layer '$pnfsname' "$section"
    data_access_layer_test '$filename' '$pnfsname' '$cleanup' "$section"
    
    #Add the second direction.
    outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
    cleanup="$cleanup $outname"

    transfer '$encp' '$pnfsname' '$outname' '$cleanup' "" "$section" READ

    data_access_layer_test '$pnfsname' '$outname' '$cleanup' "$section"
    test_diff '$filename' '$outname' '$cleanup' "$section"
    permissions_test '$filename' '$outname' '$cleanup' "$section"
    size_test '$filename' '$outname' '$cleanup' "$section"

    cleanup_files '$cleanup'
}

multiple_copies_read_write_test()
{
    section="MULTIPLE COPIES READ WRITE"
    print_test_name $section

    #Test the version of encp.
    has_library_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --library switch.  Skipping test and continuing."
	return
    fi

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	library=`cd ${PNFS_OUTPUT_DIR}; enstore sfs --library`
	encp="$encp_cmd --copies 1 --library $library,$library"
	
	#Write the original and one copy to tape.
	transfer '$encp' '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE
	test_layer '$pnfsname' "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"

	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`	
	cleanup="$cleanup $outname"

	#Do the read transfer and test for correctness of the original.
	transfer $encp_cmd '$pnfsname' '$outname' '$cleanup' "" "$section" READ

	rm -f $outname

	#Now read back the copy via bfid.
	bfid=`enstore sfs --bfid $pnfsname`
	get_bfid="--get-bfid `enstore file --find-copies $bfid`"
	transfer $encp_cmd '$get_bfid' '$outname' '$cleanup' "" "$section" READ

	rm -f $outname

	#Now read back the copy via copy number.
	transfer "$encp_cmd --copy 1" '$pnfsname' '$outname' '$cleanup' "" "$section" READ

        cleanup_files '$cleanup'
    fi
}

pnfs_agent_read_write_test()
{
    section="PNFS AGENT READ WRITE"
    print_test_name $section

    #Test the version of encp.
    is_admin_encp
    if [ $? -eq 0 ]; then
        echo "Encp is user version.  Skipping test and continuing."
	return
    fi

    #Test if pnfs agent is configured.
    if [ -z "$PNFS_HOSTNAME" ]; then
	    echo "pnfs_agent is not configured.  Skipping test and continuing."
	    return
    fi

    #This gets set to true if we temporarily enable $REMOTE_ENCP for encp
    # to use pnfs_agent.
    clear_remote_encp=0

    if [ -z "$REMOTE_ENCP" ]; then
	enstore pnfs_agent --alive --timeout 3 --retries 3
	if [ $? -eq 0 ]; then
	    #We detected that the pnfs_agent is running, lets use it.
	    export REMOTE_ENCP=only_pnfs_agent
	    clear_remote_encp=1
	else
	    echo "pnfs_agent is not running.  Skipping test and continuing."
	    return
	fi
    fi

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_AGENT_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	encp="$encp_cmd"
	
	transfer "$encp" '$filename' '$pnfsname' '$cleanup' "" "$section" WRITE

	### These two tests need to be made pnfs_agent aware.
	test_layer '$pnfsname' "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"

	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer "$encp" '$pnfsname' '$outname' '$cleanup' "" "$section" READ
    fi
    
    cleanup_files '$cleanup'
    if [ $clear_remote_encp -eq 1 ]; then
        unset REMOTE_ENCP
    fi
}

pipe_write_test()
{
    section="PIPE WRITE"
    print_test_name $section

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	encp="echo tttt | $encp_cmd"
	
	#First test that encp ingnores the standard in pipe when simulating
	# a cron environment.
	transfer "$encp" "$filename" "$pnfsname" "$cleanup" "" "$section" WRITE

	test_layer "$pnfsname" "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"

	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer "$encp_cmd" "$pnfsname" '$outname' '$cleanup' "" "$section" READ

	cleanup_files '$cleanup'
	cleanup="$pnfsname `get_lock_file_name $filename`"

	#Second test that encp reads from standard in when there is not
	# an input file on the command line and standard in is a pipe.
	transfer "$encp" "" "$pnfsname" "$cleanup" "" "$section" WRITE

	test_layer '$pnfsname' "$section"
	enstore_check_test '$pnfsname' '$cleanup' "$section"
	
	#Add the second direction.
	outname=`echo ${LOCAL_OUTPUT_DIR}/$basename`
	cleanup="$cleanup $outname"

	transfer "$encp_cmd" "$pnfsname" '$outname' '$cleanup' "" "$section" READ

        cleanup_files '$cleanup'
    fi
}

source_file_does_not_exist_write_test()
{
    section="SOURCE FILE DOES NOT EXIST WRITE"
    print_test_name $section

    truncate_encp_output

    #Make up a bogus source file.
    filename=/tmp/i_dont_exist/i_dont_exist
    pnfsname=${PNFS_OUTPUT_DIR}/i_dont_exist
    cleanup="$pnfsname `get_lock_file_name $filename`"

    #Test if encp returns an error.
    transfer "$encp_cmd" "$filename" "$pnfsname" "$cleanup" "" "$section" WRITE 1
    
    cleanup_files '$cleanup'
}

library_does_not_exist_write_test()
{
    section="LIBRARY DOES NOT EXIST WRITE"
    print_test_name $section

    #Test the version of encp.
    has_library_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --library switch.  Skipping test and continuing."
	return
    fi

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	encp="$encp_cmd --library this_library_does_not_exist"
	
	#See if the transfer fails.
	transfer "$encp" "$filename" "$pnfsname" "$cleanup" "" "$section" WRITE 1

	cleanup_files '$cleanup'
    fi
}

too_many_resubmits_write_test()
{
    section="TOO MANY RESUBMITS WRITE"
    print_test_name $section

    #Test the version of encp.
    has_max_resubmits_switch
    if [ $? -eq 0 ]; then
        echo "Encp does not have --max-resubmits switch.  Skipping test and continuing."
	return
    fi

    truncate_encp_output

    #Snag a random file.
    filelist=`get_file_list "$LOCAL_INPUT_DIR"`
    if [ -z "$filelist" ]; then
	echo "Input directory empty.  Skipping test and continuing."
    else
	filename=`pick_random_files 1 $filelist`
	basename=`basename $filename`
	pnfsname=`echo ${PNFS_OUTPUT_DIR}/$basename`
	cleanup="$pnfsname `get_lock_file_name $filename`"
	encp="$encp_cmd --resubmit-timeout 0 --max-resubmit 0"
	
	#See if the transfer fails.
	transfer "$encp" "$filename" "$pnfsname" "$cleanup" "" "$section" WRITE 1

	cleanup_files '$cleanup'
    fi
}
