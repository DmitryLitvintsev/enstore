#!/bin/bash --posix
# Include --posix which looks to be necessary, on Linux anyway, to
# not read in the .bashrc file again where the PNFS_DIR and LOCAL_DIR
# variables are possibly set.

# $Id$

#Main script to run encp regression tests.
#
# Requires $ENSTORE_DIR/tools/encp_test_functions and
# $ENSTORE_DIR/tools/encp_create_tests to work.
# 
# Requires $LOCAL_DIR and $PNFS_DIR to be set.

print_help()
{
    echo "USAGE: `basename $0` [-h | -d | -e <encp_path>] [<test_name1> [test_name2] ...]"
    echo "    -h               Print this help."
    echo "    -e <encp_path>   Specifiy the encp to use for the tests."
    echo "    -d               Increase the debugging output."
}

#LOCAL_DIR is set by the user in their environment.
if [ -z "$LOCAL_DIR" ]; then
    echo "\$LOCAL_DIR not set.  Stopping test." 1>&2
    exit 1
fi
if [ ! -d "$LOCAL_DIR" ]; then
    echo "$LOCAL_DIR does not exist.  Stopping test." 1>&2
    exit 1
fi
#PNFS_DIR is set by the user in their environment.
if [ -z "$PNFS_DIR" ]; then
    echo "\$PNFS_DIR not set.  Stopping test." 1>&2
    exit 1
fi
if [ ! -d "$PNFS_DIR" ]; then
    echo "$PNFS_DIR does not exist.  Stopping test." 1>&2
    exit 1
fi

#Note: REMOTE_ENCP is an environmental variable that tells encp to use
# pnfs_agent instead of PNFS directly.  We check for the same variable here to
# handle running these tests through the pnfs agent too.

if [ -n "$REMOTE_ENCP" ]; then
    enstore pnfs_agent --timeout 10 --retries 3 --alive
    if [ $? -ne 0 ]; then
        echo 'pnfs_agent is not running and $REMOTE_ENCP is set.' \
             'Stopping test.' 1>&2
        exit 1
    fi
fi

verbose="--verbose 9"

alias ls > /dev/null 2>&1
if [ $? -eq 0 ]; then
    unalias ls 2> /dev/null   #We want the default ls behavior.
fi

source encp_test_functions

#These variables are possibily overridden with command line arguments.
encp_command=`which encp`
debug=0

#Parse any command line arguments.
#
# encp_cmd and debug are used in encp_test_functions function transfer().
# 
while getopts dhe: option; do
    case "$option"
    in
        e) encp_cmd=`which $OPTARG`;;  #Use which to force absolute path.
	h) print_help; exit 0;;
	d) debug=`expr $debug + 1`;;
    esac
done

#Clear any switches from the argument list so that we can continue processing
# all arguments on the command line.
shift `expr $OPTIND - 1`

#If the number of arguments, $#, is zero run all the tests.
if [ $# -eq 0 ]; then
    single_read_test=`expr 1`
    single_read_write_test=`expr 1`
    multiple_read_write_test=`expr 1`
    dcache_read_write_test=`expr 1`
    non_conf_read_write_test=`expr 1`
    setuid_read_write_test=`expr 1`
    single_threaded_read_write_test=`expr 1`
    multiple_threaded_read_write_test=`expr 1`
    single_ecrc_read_write_test=`expr 1`
    single_assert_test=`expr 1`
    ensync_test=`expr 1`
    single_relative_path_read_write_test=`expr 1`
    single_local_pnfs_path_read_test=`expr 1`
    single_no_brand_read_test=`expr 1`
    volume_read_test=`expr 1`
    single_fs_path_read_test=`expr 1`
    data_access_layer_read_write_test=`expr 1`
    multiple_copies_read_write_test=`expr 1`
    pnfs_agent_read_write_test=`expr 1`
    pipe_write_test=`expr 1`
    source_file_does_not_exist_write_test=`expr 1`
    library_does_not_exist_write_test=`expr 1`
    too_many_resubmits_write_test=`expr 1`
else
    single_read_test=`expr 0`
    single_read_write_test=`expr 0`
    multiple_read_write_test=`expr 0`
    dcache_read_write_test=`expr 0`
    non_conf_read_write_test=`expr 0`
    setuid_read_write_test=`expr 0`
    single_threaded_read_write_test=`expr 0`
    multiple_threaded_read_write_test=`expr 0`
    single_ecrc_read_write_test=`expr 0`
    single_assert_test=`expr 0`
    ensync_test=`expr 0`
    single_relative_path_read_write_test=`expr 0`
    single_local_pnfs_path_read_test=`expr 0`
    single_no_brand_read_test=`expr 0`
    volume_read_test=`expr 0`
    single_fs_path_read_test=`expr 0`
    data_access_layer_read_write_test=`expr 0`
    multiple_copies_read_write_test=`expr 0`
    pnfs_agent_read_write_test=`expr 0`
    pipe_write_test=`expr 0`
    source_file_does_not_exist_write_test=`expr 0`
    library_does_not_exist_write_test=`expr 0`
    too_many_resubmits_write_test=`expr 0`

    for switch in $*; do
	if [ "single_read_test" = $switch ]; then
	    single_read_test=`expr 1`
	fi
	if [ "single_read_write_test" = $switch ]; then
	    single_read_write_test=`expr 1`
	fi
	if [ "multiple_read_write_test" = $switch ]; then
	    multiple_read_write_test=`expr 1`
	fi
	if [ "dcache_read_write_test" = $switch ]; then
	    dcache_read_write_test=`expr 1`
	fi
	if [ "non_conf_read_write_test" = $switch ]; then
	    non_conf_read_write_test=`expr 1`
	fi
	if [ "setuid_read_write_test" = $switch ]; then
	    setuid_read_write_test=`expr 1`
	fi
	if [ "single_threaded_read_write_test" = $switch ]; then
	    single_threaded_read_write_test=`expr 1`
	fi
	if [ "multiple_threaded_read_write_test" = $switch ]; then
	    multiple_threaded_read_write_test=`expr 1`
	fi
	if [ "single_ecrc_read_write_test" = $switch ]; then
	    single_ecrc_read_write_test=`expr 1`
	fi
	if [ "single_assert_test" = $switch ]; then
	    single_assert_test=`expr 1`
	fi
	if [ "ensync_test" = $switch ]; then
	    ensync_test=`expr 1`
	fi
	if [ "single_relative_path_read_write_test" = $switch ]; then
	    single_relative_path_read_write_test=`expr 1`
	fi
	if [ "single_local_pnfs_path_read_test" = $switch ]; then
	    single_local_pnfs_path_read_test=`expr 1`
	fi
	if [ "single_no_brand_read_test" = $switch ]; then
	    single_no_brand_read_test=`expr 1`
	fi
	if [ "volume_read_test" = $switch ]; then
	    volume_read_test=`expr 1`
	fi
	if [ "single_fs_path_read_test" = $switch ]; then
	    single_fs_path_read_test=`expr 1`
	fi
	if [ "data_access_layer_read_write_test" = $switch ]; then
	    data_access_layer_read_write_test=`expr 1`
	fi
	if [ "multiple_copies_read_write_test" = $switch ]; then
	    multiple_copies_read_write_test=`expr 1`
	fi
	if [ "pnfs_agent_read_write_test" = $switch ]; then
	    pnfs_agent_read_write_test=`expr 1`
	fi
	if [ "pipe_write_test" = $switch ]; then
	    pipe_write_test=`expr 1`
	fi
	if [ "source_file_does_not_exist_write_test" = $switch ]; then
	    source_file_does_not_exist_write_test=`expr 1`
	fi
	if [ "library_does_not_exist_write_test" = $switch ]; then
	    library_does_not_exist_write_test=`expr 1`
	fi
	if [ "too_many_resubmits_write_test" = $switch ]; then
	    too_many_resubmits_write_test=`expr 1`
	fi
    done
fi

###
### SINGLE READ TEST
###
if [ $single_read_test -eq 1 ]; then
    single_read_test
fi

###
### SINGLE READ & WRITE TEST
###
if [ $single_read_write_test -eq 1 ]; then
    single_read_write_test
fi

###
### MULITPLE READ & WRITE TEST
###
if [ $multiple_read_write_test -eq 1 ]; then
    multiple_read_write_test
fi

###
### DCACHE READ & WRITE TEST
###
if [ $dcache_read_write_test -eq 1 ]; then
    dcache_read_write_test
fi


###
### NON-CONF READ & WRITE TEST
###
if [ $non_conf_read_write_test -eq 1 ]; then
    non_conf_read_write_test
fi


###
### SETUID READ & WRITE TEST
###
#if [ $setuid_read_write_test -eq 1 ]; then
#    setuid_read_write_test
#fi


###
### SINGLE THREADED READ & WRITE TEST
###
if [ $single_threaded_read_write_test -eq 1 ]; then
    single_threaded_read_write_test
fi


###
### MULITPLE THREDED READ & WRITE TEST
###
if [ $multiple_threaded_read_write_test -eq 1 ]; then
    multiple_threaded_read_write_test
fi


###
### SINGLE ECRC READ & WRITE TEST
###
if [ $single_ecrc_read_write_test -eq 1 ]; then
    single_ecrc_read_write_test
fi


###
### SINGLE ASSERT TEST
###
if [ $single_assert_test -eq 1 ]; then
    single_assert_test
fi


###
### ENSYNC TEST
###
if [ $ensync_test -eq 1 ]; then
    ensync_test
fi

###
### SINGLE RELATIVE PATH READ WRITE TEST
###
if [ $single_relative_path_read_write_test -eq 1 ]; then
    single_relative_path_read_write_test
fi

###
### SINGLE LOCAL PNFS PATH READ WRITE TEST
###
if [ $single_local_pnfs_path_read_test -eq 1 ]; then
    single_local_pnfs_path_read_test
fi

###
### SINGLE NO BRAND READ TEST
###
if [ $single_no_brand_read_test -eq 1 ]; then
    single_no_brand_read_test
fi

###
### VOLUME READ TEST
###
if [ $volume_read_test -eq 1 ]; then
    volume_read_test
fi

###
### SINGLE FS PATH READ TEST
###
if [ $single_fs_path_read_test -eq 1 ]; then
    single_fs_path_read_test
fi

###
### DATA ACCESS LAYER READ WRITE TEST
###
if [ $data_access_layer_read_write_test -eq 1 ]; then
    data_access_layer_read_write_test
fi

###
### MULTIPLE COPES READ WRITE TEST
###
if [ $multiple_copies_read_write_test -eq 1 ]; then
    multiple_copies_read_write_test
fi

###
### PNFS AGENT READ WRITE TEST
###
if [ $pnfs_agent_read_write_test -eq 1 ]; then
    pnfs_agent_read_write_test
fi

###
### PIPE WRITE TEST
###
if [ $pipe_write_test -eq 1 ]; then
    #pipe_write_test
    # Skip the pipe write test until the library manager supports it.
    echo "Skipping Pipe Write Test"
fi

###
### SOURCE FILE DOES NOT EXIST WRITE TEST
###
if [ $source_file_does_not_exist_write_test -eq 1 ]; then
    source_file_does_not_exist_write_test
fi

###
### LIBRARY DOES NOT EXIST WRITE TEST
###
if [ $library_does_not_exist_write_test -eq 1 ]; then
    library_does_not_exist_write_test
fi

###
### TOO MANY RESUBMITS READ TEST
###
if [ $too_many_resubmits_write_test -eq 1 ]; then
    too_many_resubmits_write_test
fi
