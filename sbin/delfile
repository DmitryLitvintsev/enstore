#!/bin/sh
set -u  # force better programming and ability to use check for not set
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

# sbin/$RCSfile$  $Revision$

# check for ENSTORE_DIR being setup
if [ -z "${ENSTORE_DIR-}" ]; then
  echo "ENSTORE is not setup - trying to setup..."
  . /usr/local/etc/setups.sh
  setup enstore
fi

# if we are called with no arguments, then assume we need to search for deleted files
if [ -z "${1-}" ] ; then

  # specify where pnfs puts its trash
  if [ -z "${TRASH_CAN-}" ]; then
    TRASH_CAN=/rip6a/pnfs/trash/4
    export TRASH_CAN
  fi
  ACTIVE=$TRASH_CAN/ACTIVE
  
  # see if any other delfiles are active - use the DESY technique of creating a directory as lock file
  mkdir $ACTIVE 1>/dev/null 2>/dev/null
  if [ $? -ne 0 ];then
    #echo "Can not make $ACTIVE - another delfile must be active"
    exit 1
  fi

  # find all the deleted files from pnfs
  find $TRASH_CAN -type f -exec $ENSTORE_DIR/sbin/delfile {} \;

  # finally get rid of all active lock
  rmdir $ACTIVE   >/dev/null 2>&1


# if we are called with an argument, then assume we are supposed to flag a file as deleted
else

  # make sure we can read the file, and then store its contents
  if [ -r "$1" ] ; then
    a=`cat $1`
  else
    echo "$1 is not readable"
    exit 2
  fi

  # the bfid is the 9th element in the file
  bfid=`echo $a | awk '{print $9}'`
  if [ $? -ne 0 ]; then
    echo "Can not get the bfid from $1"
    echo "$a"
    exit 1
  fi

  # flag the file as deleted
  cmd="enstore file --bfid=$bfid --deleted=yes"
  #echo "$cmd"
  eval $cmd

  # if it worked, then delete the trash file so we don't keep repeating
  if [ $? -ne 0 ]; then
    echo "Can not set bfid $bfid deleted from $1"
    echo "$a"
    echo "$cmd"
    exit 1
  else
    rm $1
    if [ $? -ne 0 ]; then
       echo "Can not delete the file $1"
       exit 1
    fi
  fi

fi

exit 0
