#!/usr/bin/env bash
set -u  # force better programming and ability to use check for not set

if [ "${1:-}" = "-x" ]; then set -xv; shift; fi

# this is cheap argument processing. Must be in this order when checking.
if [ "${1:-}" = "-a" ]; then ALARM=1; shift; else ALARM=0; fi
if [ "${1:-}" = "-q" ]; then QUIET=1; shift; else QUIET=0; fi
if [ "${1:-}" = "-i" ]; then IPMI=0; shift; else IPMI=1; fi

set +u
. /usr/local/etc/setups.sh
setup enstore
set -u

# Things checked:
# . Correct configuration files
# . Correct authorization files
# . Check that ngop is installed and running
# . Check enstore scripts in /etc/rc.d/init.d
# . Check that eth1 is working (if present)
# . Correct ntp time sync (allow * and ~ on 1st line)
## . Check that two processors are active
## . Check that mounted disks are less than 90% full
# . Check that root crontab includes reset of watchdog, netscan, and ntpset
# . Check that rc.local contains boot_cleanup
# . Check that enstore and root .forward files contain enstore-admin@fnal.gov
# . Check that ipmisrv is running and has NO_DOG option
# . Check that watchdog timer action is to do nothing
# . Check that there are less than N processes running on the node
# . Check for correct number of pnfs daemons running on servers
# . Check database sizes on pnfs servers (srv1 nodes)
# . Check the largest of today's log files on srv2 nodes
## . If file or volume clerk are running, then db_checkpoint and db_deadlock are running, too
# . Check that web servers are running on right nodes and not elsewhere
# . Check cgi scripts on web server nodes
# . Check the /etc/krb5.keytab and /local/ups/kt/enstorekt files for legal values
# . Look for "lost" files in mounted local file systems
# . Look for local files hidden behind nfs mount points
# . Check for open LISTEN sockets
## . Check that /etc/cron.* directories match the base farmlet
# . Check that the farmlets directory matches the base farmlet

# Known vunerabilities:
# . I know I don't check everything!
# . Only check for LISTEN, ignoring TCP and UDP for now.
#        TCP could be done, but UDP seems very hard (sh, mt... open lots of sockets!).
# . Require connection to live across a ps, so I can get the process name for later checks
# . Depend on installed version of os (grep, lsof...)
#        Should download a static version each time.
# . Swapped out versions of jobs with open connections - allowed, not checked.
#        Should look into the proc file system to get cmdline and check that.
#        Should also buy more memory to make sure nothing is swapped out.
# . Allow all tasks run from enstore/bin or enstore/src
#        Should check for individual applications
# . RPM - could be modified
#        Too many exceptions in rpm -Va to be useful...

# List of binaries/scripts used in checking.
# In principle, these should be loaded onto the machine each time to prevent hacker tampering
DF="/bin/df"
LS="/bin/ls"
PS="/bin/ps"
AWK="/bin/awk"
SED="/bin/sed"
RPM="/bin/rpm"
ECHO="/bin/echo"
KILL="/bin/kill"
DATE="/bin/date"
GREP="/bin/grep"
SORT="/bin/sort"
CHMOD="/bin/chmod"
CHOWN="/bin/chown"
EGREP="/bin/egrep"
MKDIR="/bin/mkdir"
SLEEP="/bin/sleep"
HOSTNAME="/bin/hostname"
DU="/usr/bin/du"
TR="/usr/bin/tr"
WC="/usr/bin/wc"
CMP="/usr/bin/cmp"
if [ -x /usr/bin/cut ]; then
  CUT="/usr/bin/cut"
elif [ -x /bin/cut ]; then
  CUT="/bin/cut"
else
  $ECHO "Can not find cut"
  exit 1
fi
TAIL="/usr/bin/tail"
UNIQ="/usr/bin/uniq"
if [ -x /usr/local/bin/lsof ]
then
    LSOF="/usr/local/bin/lsof"
else
    LSOF="/usr/sbin/lsof"
fi
IFUP="/etc/sysconfig/network-scripts/ifup"
IFDOWN="/etc/sysconfig/network-scripts/ifdown"

OCTAL="printf 0%o"

FARMLETS="$ENSTORE_DIR/sbin/farmlets"
KEYTAB_CHECK="$ENSTORE_DIR/sbin/keytab_check"

LOG=/tmp/netscan.log
ACTIVE=/root/CRON/netscanACTIVE

node=`$HOSTNAME -s`
gang=`$ENSTORE_DIR/sbin/gang`


# convert uptime to units of our scheduling interval (15 minutes)
let uptime=`$CUT -d. -f1 /proc/uptime`/900

# did we just reboot?
if [ $uptime -eq 0 ]
then
  REBOOT=1
else
  REBOOT=0
fi

# are we a server?
if $ECHO $node | $GREP srv >/dev/null
then
  SERVER=1
else
  SERVER=0
fi

# once a day, or after reboot, override quiet mode and log verbose information
[ $((uptime % 97)) -eq 0 ] && QUIET=0

# function to log messages, optionally print the ps state
logit() { $ECHO `$DATE` "$1" >>$LOG 2>&1
	  if [ "${2:-}"x = psx ]; then
	     $ECHO "${PSfirst:-}" >>$LOG 2>&1
	  fi
	  $ECHO "$1"
	}

# function to check the owner of a file or directory
check_owner() { local theUsr=${2:-enstore}
		local theGrp=${3:-$theUsr}
		if [ ! -r $1 ]; then
		  msg1="BAD CONFIGURATION: $1 does not exist"
		  logit "$msg1"
		  if [ $ALARM -eq 1 ]; then
		     enstore alarm --raise --severity "A" --root-error "$msg1"
		  fi
		else
		  local theOwn=${theUsr}.${theGrp}
		  local chkOwn=`$LS -ld $1 | $AWK '{print $3"."$4}'`
		  # /etc/group doesn't always contain "products"
		  if [ "${chkOwn/%.4525/.products}" != "${theOwn/%.4525/.products}" ]; then
		     [ -e /PRODUCTION ] && $CHOWN "${theOwn/%.products/.4525}" $1
		     msg1="BAD CONFIGURATION: Changing $1 owner ($chkOwn to $theOwn)"
		     logit "$msg1"
		     if [ $ALARM -eq 1 -a -e /PRODUCTION ]; then
			enstore alarm --raise --severity "I" --root-error "$msg1"
		     fi
		  elif [ $QUIET -ne 1 ]; then
		     logit "$1 owner is $theOwn, ok"
		  fi
		fi
	      }

# function to parse file mode from terse output of stat(1)
getfilemode() { set `stat -t $1 2>/dev/null`
		if [ $# -eq 15 ]; then
		   # 0x8000 => regular file
		   $OCTAL $((0x$4 & 0777))
		else
		   # probably an older stat, w/o -t option
		   $ECHO "$9" | $CUT -f2 -d\( | $CUT -f1 -d/
		fi
	      }

# function to check the mode of a file or device
#
# Note that the mode argument must be in octal, with a leading
# 0 (for example, 0755).
#
# Also check file owner against 3rd and 4th arguments, if present,
# or confirm that files under /, /etc or /root are owned by root.
check_mode() { if [ ! -r $1 ]; then
		 msg1="BAD CONFIGURATION: $1 does not exist"
		 logit "$msg1"
		 if [ $ALARM -eq 1 ]; then
		    enstore alarm --raise --severity "A" --root-error "$msg1"
		 fi
	       else
		 local fmode=`getfilemode $1`
		 if [ $((fmode)) -ne $(($2)) ]; then
		    [ -e /PRODUCTION ] && $CHMOD $2 $1
		    msg1="BAD CONFIGURATION: Changing $1 mode ($fmode to $2)"
		    logit "$msg1"
		    if [ $ALARM -eq 1 -a -e /PRODUCTION ]; then
		       enstore alarm --raise --severity "I" --root-error "$msg1"
		    fi
		 else
		    if [ $QUIET -ne 1 ]; then
		       logit "$1 mode is $2, ok"
		    fi
		    if [ $# -eq 3 ]; then
		       check_owner $1 $3
		    elif [ $# -eq 4 ]; then
		       check_owner $1 $3 $4
		    elif dirname $1 | $EGREP '^/($|etc|root)' >/dev/null; then
		       check_owner $1 root
		    fi
		 fi
	       fi
	     }

# function to check for a string within a file
#
# Also confirm that files under /, /etc or /root are owned by
# root, and check file mode against 3rd argument, if present.
# Note that the 3rd argument, if specified, must be in octal,
# with a leading 0 (for example, 0755).
check_file() { local theFile=${2:-/var/spool/cron/root}
	       if [ ! -r "$theFile" ]; then
		  msg1="BAD CONFIGURATION: $theFile is missing"
		  logit "$msg1"
		  if [ $ALARM -eq 1 ]; then
		     enstore alarm --raise --severity "A" --root-error "$msg1"
		  fi
	       elif ! $EGREP "$1" "$theFile" >/dev/null; then
		  msg1="BAD CONFIGURATION: $theFile is missing $1"
		  logit "$msg1"
		  if [ $ALARM -eq 1 ]; then
		     enstore alarm --raise --severity "A" --root-error "$msg1"
		  fi
	       else
		  if [ $QUIET -ne 1 ]; then
		     logit "$1 in $theFile, ok"
		  fi
		  if [ $# -eq 3 ]; then
		     check_mode "$theFile" $3
		  elif dirname "$theFile" | $EGREP '^/($|etc|root)' >/dev/null; then
		     check_owner "$theFile" root
		  fi
	       fi
	     }

# function to compare files and complain if they are not the same
#
# Also confirm that files under /, /etc or /root are owned by
# root, and check file mode against 3rd argument, if present.
# Note that the 3rd argument, if specified, must be in octal,
# with a leading 0 (for example, 0755).
right_file() { local src=$1; local dst=$2
	       [ -d $dst ] && dst=$dst/`basename $src`
	       if [ ! -r $src -o ! -r $dst ]; then
		  msg1="BAD CONFIGURATION: $src $dst do not both exist"
		  logit "$msg1"
		  if [ $ALARM -eq 1 ]; then
		     enstore alarm --raise --severity "A" --root-error "$msg1"
		  fi
	       elif ! $CMP $src $dst 2>/dev/null; then
		  msg1="BAD CONFIGURATION: $src $dst do not match"
		  logit "$msg1"
		  if [ $ALARM -eq 1 ]; then
		     enstore alarm --raise --severity "A" --root-error "$msg1"
		  fi
	       else
		  if [ $QUIET -ne 1 ]; then
		     logit "$dst matches $src, ok"
		  fi
		  if [ $# -eq 3 ]; then
		     check_mode $dst $3
		  elif dirname $dst | $EGREP '^/($|etc|root)' >/dev/null; then
		     check_owner $dst root
		  fi
	       fi
	     }

# function to check for allowed services and complain if not allowed
#
#   This function uses the rules in $ALLOW, which must be defined with no embedded
#   spaces (substitute # for a space). Each rule is terminated by a newline (\n).
#   The loop is limited to rules that meet the first 4 of the 5 requirements in
#   each rule. There may be more than one such rule. If there is at least one, and
#   they all fail, that is a "type 1" error; if there are none, that is a "type 2"
#   error.
#
allow() { tt=${1:-UNKNOWN}
	  local psline=""
	  for i in `$ECHO -e -n $ALLOW | $AWK -F, -v TT=$tt -v CMD=$command -v REST="$rest" '$1 ~ TT && $2 == CMD && REST ~ $3 && REST ~ $4 {print "a=\"" $2 "\";b=\"" $3 "\";c=\"" $4 "\";p=\"" $5 "\""}'`
	  do
	    eval $i
	    if [ $p != x ]; then
	       if [ -z "$psline" ]; then
		  psline=`$ECHO "$PSfirst" | $AWK -v PID=$pid '$2 ~ PID {print}'`
	       fi
	       if [ `$ECHO $psline | $EGREP -c '\[.*\]'` -ne 0 ]; then
		  logit "Swapped out $node $tt $command $pid $rest -> $psline"
		  return 0
	       elif [ `$ECHO $psline | $SED 's/  */#/g' | $EGREP -c "$p"` -eq 0 ]; then
		  continue
	       fi
	    else
	      p=""
	    fi
	    if [ $QUIET -ne 1 ]; then
	      logit "Allowing $node $c $tt $a $b $p, ok"
	    fi
	    return 0
	  done
	  if [ -n "$psline" ]; then
	     type=1
	  else
	     psline=`$ECHO "$PSfirst" | $AWK -v PID=$pid '$2 ~ PID {print}'`
	     type=2
	  fi
	  msg1="UNAUTHORIZED NETWORK SERVICE, type ${type}! $node $tt $command $pid $rest"
	  logit "$msg1 $psline" "ps"
	  if [ $ALARM -eq 1 ]; then
	    enstore alarm --raise --severity "A" --root-error "$msg1 $psline"
	  fi
	  return $type
	 }

if [ -r "/etc/inetd.conf" ]; then
       INETD=inetd
elif [ -r "/etc/xinetd.conf" ]; then
       INETD=xinetd
else
       INETD=unknown
fi
# We allow these everywhere
ALLOW_BASE="
	LISTEN,$INETD,:(ftp|kshell|klogin|telnet|eklogin|netperf),TCP,x\n
	LISTEN,python,:,TCP,$ENSTORE_DIR/(bin|src)|/home/petravic/Zope|ftpcp.py\n
	LISTEN,dccp,:,TCP,x\n
	LISTEN,netserver,:,TCP,x\n
	LISTEN,portmap,:sunrpc,TCP,x\n
	LISTEN,rsh,:,TCP,/usr/krb5/bin/rsh\n
	LISTEN,sh,inet,TCP,MSG_TYPE|enstore\n
	LISTEN,mv,inet,TCP,MSG_TYPE|enstore\n
	LISTEN,grep,inet,TCP,MSG_TYPE|enstore\n
	LISTEN,sort,inet,TCP,MSG_TYPE|enstore\n
	LISTEN,ALARM_CLIENT,inet,TCP,x\n
	TCP,xemacs,:x11,TCP,x\n
	TCP,rsh,:kshell,TCP,x\n
	TCP,rsh,:,TCP,/usr/krb5/bin/rsh\n
	TCP,kshd,:kshell,TCP,x\n
	TCP,kshd,:,TCP,kshd#kshd#-5c\n
	TCP,klogind,:eklogin,TCP,x\n
	TCP,telnetd,:telnet,TCP,telnetd#-Pa#valid\n
	TCP,netserver,TCP,:netperf,x\n
	TCP,python,:,TCP,$ENSTORE_DIR/(bin/encp|src/(encp|monitor_server).py)\n
	UDP,python,:,UDP,$ENSTORE_DIR/(bin/encp|src/(encp|monitor_server|volume_assert).py|ngop/cronjobAgent.py)\n
	UDP,python,:7499,UDP,$ENSTORE_DIR/src/monitor_server.py\n
	UDP,xntpd,:ntp,UDP,x\n
	UDP,portmap,:sunrpc,UDP,x\n
	UDP,tee,:,UDP,tee#/dev/tty\n
"

# Extra for console servers
ALLOW_CONS="$ALLOW_BASE
	LISTEN,conserver,:console,TCP,x\n
	LISTEN,conserver,:,TCP,conserver#-d\n
	LISTEN,X,:x11,TCP,x\n
	TCP,console,:console,TCP,x\n
"

# Extra for srv3 - console + nfs server + pagedcache
ALLOW_SRV3="$ALLOW_CONS
	LISTEN,rpc.mount,:,TCP,rpc.mountd\n
	LISTEN,rpc.nfsd,:(nfs|2049),TCP,x\n
	LISTEN,java,:,TCP,java#-cp\n
	UDP,rpc.mount,:mount,UDP,x\n
	UDP,rpc.nfsd,:(nfs|2049),UDP,x\n
"

# Extra for srv2 - web server
ALLOW_SRV2="$ALLOW_BASE
	LISTEN,httpd,:http,TCP,/local/ups/prd/apache/\n
	LISTEN,mv,(d0|stk|cdf)ensrv2.fnal.gov:,TCP,mv\n
	LISTEN,sh,(d0|stk|cdf)ensrv2.fnal.gov:,TCP,sh\n
	LISTEN,grep,(d0|stk|cdf)ensrv2.fnal.gov:,TCP,grep\n
	LISTEN,sort,(d0|stk|cdf)ensrv2.fnal.gov:,TCP,sort\n
	LISTEN,python,(d0|stk|cdf)ensrv2.fnal.gov:,TCP,$ENSTORE_DIR/src/inquisitor.py\n
"
#	LISTEN,sendmail,:smtp,TCP,x\n

# Extra for srv1 - pnfs server
ALLOW_SRV1="$ALLOW_BASE
	LISTEN,java,:,TCP,/home/enstore/dcache/run|[java]\n
"

# Extra for postgres db servers
ALLOW_PGDB="$ALLOW_BASE
	LISTEN,postmaste,:(postgres|5432|8076|8888),TCP,x\n
"

# Extra for adic
ALLOW_ADIC="$ALLOW_BASE
	LISTEN,dasadmin,:663,TCP,x\n
	LISTEN,dasadmin,:,TCP,dasadmin\n
"

# Extra for d0ensrv4 - makes stk and adic calls
ALLOW_DSRV4="$ALLOW_ADIC
	LISTEN,rsh,:,TCP,fntt#-l#acsss#echo\n
	LISTEN,rsh,:,TCP,-l#acsss#fntt#echo\n
"

# Extra for d0ensrv3
ALLOW_DSRV3="$ALLOW_SRV3
	LISTEN,perl,d0ensrv3p.fnal.gov:,TCP,mirror#everything:adic2.fnal.gov\n
"

# Extra for d0ensrv2
ALLOW_DSRV2="$ALLOW_SRV2
	LISTEN,mirror,d0ensrv2p.fnal.gov:,TCP,mirror#logs:adic2.fnal.gov\n
"

# Extra for stkensrv4 - makes stk and adic calls
ALLOW_SSRV4="$ALLOW_ADIC
	LISTEN,rsh,:,TCP,fntt#-l#acsss#echo\n
	LISTEN,rsh,:,TCP,-l#acsss#fntt#echo\n
"

# Extra for stkensrv2 - nfs server
ALLOW_SSRV2="$ALLOW_SRV2
	LISTEN,rpc.mount,:,TCP,rpc.mountd\n
	LISTEN,rpc.nfsd,:(nfs|2049),TCP,x\n
	UDP,rpc.mount,:mount,UDP,x\n
	UDP,rpc.nfsd,:(nfs|2049),UDP,x\n
"

# Extra for cdfensrv4 - makes stk calls
ALLOW_CSRV4="$ALLOW_BASE
	LISTEN,rsh,:,TCP,fntt2#-l#acsss#echo\n
	LISTEN,rsh,:,TCP,-l#acsss#fntt2#echo\n
"

# Extra for movers
ALLOW_MVR="$ALLOW_BASE
	LISTEN,python,:,TCP,$ENSTORE_DIR/src/mover.py\n
	TCP,python,:,TCP,$ENSTORE_DIR/src/mover.py\n
	UDP,python,:,UDP,$ENSTORE_DIR/src/mover.py\n
"

# Extra for dcache
# Allowing swapped out java's is not good, but I don't know what else to do right now.
ALLOW_DCA="$ALLOW_BASE
	LISTEN,httpd,:http,TCP,/local/ups/prd/apache/\n
	LISTEN,java,:,TCP,/home/enstore/dcache/run/diskCache|[java]|dmg.cells.services.Domain\n
"

# make the choice
case $node in
       *srv0|rip1) ALLOW=$ALLOW_PGDB;  logit "Comparing to srv0";;
       *srv1|rip6) ALLOW=$ALLOW_SRV1;  logit "Comparing to srv1";;
    d0ensrv2)      ALLOW=$ALLOW_DSRV2; logit "Comparing to d0ensrv2";;
   stkensrv2)      ALLOW=$ALLOW_SSRV2; logit "Comparing to stkensrv2";;
       *srv2|rip7) ALLOW=$ALLOW_SRV2;  logit "Comparing to srv2";;
    d0ensrv3)      ALLOW=$ALLOW_DSRV3; logit "Comparing to d0ensrv3";;
       *srv3)      ALLOW=$ALLOW_SRV3;  logit "Comparing to srv3";;
    d0ensrv4)      ALLOW=$ALLOW_DSRV4; logit "Comparing to d0ensrv4";;
   stkensrv4)      ALLOW=$ALLOW_SSRV4; logit "Comparing to stkensrv4";;
   cdfensrv4)      ALLOW=$ALLOW_CSRV4; logit "Comparing to cdfensrv4";;
    *srv[57])      ALLOW=$ALLOW_CONS;  logit "Comparing to srv5";;
       *srv6)      ALLOW=$ALLOW_PGDB;  logit "Comparing to srv6";;
       *mvr*|rip*) ALLOW=$ALLOW_MVR;   logit "Comparing to mvr";;
       *dca*)      ALLOW=$ALLOW_DCA;   logit "Comparing to dca";;
	   *)      ALLOW=$ALLOW_BASE;  logit "Comparing to base";;
esac


# try to start - but if one netscan already running, then exit
$MKDIR $ACTIVE 1>/dev/null 2>/dev/null
if [ $? -ne 0 ]; then
   # ok, this is terrible..., but I don't know what else to do.  Dang kerberos!
   # the most likely thing that has failed, or hung is the task that access the net.  Kill it.
   # kill the farmlets task
   $PS axwww | $GREP "farmlets" | $GREP -v grep | while read pid line
   do
      $ECHO `$DATE` $KILL -9 $pid $line >>$LOG 2>&1
      $ECHO $KILL -9 $pid $line
      $KILL -9 $pid
   done
   $SLEEP 30
   # kill any remaining rsyncs that check the cron area
   $PS axwww | $EGREP "farmlets|rsync" | $GREP -v grep | $GREP cron | while read pid line
   do
      $ECHO `$DATE` $KILL -9 $pid $line >>$LOG 2>&1
      $ECHO $KILL -9 $pid $line
      $KILL -9 $pid
   done
   $SLEEP 30
   $MKDIR $ACTIVE 1>/dev/null 2>/dev/null
   if [ $? -ne 0 ] ; then
     msg="ERROR: netscan on $node already ACTIVE... exiting"
     logit "$msg"
     if [ $ALARM -eq 1 ]; then
	enstore alarm --raise --severity "A" --root-error "$msg"
     fi
     exit 1
   else
     logit "netscan starting"
   fi
else
  logit "netscan starting"
fi

# make this a dry run if we are not a production node
[ -e /PRODUCTION ] || logit "Dry Run - bad file attributes will not be corrected"


#generate an informational alarm if we detect a server has rebooted
if [ $REBOOT -eq 1 -a $SERVER -eq 1 ]
then
  msg="Server $node has rebooted"
  logit "$msg"
  if [ $ALARM -eq 1 ]; then
     enstore alarm --raise --severity "I" --root-error "$msg"
  fi
fi

# check these files
right_file $ENSTORE_DIR/sbin/routes			/root/routes
right_file $ENSTORE_DIR/sbin/gettkt			/home/enstore/gettkt
right_file $ENSTORE_DIR/etc/root.k5login		/root/.k5login
right_file $ENSTORE_DIR/etc/$gang.enstore.k5login	/home/enstore/.k5login
right_file $ENSTORE_DIR/etc/$gang.hosts.allow		/etc/hosts.allow
right_file $ENSTORE_DIR/etc/hosts.deny			/etc/hosts.deny
right_file $ENSTORE_DIR/etc/hosts			/etc/hosts
right_file $ENSTORE_DIR/etc/sudoers			/etc/sudoers		0440
right_file $ENSTORE_DIR/etc/krb5.conf			/etc/krb5.conf		0644
right_file $ENSTORE_DIR/etc/xserverrc			/etc/X11/xinit		0755
right_file $ENSTORE_DIR/bin/enstore-boot		/etc/rc.d/init.d	0755
right_file $ENSTORE_DIR/bin/monitor_server-boot		/etc/rc.d/init.d	0755

# check these files only on db server nodes
case $node in
  d0ensrv6|stkensrv6|cdfensrv6)
    right_file $ENSTORE_DIR/sbin/enstore-drivestat	/etc/rc.d/init.d	0755
    right_file $ENSTORE_DIR/sbin/enstore-pgdb		/etc/rc.d/init.d	0755
    ;;
  d0ensrv0|stkensrv0|cdfensrv0)
    right_file $ENSTORE_DIR/sbin/enstore-db		/etc/rc.d/init.d	0755
    ;;
  *)
    ;;
esac

for x in /etc/rc.d/rc.{sysinit,local} /var/log/sa
do
  check_mode $x			0755
done

if [ -e /PRODUCTION ]
then
  check_mode /PRODUCTION	0644
fi

if $ECHO $node | $EGREP '^(d0|stk|cdf)en(srv[0-9]|mvr[1-9][0-9]?a)$' >/dev/null
then

  # check ups and product support
  check_file	"/local/ups/db"		/local/ups/etc/upsdb_list
  check_mode	/local/ups/etc/upsdb_list	0664	products
  check_mode	/local/ups/.k5login		0664	products
  for f in $PRODUCTS/.upsfiles/{startup,shutdown}/${node}.products
  do
    check_file	"(start|stop)[[:space:]]+"	$f
    check_mode	$f				0755	products
  done
# right_file	$UPS_DIR/init.d/ups	/etc/rc.d/init.d/ups		0755

  # check ngop configuration directories
  for x in /var/ngop{,/include,/cron_agent,/plugins_agent}
  do
    check_mode	$x				0755	root
  done

  # check ngop configuration files
  for i in $ENSTORE_DIR/ngop/check*.py
  do
    right_file	$i					/var/ngop/include		0644
  done
  right_file	$ENSTORE_DIR/ngop/raise_enstore_alarm	/var/ngop/include		0755
  right_file	$ENSTORE_DIR/ngop/local_cronjob.xml	/var/ngop/cron_agent		0644
  right_file	$ENSTORE_DIR/ngop/start_cron		/var/ngop/cron_agent/.start	0755
  if [ $SERVER -eq 1 ]; then
    lh_xml="srv_linuxHealth"	# servers
  else
    lh_xml="linuxHealth"	# movers
  fi
  right_file	$ENSTORE_DIR/ngop/${lh_xml}.xml		/var/ngop/plugins_agent		0644

  # are the two ngop agents running?

  set +u
  setup ngop
  set -u
  agents=`ngop check`
  if [ `$ECHO "$agents" | $WC -l` -ne 2 ] ||
     [ `$ECHO "$agents" | $AWK '$1 != "dead" && $2 == "root"' | $WC -l` -ne 2 ] ||
      ! $ECHO "$agents" | $GREP "ngop plugins_agent -c /var/ngop/plugins_agent/${lh_xml}\.xml" >/dev/null ||
      ! $ECHO "$agents" | $GREP "/var/ngop/cron_agent/\.start -c /var/ngop/cron_agent/local_cronjob\.xml" >/dev/null
  then
     msg=`$ECHO -e "problem with ngop agent(s):\n$agents"`
     logit "$msg"
     if [ $ALARM -eq 1 ]; then
	enstore alarm --raise --severity "A" --root-error "$msg"
     fi
  elif [ $QUIET -ne 1 ]; then
     logit "two ngop agents running, ok"
  fi

fi


# it seems we almost always change the mode of /dev/console after reboot, so don't alarm then
if [ $REBOOT -eq 1 ]; then
 (
  ALARM=0
  check_mode /dev/console	0622
 )
else
  check_mode /dev/console	0622
fi

# there needs to be more logic for xinetd or inetd files
if [ "$INETD" = unknown ]; then
  # neither file existed, this is a problem
  enstore alarm --raise --severity "A" --root-error "MISSING CONFIGURATION: no inetd.conf or xinetd.conf in /etc"
else
  right_file $ENSTORE_DIR/etc/${INETD}.conf		/etc/${INETD}.conf
  if [ "$INETD" = xinetd ]; then
    right_file $ENSTORE_DIR/etc/ftp			/etc/xinetd.d/ftp
    right_file $ENSTORE_DIR/etc/klogin			/etc/xinetd.d/klogin
    right_file $ENSTORE_DIR/etc/kshell			/etc/xinetd.d/kshell
    right_file $ENSTORE_DIR/etc/telnet			/etc/xinetd.d/telnet
    right_file $ENSTORE_DIR/etc/eklogin			/etc/xinetd.d/eklogin
  fi
fi

right_file $ENSTORE_DIR/etc/enstore.bashrc	  	/home/enstore/.bashrc
right_file $ENSTORE_DIR/etc/enstore.bash_profile	/home/enstore/.bash_profile
right_file $ENSTORE_DIR/etc/$gang.step-tickers		/etc/ntp/step-tickers


# check that no rpm binaries have been tampered with
# disabled... we made changes, check is not robust.
#$RPM -Va | $GREP bin | $EGREP -v '/usr/bin/X11|/usr/local/bin|/bin/bash|/usr/bin/bashbug|/usr/bin/db_|/usr/bin/run-parts|\.h$|\.h$|/bin/login'


# check that eth1 is working, fix if not
eth1_err="eth1: card reports no RX buffers"
if $TAIL -n 10 /var/log/messages | $EGREP "$eth1_err"; then
   logit "ERROR: $eth1_err"
   if [ $ALARM -eq 1 ]; then
     enstore alarm --raise --severity "A" --root-error "$eth1_err"
   fi
   [ -e /PRODUCTION ] && $IFDOWN eth1 >>$LOG 2>&1
   [ -e /PRODUCTION ] && $IFUP   eth1 >>$LOG 2>&1
elif [ $QUIET -ne 1 ]; then
   logit "No eth1 errors found in messages, ok"
fi


# check that ntp is working, fix if not, complain if down more than once
# check only in this job.  Separate cronjob sets time if needed.
msg=`$ENSTORE_DIR/sbin/ntpset -a -c 2>&1`
if [ $QUIET -ne 1 ]; then
   logit "$msg"
fi


# check that we have two processors running
#if [ `$GREP -c '^processor' /proc/cpuinfo` -ne 2 ]; then
#   if [ "$node" = "stkensrv5" ]; then
#      if [ $QUIET -ne 1 ]; then
#         logit "One processor found, ok"
#      fi
#   else
#      logit "ONLY 1 PROCESSOR RUNNING"
#      if [ $ALARM -eq 1 ]; then
#         enstore alarm --raise --severity "A" --root-error "ONLY 1 PROCESSOR RUNNING"
#      fi
#   fi
#else
#  if [ $QUIET -ne 1 ]; then
#    logit "Two processors found, ok"
#  fi
#fi


# check that we have sufficient disk space available.
#dflines=`$DF -P`
#$ECHO "$dflines" | while read a b c d e rest
#do
#  if [ `$ECHO $e | $GREP -c %` -eq 1 ]; then
#    cap=`$ECHO $e | $SED -e 's/%//'`
#    mess="$a $b $c $d $e $rest"
#    if [ $cap -ge 90 ]; then
#      msg="DISK FULL: $mess"
#      logit "$msg"
#      if [ $ALARM -eq 1 ]; then
#        enstore alarm --raise --severity "A" --root-error "$msg"
#      fi
#    else
#      if [ $QUIET -ne 1 ]; then
#        logit  "DISK $a at $cap%, ok"
#      fi
#    fi
#  fi
#done


if [ $IPMI -eq 1 ]; then
   # we need a watchdog_reset file to make check_watchdog work
   if [ ! -r /etc/watchdog_reset ]; then
      msg="/etc/watchdog_reset is missing"
      logit "$msg"
      if [ $ALARM -eq 1 ]; then
	 enstore alarm --raise --severity "A" --root-error "$msg"
      fi
   elif [ $QUIET -ne 1 ]; then
      logit "/etc/watchdog_reset, ok"
   fi
fi

# check that special jobs are listed in root crontab, or other files
if [ -r /var/spool/cron/root ]; then
   check_file "ekill -v -9 \"sdrread\|selread\|chip2\|Chip2\|netperf\|dog\|selbit\|selclear\|netstat\|Nodeinfo\|biterror\""
   check_file "check_watchdog_reset.py"
   check_file "ntpset"
   check_file "netscan -a -q"		# not so dumb, because we can run netscan manually, too
else
   logit "No root crontab"
fi

check_file "boot_cleanup"		/etc/rc.d/rc.local

for f in /{root,home/enstore}/.forward
do
  check_file "enstore-admin@fnal.gov"	$f	0644
done

# verify ownership of enstore keytab directory and file
check_owner /local/ups/kt
check_owner /local/ups/kt/enstorekt

# verify ownership of log files
check_owner ~enstore/`$HOSTNAME`.startup
check_owner /`$HOSTNAME`.monitor_server.output	root


# check that we don't have too many processes running
NPROC=`$LS -ld /proc/[1-9]* | $WC -l`
if   $ECHO $node | $GREP dca >/dev/null
then
    maxproc=300	 # disk cache
elif $ECHO $node | $GREP srv >/dev/null
then
    maxproc=200  # servers
elif $ECHO $node | $GREP mvr >/dev/null
then
    maxproc=100  # movers
else
    maxproc=100  # ???
fi

if [ $NPROC -ge $maxproc ]; then
   msg="$NPROC processes running. Way too many"
   logit "$msg"
   if [ $ALARM -eq 1 ]; then
     enstore alarm --raise --severity "A" --root-error "$msg"
   fi
elif [ $QUIET -ne 1 ]; then
   logit "$NPROC processes, ok"
fi

# count the number of pnfsd processes running on server nodes
case $node in
  *ensrv?)
    case $node in
      d0ensrv1)
	npnfsd=5
	;;
      stkensrv1)
	npnfsd=4
	;;
      cdfensrv1)
	npnfsd=7
	;;
      *)
	npnfsd=0
	;;
    esac
    NPROC=`$PS --no-headers -C pnfsd | $WC -l`
    if [ $NPROC -ne 0 -a $NPROC -ne $npnfsd ]; then
      msg="$NPROC pnfsd processes running. Should be $npnfsd"
      logit "$msg"
      if [ $ALARM -eq 1 ]; then
	enstore alarm --raise --severity "W" --root-error "$msg"
      fi
    elif [ $QUIET -ne 1 ]; then
      logit "$NPROC pnfsd processes, ok"
    fi
    ;;
esac

today=`date -I`

case $node in

  d0ensrv1|stkensrv1|cdfensrv1)
    # check database sizes on pnfs servers (srv1 nodes)
    #  - but don't make too much noise about it
    if [ $QUIET -ne 1 -a -r /diska/pnfs/db/info/D-0000 ]; then
       # establish directory for database sizes
       [ -d /tmp/pnfs-db-sizes ] || $MKDIR /tmp/pnfs-db-sizes
       # loop over all current enabled databases
       for db in `$GREP enabled /diska/pnfs/db/info/D-* | $CUT -d: -f6`
       do
	 dbname=`basename $db`
	 dbfile=/tmp/pnfs-db-sizes/$dbname
	 dbsize=`$LS -l $db | $AWK '{print $5}'`
	 if [ -r $dbfile ]; then
	    if [ $dbsize -gt 1610612736 ] && [ $dbsize -gt `cat $dbfile` ]; then
	       dbrnd
	       msg="DATABASE TOO BIG: $dbname - $(( (dbsize+524288)/1048576 )) MB exceeds 1.5 GB and is growing"
	       logit "$msg"
	       if [ $ALARM -eq 1 ]; then
		  enstore alarm --raise --severity "W" --root-error "$msg"
	       fi
	    else
	       logit "$dbname - $(( (dbsize+524288)/1048576 )) MB not too big or not growing, ok"
	    fi
	 fi
	 $ECHO $dbsize > $dbfile
       done
    fi
    ;;

  d0ensrv2|stkensrv2|cdfensrv2)
    # check the largest of today's log files on srv2 nodes
    logline=`$LS -ls /diska/enstore-log/*-$today | $SORT -n | $TAIL -1`
    logtime=`date +%s`
    logsize=`$ECHO $logline | $AWK '{print $6}'`
    logpath=`$ECHO $logline | $AWK '{print $10}'`
    logname=`basename $logpath`
    logfile=/tmp/logfile-sizes/$logname
    if [ $logsize -gt 536870912 ]; then
       # establish directory for logfile sizes
       [ -d /tmp/logfile-sizes ] || $MKDIR /tmp/logfile-sizes
       if [ -r $logfile ]; then
	  let dt=$logtime-`date -r $logfile +%s`
	  let ds=$logsize-`cat $logfile`
	  if [ $(( (`date -d 2359 +%s`-logtime)*ds )) -gt $(( (1073741824-logsize)*dt )) ]; then
	     msg="LOG FILE GROWING TOO FAST: $logname will exceed 1 GB by midnight"
	     logit "$msg"
	     if [ $ALARM -eq 1 ]; then
		enstore alarm --raise --severity "W" --root-error "$msg"
	     fi
	  elif [ $QUIET -ne 1 ]; then
	     logit "$logname - $(( (logsize+524288)/1048576 )) MB not growing too fast, ok"
	  fi
       else
	  $ECH0 $logsize > $logfile
	  msg="LOG FILE TOO BIG: $logname - $(( (logsize+524288)/1048576 )) MB exceeds .5 GB"
	  logit "$msg"
	  if [ $ALARM -eq 1 ]; then
	     enstore alarm --raise --severity "W" --root-error "$msg"
	  fi
       fi
    elif [ $QUIET -ne 1 ]; then
       logit "$logname - $(( (logsize+524288)/1048576 )) MB not too big, ok"
    fi
    ;;

esac

# check that db_deadlock and db_checkpoint are running if file or vol clerk running:
#if [ `$PS axuwww|$GREP python|$GREP -v 'grep'|$EGREP -c 'file_clerk.py|volume_clerk.py'` -ge 1 ]; then
#   for need in db_checkpoint db_deadlock
#   do
#     if [ `$PS axuwww|$GREP -v 'grep'|$GREP -c $need` -ne 1 ]; then
#	msg="$need not running (or more than 1 running) and file/volume clerk are running."
#	logit "$msg"
#	if [ $ALARM -eq 1 ]; then
#	  enstore alarm --raise --severity "A" --root-error "$msg"
#	fi
#     elif [ $QUIET -ne 1 ]; then
#	logit "$need running, ok"
#     fi
#   done
#elif [ $QUIET -ne 1 ]; then
#  logit "file/volume clerk not running, no db_deadlock or db_checkpoint check, ok"
#fi

# check for web servers
case $node in
# web servers should be running on these nodes
  rip7|d0ensrv2|stkensrv2|cdfensrv2|stkendca3a)
    if [ `$PS --no-headers -C httpd | $WC -l` -eq 0 ]; then
       msg="httpd web server not running"
       logit "$msg"
       if [ $ALARM -eq 1 ]; then
	 enstore alarm --raise --severity "A" --root-error "$msg"
       fi
    elif [ $QUIET -ne 1 ]; then
       logit "httpd web server running, ok"
    fi
    for i in $ENSTORE_DIR/src/*_cgi.py
    do
       right_file $i /local/ups/prd/httpd/cgi-bin/enstore 0755
    done
    ;;
# web servers may be running on these nodes, but don't need to be
  stkendca[678]|cachen[12]a|d0enout[12]a)
    ;;
# web servers should not be running on any other nodes
  *)
    if [ `$PS --no-headers -C httpd | $WC -l` -ne 0 ]; then
       msg="httpd web server running on illegal node"
       logit "$msg"
       if [ $ALARM -eq 1 ]; then
	 enstore alarm --raise --severity "A" --root-error "$msg"
       fi
    elif [ $QUIET -ne 1 ]; then
       logit "httpd web server not running, ok"
    fi
    ;;
esac


# check that the keytabs are "correct"
$KEYTAB_CHECK `[ $ALARM -eq 1 ] && $ECHO '-a'`  `[ $QUIET -eq 1 ] && $ECHO '-q'`


# look for "lost" files - non-empty lost+found directories - in mounted local file systems
for dsk in `awk '$3 ~ /ext[23]/ {print $2}' /proc/mounts`
do
  # we should always find /, which is syntactically redundant
  [ $dsk = / ] && dsk=''
  if [ -d $dsk/lost+found ]; then
     if [ `$LS -1 $dsk/lost+found | $WC -l` -ne 0 ]; then
	siz=`$DU -ks $dsk/lost+found | $AWK '{print $1}'`
	msg="Files in $dsk/lost+found: $siz KB"
	logit "$msg"
	if [ $ALARM -eq 1 ]; then
	   enstore alarm --raise --severity "I" --root-error "$msg"
	fi
     elif [ $QUIET -ne 1 ]; then
	logit "$dsk/lost+found empty, ok"
     fi
  elif [ $QUIET -ne 1 ]; then
     msg="No lost+found for $dsk"
     logit "$msg"
     if [ $ALARM -eq 1 ]; then
	enstore alarm --raise --severity "I" --root-error "$msg"
     fi
  fi
done

# look for local files hidden behind mount points where nfs file systems are not mounted
# subtract set of mounted nfs file systems from mount points where they might be mounted
fs_avail=`$AWK '$3 ~ /nfs/ && $1 !~ /#.*/ {print $2}' /etc/fstab`
fs_mount=`$AWK '$3 ~ /nfs/ {print $2}' /proc/mounts`
for dsk in `$ECHO $fs_avail $fs_mount | $TR " " "\n" | $SORT | $UNIQ -u`
do
  if [ -d $dsk ]; then
     if [ `$LS -1 $dsk | $WC -l` -ne 0 ]; then
	siz=`$DU -ks $dsk | $AWK '{print $1}'`
	msg="Files hidden behind $dsk: $siz KB"
	logit "$msg"
	if [ $ALARM -eq 1 ]; then
	   enstore alarm --raise --severity "I" --root-error "$msg"
	fi
     elif [ $QUIET -ne 1 ]; then
	logit "$dsk empty, ok"
     fi
  elif [ $QUIET -ne 1 ]; then
     msg="No mount point for $dsk"
     logit "$msg"
     if [ $ALARM -eq 1 ]; then
	enstore alarm --raise --severity "I" --root-error "$msg"
     fi
  fi
done


# get open files - twice - get ps in between - only take connections that survive past this
# otherwise it is impossible to compare and see if they are allowed - this is a small hole
# also need to go through a file - because argument to echo is too large!!!
netscan_n1=/tmp/netscan_n1
netscan_n2=/tmp/netscan_n2
rm -f $netscan_n1
rm -f $netscan_n2
$LSOF -i TCP -i UDP > $netscan_n1
# sometimes we get no output from ps command
while true
do
  PSfirst=`$PS --no-headers afuwwwx | $CUT -c1-250`
  if [ -n "${PSfirst:-}" ]; then
    break
  fi
  $SLEEP 1
done
$LSOF -i TCP -i UDP > $netscan_n2


if [ $IPMI -eq 1 ]; then
   # check that ipmisrv is running without watchdog timer
   if [ `$ECHO $PSfirst | $GREP -c "ipmisrv NO_DOG"` -ne 1 ]; then
      msg="ipmisrv NO_DOG not running or misconfigured"
      logit "$msg"
      if [ $ALARM -eq 1 ]; then
	 enstore alarm --raise --severity "A" --root-error "$msg"
      fi
   elif [ $QUIET -ne 1 ]; then
      logit "ipmisrv NO_DOG running, ok"
   fi

   # check that watchdog timer action is to do nothing
   ACTION=`/home/enstore/ipmi/dogread | $GREP Action | $AWK '{print $2}'`
   if [ "$ACTION" != "00" ]; then
      msg="watchdog action is < $ACTION >. Should be 00"
      logit "$msg"
      if [ $ALARM -eq 1 ]; then
	 enstore alarm --raise --severity "A" --root-error "$msg"
      fi
      # disable the action
      /home/enstore/ipmi/dogdisarm
   elif [ $QUIET -ne 1 ]; then
      logit "watchdog action, ok"
   fi
fi


# scan open files and check if allowed
$SORT $netscan_n1 $netscan_n2 | $UNIQ -d | while read command pid rest
do
    if [ $pid = "PID" ] ; then continue; fi
    if [ `$ECHO $rest | $GREP -c "LISTEN"` -ne 0 ]; then
       allow LISTEN
    elif [ `$ECHO $rest | $GREP -c "UDP"` -ne 0 ]; then
      if [ $QUIET -ne 1 ]; then
	 logit "Ignoring open UDP connections $command $pid $rest ..."
      fi
    elif [ `$ECHO $rest | $GREP -c "TCP"` -ne 0 ]; then
      if [ $QUIET -ne 1 ]; then
	 logit "Ignoring open TCP connections $command $pid $rest ..."
      fi
    fi
done

# once a day, check for core files in unusual places.
#CORE=`slocate -r '/core\.[1-9][0-9]*$'`

# tasks that go over network. Can hang sometimes. Do this last.

# reduce load on base nodes by doing this less than once an hour.

# check that farmlets match
if [ $((uptime % 5)) -eq 0 ] && [ $gang != "rip" ]; then
   if [ $ALARM -eq 1 ]; then
     msg="`$FARMLETS -a 2>&1`"
   else
     msg="`$FARMLETS 2>&1`"
   fi
   if [ $? -ne 0 ]; then
      logit "$msg"
   elif [ $QUIET -ne 1 ]; then
      logit "$msg"
   fi
fi


logit "netscan finished"
rm -fr $ACTIVE
