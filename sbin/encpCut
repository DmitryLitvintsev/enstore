#!/bin/sh
set -u  # force better programming and ability to use check for not set
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

# sbin/$RCSfile$  $Revision$

# script to cut the encp product from the enstore sources

# based on copCut which is based almost entirely on Ron R's dscCut

product=encp

echo "${product}Cut starting at `date`"

##############################################################################

USAGE="

   ${product}Cut -options

-r version   next release version
-i directory install directory (without version number and product) for the new revision (i.e. /p/Linux)
-c chain     to set chain to be <new|old|test|development|current|none>
-s steps     to control which steps get executed,  zB 1,2,4-13
-x           to set -xv
-?           to list this

Steps to the cutting process:
  1.  cvs directory check
  2.  cd modules - make clean all
  3.  cd src - make clean encp
  4.  cd volume_import - make clean enstore_tape
  5.  cvs tag
  6.  install into product area
  7.  ups undeclare
  8.  ups declare
  9.  upd delproduct
  10. upd addproduct
"

##############################################################################

STEPSDEFINED=10

echo "$USAGE"

thepwd=`pwd`

##############################################################################
# utility functions that do what their names imply

check_status() { jstatus=${1:-0}
                 jname=${2:-unknown}
                 jstep=${Step:-unknown}
                 if [ $jstatus != 0 ] ; then
                   echo ""
                   echo "${product}Cut Fatal Error=$1 \"$jname\", Step \"$jstep\"" >&2
                   echo "${product}Cut ABORTED at `date`"
                   cd $thepwd
                   exit $jstatus
                 else
                   if [ -z "${3-}" ] ; then
                      echo "${product}Cut success for \"$jname\", Step \"$jstep\" at `date`" >&2
                   fi
                 fi ; }

echo_timed_read() { jtime=${1:-10}
                    /bin/sh -c '( sleep '$jtime' ; kill $$ ) >/dev/null 2>&1 &
                    read ans ; echo "$ans"' ;}

starting() { if [ $try != "list" ] ; then
                /bin/echo -n "starting at `date`"
             fi; }

##############################################################################
# we need ups and upd to be setup

if [ -z "${UPS_DIR-}" ] ; then
  Step="ups check"
  check_status 1 "You need ups to be setup before using ${product}Cut"
fi

if [ -z "${UPD_DIR-}" ] ; then
  Step="upd check"
  check_status 1 "You need upd to be setup before using ${product}Cut"
fi

##############################################################################
# we need enstore to be setup and we need to be in a cvs working directory

if [ -z "${ENSTORE_DIR-}" ] ; then
  Step="enstore check"
  check_status 1 "You need enstore to be setup before using ${product}Cut"
fi
cd $ENSTORE_DIR
#FLAVOR=`echo $SETUP_ENSTORE | cut -d" " -f4` # potentially troublesome - not very robust if the setup_enstore line changes
FLAVOR=`echo $SETUP_ENSTORE | sed -e 's/.*-f //' -e 's/ .*//'`
if [ -d CVS ] ; then
   Cvs_Module=`expr "\`cat CVS/Repository\`" : ".*/\([^/]*\)"`
fi
if [ "${Cvs_Module:-}" = "" ];then
   check_status 1 "You need to be in a cvs working directory to use ${product}Cut"
fi

##############################################################################
# parse the options on the command line
#### dadburned getopts does not work on OSF1, so parse opts manually############

gotc=

opt=""
if [ $# -gt 0 ] ; then
   for optarg in $@ ; do

      case $opt in
         -i) INSTALLDIR=$optarg
             opt=""
             ;;
         -r) REV=$optarg
             opt=""
             ;;
         -c) case $optarg in
               "")  CHAIN="";             ;;
               no*) CHAIN="";             ;;  # no or none
               c*)  CHAIN="${CHAIN-} -c"; ;;  # you can have multiple chains
               d*)  CHAIN="${CHAIN-} -d"; ;;
               n*)  CHAIN="${CHAIN-} -n"; ;;
               o*)  CHAIN="${CHAIN-} -o"; ;;
               t*)  CHAIN="${CHAIN-} -t"; ;;
                *)   Step="chain getopts"; check_status 1 "You have specified an illegal chain";  ;;
             esac
             gotc=1
             opt=""
             ;;
         -s) STEPS=`for i in \`echo $optarg | sed -e 's/,/ /g'\` ; do
                if x=\`expr $i : '\(.*\)-'\` ; then
                   y=\`expr $i : '.*-\(.*\)'\`
                   while [ $x -le $y -a $x -le $STEPSDEFINED ] ; do
                     echo $x
                     x=\`expr $x + 1\`
                   done
                else
                   echo $i
                fi
              done | sort -nu`        # do not sort if we want to specify an order or repeating steps (could use uniq instead of sort)
              STEPS="`echo $STEPS`"   # remove lfs (b/c STEPS isnt quoted inside)
              opt=""
              ;;
         "") opt=$optarg;;
         -?) echo "$USAGE"; Step="getopts"; check_status 1 "" ;;
         *)  echo "$USAGE"; Step="getopts"; check_status 1 "Unknown option" ;;
         esac
   done
fi

if [ -n "$opt" ] ; then echo "$USAGE"; Step="getopts"; check_status 1 "Can not parse command line correctly"; fi

echo ""
echo "options have been processed... checking"

##############################################################################
# we need a revision - if not specified, get old one from a cvs tag

if [ -z "${REV-}" ] ; then
   Step="next revision"
   last=`cvs status -v Makefile | grep \(revision: | grep $product | head -1  | sed -e 's/^[ ]*//'`
   check_status $? "cvs status -v Makefile"
   if [ -z "${last-}" ] ; then
     echo "revision info not available via cvs - defaulting to v0_0 as last known revision"
     last=${last:-v0_0_Linux}
   fi
   major=`echo $last | awk -F_ '{print $1}'`
   minor=`echo $last | awk -F_ '{print $2}'`
   REV=${major}_`expr $minor + 1`
   check_status $? "determining next rev from $last"
   echo "Revision not specified - Defaulting to revison $REV"
fi

##############################################################################
# we need a place to install the cut product

setrev=1
if [ -z "${INSTALLDIR-}" ] ; then
   Step="installdir"
   case `uname -n` in
      airedale*) INSTALLDIR=/home/products/$product;;
      pcfarm9*)  INSTALLDIR=/products/$product;;
      hppc*)     INSTALLDIR=/usr/products/IRIX+6/$product;;
      ripsgi*)   INSTALLDIR=/usr/products/$product;;
      rip8*)     INSTALLDIR=/fnal/ups/prd/$product/${REV}/Linux+2/
	         setrev=0;;
      *)         INSTALLDIR=/p/`uname`/$product;;
   esac
   echo "Install directory not specified - Defaulting to install directory of $INSTALLDIR"
fi
if [ $setrev -eq 1 ]; then
  INSTALLDIR=${INSTALLDIR}/${REV}
fi

##############################################################################
# we need to know what steps we are supposed to perform during the cut

if [ -z "${STEPS-}" ] ; then
   STEPS=1
   s=2
   while [ $s -le $STEPSDEFINED ] ; do STEPS="${STEPS-} $s"; s=`expr $s + 1`; done
   echo "Cut steps not specified - Defaulting to all steps: $STEPS"
fi
STEPSOK=""
for step in $STEPS; do
   if [ $step -le $STEPSDEFINED -a $step -ge 1 ] ; then
      if [ -z "${STEPSOK-}" ] ; then
        STEPSOK=$step
      else
        STEPSOK="$STEPSOK $step"
      fi
   fi
done
if [ -z "${STEPSOK-}" ] ; then
  Step="checksteps"
  check_status 1 "No steps defined, how odd"
fi
STEPS=$STEPSOK
STEPS="$STEPS done" # done is flag that we are finished
save_STEPS=$STEPS

##############################################################################
# we need to know what chain we are cutting

if [ -z "${gotc-}" ] ; then
   CHAIN=" -c"
   echo "UPS/UPD chain not specified - Defaulting to chain $CHAIN"
fi

echo ""
echo "Using files in CVS $Cvs_Module working directory `pwd` to cut $product $REV"
echo "  and ups/upd declaring it as ($CHAIN) into directory $INSTALLDIR using steps $save_STEPS."

##############################################################################

for try in list doit; do
   echo ""
   STEPS=$save_STEPS
   while [ "$STEPS" != "done" ] ; do
      Step="`expr \"$STEPS\" : '\([^ ]*\) .*'`"
      STEPS="`expr \"$STEPS\" : '[^ ]* \(.*\)'`"
      case $Step in

        1) echo "Step $Step:  cvs directory check for `pwd`    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR
              cvs_nq_update=`cvs -nq update 2>&1`
              check_status $? "cvs -nq update: $cvs_nq_update"
              if echo "$cvs_nq_update" | fgrep '[server aborted]' >/dev/null ; then
                check_status 1 "server aborted problems with cvs: $cvs_nq_update"
              elif x="`echo \"$cvs_nq_update\"|grep '^M'`"   ; then
               check_status 1 "$x: Modified or unknown files ($cvs_nq_update) in working directory - update/commit needed first"
              elif x="`echo \"$cvs_nq_update\"|grep '^[PU]'`"; then
               check_status 1 "$x: Update/Patched files ($cvs_nq_update) in repository - update/commit needed first"
              fi
           fi
           ;;

        2) echo "Step $Step:  cd modules and make clean all   `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/modules
              make clean all
              check_status $? "make clean all"
           fi
           ;;

        3) echo "Step $Step:  cd src and make clean encp    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/src
              make clean encp
              check_status $? "make clean encp"
           fi
           ;;

        4) echo "Step $Step:  cd volume_import and make clean enstore_tape    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/volume_import
              make clean enstore_tape
              check_status $? "make clean enstore_tape"
           fi
           ;;

        5) tag=${REV}_${product}_`uname`
           echo "Step $Step:  cvs tag $tag    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR
              cvs tag $tag
              check_status $? "cvs tag $tag"
           fi
           ;;

        6) echo "Step $Step:  install $product into $INSTALLDIR    `starting`"
           if [ "$try" = "doit" ] ; then
              cd $ENSTORE_DIR/src/ENCPBIN
              # check if directory doesn't exist
              if [ ! -d $INSTALLDIR ] ; then
                 echo "$INSTALLDIR does not exist... making it"
                 mkdir -p $INSTALLDIR
                 check_status $? "mkdir -p $INSTALLDIR"
              fi
              cp * $INSTALLDIR
              check_status $? "cp * $INSTALLDIR"
	      cp $ENSTORE_DIR/volume_import/enstore_tape $INSTALLDIR
	      check_status $? "cp enstore_tape $INSTALLDIR"
	      cd $INSTALLDIR
	      ln -s sam.table enstore_variables.table
	      check_status $? "cp ln -s sam.table enstore_variables.table"
           fi
           ;;

        7) echo "Step $Step:  ups undeclare -f $FLAVOR $product $REV    `starting`"
           if [ "$try" = "doit" ] ; then
              a=`$UPS_DIR/bin/ups undeclare  -f $FLAVOR $product $REV 2>&1`
              stat=$?
              if [ `echo "$a" | grep -c "No matching product"` -eq 0 ]; then
                check_status $stat $a
              fi
           fi
           ;;

        8) echo "Step $Step:  ups declare $CHAIN -f $FLAVOR -r $INSTALLDIR -M $INSTALLDIR -m $product.table $product $REV    `starting`"
           if [ "$try" = "doit" ] ; then
                 $UPS_DIR/bin/ups declare $CHAIN -f $FLAVOR -r $INSTALLDIR -M $INSTALLDIR -m $product.table $product $REV
                 check_status $? "ups declare"
           fi
           ;;

        9) echo "Step $Step:  upd delproduct -H $FLAVOR -f $FLAVOR  $product $REV   `starting`"
           if [ "$try" = "doit" ] ; then
              a=`$UPD_DIR/bin/upd delproduct  -H $FLAVOR -f $FLAVOR $product $REV 2>&1`
              stat=$?
              if [ `echo "$a" | grep -c "No matching product"` -eq 0 ]; then
                check_status $stat $a
              fi
           fi
           ;;

        10) echo "Step $Step:  upd addproduct $CHAIN -H $FLAVOR -f $FLAVOR -r $INSTALLDIR -M $INSTALLDIR -m $product.table $product $REV   `starting`"
           if [ "$try" = "doit" ] ; then
              $UPD_DIR/bin/upd addproduct $CHAIN -H $FLAVOR -f $FLAVOR -r $INSTALLDIR -M $INSTALLDIR -m $product.table $product $REV
              check_status $? "upd addproduct"
           fi
           ;;


        *) check_status 1 "There is no step \"$Step\". Why did you ask for it?"
           ;;

       esac
   done

   if [ "$try" = "list" ] ; then
      /bin/echo -n "\nThere are a total of $STEPSDEFINED steps defined. Is this the set that you want to do? "
      ans=`echo_timed_read 10`
      if [ $? != 0 ] || expr "$ans" : '[Yy]' >/dev/null ; then
        echo "Proceeding with ${product}Cut..."
        echo ""
    else
         cd $thepwd
         exit 0
      fi
  fi
done

cd $thepwd
echo "${product}Cut $REV finished at `date`"
