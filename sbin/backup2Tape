#!/bin/sh
set -u  # force better programming and ability to use check for not set
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

# bin/$RCSfile$  $Revision$

#FULL_BACKUP_DAYS="Mon Thu"
#FULL_BACKUP_DAYS="Wed"
#FULL_BACKUP_DAYS="Thu"
FULL_BACKUP_DAYS="NEVER"


node=`uname -n| sed -e 's/\([^\.]\)\..*/\1/'`

# function to return date so it can be used in filename
date_string() { date +"%Y-%m-%d.%H.%M" }

# function to return date so it can be used in directory path
date_string_d() { date +"%Y/%m/%d/%H" }

today=`date +"%b %d"`
now=`date +"%s"`

list() { echo "$1"
         if [ "${BACKUP_LOG:-}" != "" ]; then echo "$1" >>$BACKUP_LOG; fi
       }

#function to list command, execute it and list status
doit() { list "$1"
         doutput=/tmp/doit_output
         rm -f $doutput
         eval "nice -n 20 $1" >>$doutput
         status=$?
         cat $doutput
         if [ "${BACKUP_LOG:-}" != "" ]; then cat $doutput >>$BACKUP_LOG; fi
         list "Status= $status"
         if [ $status -ne 0 ]; then exit $status; fi
         list ""
       }

saveit() { if [ $method = "volume_import" ]; then
             #  TAPE=/dev/rmt/tps0d4n;         export TAPE
             #  TAPE_DEVICE=$TAPE;             export TAPE_DEVICE
             #  TAPE_DB=/diska/BackupTapeDB;   export TAPE_DB
             #  $ENSTORE_DIR/volume_import/enstore_tape --init --volume_label=LABEL
             doit "$ENSTORE_DIR/volume_import/enstore_tape --write --volume-label=$LABEL $1 --pnfs-dir=$pnfspath --no-check --strip-path='' $1"
           elif [ $method = "encp" ]; then
             #  Tapes have to be declared to the volume server and in the correct storage family
             pnfsname=`echo $1 | tr '/' '-' | sed s/-//`
             doit "encp --data $verbose $1 $pnfspath/$pnfsname"
           else
             doit "invalid method"
           fi
         }

# Fermi specific stuff
if [ $node = d0ensrv3 ]; then
  method=volume_import;               export method
  verbose=""
  pnfspath="/pnfs/backups";           export pnfspath
  filePath='/diska'
  tapeName='/dev/rmt/tps0d4n'
  TAPE=${tapeName};                   export TAPE
  TAPE_DB=${filePath}/BackupTapeDB;   export TAPE_DB
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  rm -f $BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  ENSTORE=${filePath}/enstore-backup
  ENSTORELOG=${filePath}/enstore-log-backup
  TIMEONDISK=1 #days

elif [ $node = stkensrv3 ]; then
  method=encp;                        export method
  verbose="--verbose=1"
  pnfspath="/pnfs/eagle/backups/`date_string_d`"; export pnfspath
  doit "mkdir -p $pnfspath"
  filePath='/diska'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  rm -f $BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  ENSTORE=${filePath}/enstore-backup
  ENSTORELOG=${filePath}/enstore-log-backup
  TIMEONDISK=1  #days

else
  doit "Do not know about node $node... fix $ENSTORE/sbin/backup2Tape script"
fi


if [ $method = volume_import ]; then
   list  "METADATA BACKUP Using the $method method"
   LABEL=NOLABL; export LABEL
   if [ "$LABEL" = "NOLABL" ]; then
      if [ -r $VAULT/CURRENT_TAPE ]; then
         LABEL=`cat $VAULT/CURRENT_TAPE`
         LABEL=`echo $LABEL|cut -c0-6` # the echo gets rid of spaces, etc
      fi
   fi

   TAPE_DEVICE=$TAPE;             export TAPE_DEVICE
   STATS=$VAULT/tape_stats
elif [ $method = encp ]; then
   list "METADATA BACKUP Using the $method method."
else
   doit "invalid method"
fi



############################################################################
# decided if we need to do a full backup or incremetal since last full backup

START_BACKUP_DATE=$VAULT/start_backup_date
rm -f $START_BACKUP_DATE
touch $START_BACKUP_DATE  #make this now, mv'ing it later will NOT change the access time

LAST_BACKUP_DATE=$VAULT/last_backup_date
last="`date -r $LAST_BACKUP_DATE`"
list "Last backup on $last"

rm -f $VAULT/*.tar $VAULT/*.tgz $VAULT/*.tbz2 # junk accumulates and takes up valuable space!

FULL_BACKUP_FLAG=$VAULT/full_backup_needed
FULL_BACKUP_LAST=$VAULT/full_backup_date

if [ `echo $FULL_BACKUP_DAYS | grep -c "\`date +'%a'\`"` -ne 0 -a -r $FULL_BACKUP_FLAG ]; then
   tar_options=""
   find_options="-follow"
   TOUCHME=$FULL_BACKUP_LAST
   kind=FULL
else
   reference="`date -r $FULL_BACKUP_LAST`"
   tar_options="--newer=\"$last\""
   find_options="-follow -newer $LAST_BACKUP_DATE"
   TOUCHME=$FULL_BACKUP_FLAG # indicate that another full backup is needed when the right day rolls around
   kind=INCREMENTAL
fi


#### PNFS Database Backup ##################################################
# bzip2/copy the files that have not been copied to tape

PNFS_FILES=$VAULT/pnfs.files
rm -f $PNFS_FILES
find $PNFS -type f $find_options -print > $PNFS_FILES
doit "cat $PNFS_FILES"
lines=`wc -l $PNFS_FILES | awk '{print $1}'`
list ""
list "PNFS databases backup: $lines files to backup to tape"
cat $PNFS_FILES
list ""
counter=0
cat $PNFS_FILES| while read file; do
  counter=`expr $counter + 1`;
  list "$counter of $lines PNFS database files: $file"
  saveit $file
done
rm -f $PNFS_FILES
find $PNFS -daystart -mtime +$TIMEONDISK -exec rm -fr {} \;




#### Enstore Database Backup ###############################################
# bzip2/copy the files that have not been copied to tape

ENSTORE_FILES=$VAULT/enstore.files
rm -f $ENSTORE_FILES
find $ENSTORE -type f $find_options -print > $ENSTORE_FILES
doit "cat $ENSTORE_FILES"
lines=`wc -l $ENSTORE_FILES | awk '{print $1}'`
list ""
list "ENSTORE databases backup: $lines files to backup to tape"
cat $ENSTORE_FILES
list ""
counter=0
cat $ENSTORE_FILES| while read file; do
  counter=`expr $counter + 1`;
  list "$counter of $lines ENSTORE database files: $file"
  saveit $file
done
rm -f $ENSTORE_FILES
find $ENSTORE -daystart -mtime +$TIMEONDISK -exec rm -fr {} \;




#### Enstore Log Backup ####################################################
# bzip2/copy the files that have not been copied, excluding today's, to tape

ENSTORELOG_FILES=$VAULT/enstorelog.files
rm -f $ENSTORELOG_FILES
find $ENSTORELOG -type f $find_options  -exec ls -l {} \; | grep -v "$today" | awk '{print $NF}' > $ENSTORELOG_FILES
doit "cat $ENSTORELOG_FILES"
lines=`wc -l $ENSTORELOG_FILES | awk '{print $1}'`
list ""
list "ENSTORE log backup: $lines files to backup to tape"
cat $ENSTORELOG_FILES
list ""
counter=0
cat $ENSTORELOG_FILES| while read file; do
  counter=`expr $counter + 1`;
  list "$counter of $lines ENSTORE log files: $file"
  output=$VAULT/`basename $file`.$now.tbz2
  doit "bzip2 < $file > $output"
  saveit $output
  rm -f $output
done
rm -f $ENSTORELOG_FILES




############################################################################

rm -f $VAULT/*.tar $VAULT/*.tgz $VAULT/*.tbz2 # junk accumulates and takes up valuable space!

#next time, get only new files since we started the backup.
mv $START_BACKUP_DATE $LAST_BACKUP_DATE

touch $TOUCHME            # indicate that the backup was successful
if [ $kind = "FULL" ]; then
  rm -f $FULL_BACKUP_FLAG # indicate we've done the full backup on selected day (not twice per day)
fi



if [ $method = volume_import ]; then

   ############################################################################
   # get the tape stats and check for dirty drives or out of space conditions

   stats="`doit "$ENSTORE_DIR/sbin/ftt_stats $TAPE"`"

   min_remaining_KB_before_warn=`expr 1024 \* 1024 / 4 `
   remaining_KB=`echo  "$stats" | grep FTT_REMAIN_TAPE  | cut -f3 -d' '`
   if [ $remaining_KB -le $min_remaining_KB_before_warn ]; then
      echo Running out of room on Backup tape $LABEL on `uname -n` tape drive $TAPE; echo ""
      /usr/bin/Mail -s "Running out of room on backup tape $LABEL on `uname -n` tape drive $TAPE" $ENSTORE_MAIL <<EOF

   Running out of room on Backup tape $LABEL on `uname -n` tape drive $TAPE

   Tape left =  $remaining_KB kilobytes
   Minimum space before warning = $min_remaining_KB_before_warn kilobytes

   Please replace tape $LABEL soon

   Insert a new tape into the drive and initialize it:
     TAPE=${tapeName};              export TAPE
     TAPE_DEVICE=$TAPE;             export TAPE_DEVICE
     TAPE_DB=${filePath}/BackupTapeDB;   export TAPE_DB
     setup enstore
     $ENSTORE_DIR/volume_import/enstore_tape --init --volume_label=<NEW_LABEL>

   Edit $VAULT/CURRENT_TAPE
    and enter the label of the replacement tape

   Thanks,
   Enstore Backup

   $stats

EOF
   fi

   rm -f $STATS
   echo ""
   echo `expr $remaining_KB / 1024` MB left on $LABEL in $TAPE on `uname -n`
   echo `expr $remaining_KB / 1024` MB left on $LABEL in $TAPE on `uname -n` >> $STATS
   echo ""
   echo ""  >> $STATS

   cleaning_needed=`echo "$stats" | grep FTT_CLEANING_BIT | cut -f3 -d' '`
   if [ $cleaning_needed -ne 0 ]; then
      echo "Dirty backup tape drive $TAPE (not in the robot) on `uname -n`"; echo ""
      /usr/bin/Mail -s "Dirty backup tape drive $TAPE (not in the robot) on `uname -n`" $ENSTORE_MAIL <<EOF

   Dirty backup tape drive $TAPE (not in the robot) on `uname -n`

   Please clean soon or else backups will fail.

   The cleaning tape is on the shelf next to the tape drive.


   Thanks,
   Enstore Backup

   $stats

EOF
   fi

   echo ""
   echo $TAPE on `uname -n` not reporting dirty
   echo $TAPE on `uname -n` not reporting dirty >> $STATS
   echo ""
   echo ""  >> $STATS

   echo "$stats"
   echo "$stats" >> $STATS
   echo

elif [ $method = encp ]; then
   #  send mail to let people know what was backed up
   cat $BACKUP_LOG | /usr/bin/Mail -s "Metadata tape backup log from $node on `uname -n`" $ENSTORE_MAIL
fi

list `date`: Finished backup on $node

exit 0
