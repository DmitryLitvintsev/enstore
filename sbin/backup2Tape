#!/bin/sh
set -u  # force better programming and ability to use check for not set
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

# bin/$RCSfile$  $Revision$

#FULL_BACKUP_DAYS="Mon Thu"
#FULL_BACKUP_DAYS="Wed"
#FULL_BACKUP_DAYS="Thu"
FULL_BACKUP_DAYS="NEVER"


node=`uname -n| sed -e 's/\([^\.]\)\..*/\1/'`

# function to return date so it can be used in filename
date_string() { date +"%Y-%m-%d.%H.%M" }

# function to return date so it can be used in directory path
date_string_d() { date +"%Y/%m/%d/%H" }

today=`date +"%b %d"`
now=`date +"%s"`

list() { echo "$1"
         if [ "${BACKUP_LOG:-}" != "" ]; then echo "$1" >>$BACKUP_LOG; fi
       }

#function to list command, execute it and list status
doit() { list "$1"
         doutput=/tmp/doit_output
         rm -f $doutput
         eval "nice -n 20 $1" >>$doutput 2>&1
         status=$?
         if [ `echo $1 | grep -c encp` -ne 0 -a `grep -c STATUS=ok $doutput` -eq 0 ]; then status=1; fi
         cat $doutput
         if [ "${BACKUP_LOG:-}" != "" ]; then cat $doutput >>$BACKUP_LOG; fi
         list "Status= $status"
         list ""
         if [ $status -ne 0 ]; then touch $QUIT; exit $status ;fi
       }

saveit() { #  Tapes have to be declared to the volume server and in the correct storage family
           pnfsname=`echo $1 | tr '/' '-' | sed s/-//`
           ls -l $1
           doit "encp --data $verbose $1 $pnfspath/$pnfsname"
           status=$?
           ls -l $pnfspath/$pnfsname
           if [ $status -ne 0 ]; then touch $QUIT; exit $status; fi
         }

# Fermi specific stuff
if [ $node = d0ensrv3 ]; then
  verbose="--verbose=1"
  pnfspath="/pnfs/archive/backups/`date_string_d`"; export pnfspath
  filePath='/diska'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  ENSTORE=${filePath}/enstore-backup
  ENSTORELOG=${filePath}/enstore-log-backup
  QUIT=$VAULT/QUIT
  TIMEONDISK=1  #days

elif [ $node = stkensrv3 ]; then
  verbose="--verbose=1"
  pnfspath="/pnfs/eagle/backups/`date_string_d`"; export pnfspath
  filePath='/diska'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  ENSTORE=${filePath}/enstore-backup
  ENSTORELOG=${filePath}/enstore-log-backup
  QUIT=$VAULT/QUIT
  TIMEONDISK=1  #days

else
  doit "Do not know about node $node... fix $ENSTORE/sbin/backup2Tape script"
  exit 1
fi

rm -f $BACKUP_LOG

# try to make a unique directory, but give up after 10 tries
x=0; while [ $x -le 10 -a -d $pnfspath ]; do x=`expr $x + 1`; pnfspath=${pnfspath}.next; done
if [ -d $pnfspath ]; then list "$pnfspath exists, quitting"; fi
mkdir -p $pnfspath

rm -f $VAULT/*.tbz2 #old junk
rm -f $QUIT

############################################################################
# decided if we need to do a full backup or incremetal since last full backup

START_BACKUP_DATE=$VAULT/start_backup_date
rm -f $START_BACKUP_DATE
touch $START_BACKUP_DATE  #make this now, mv'ing it later will NOT change the access time

LAST_BACKUP_DATE=$VAULT/last_backup_date
last="`date -r $LAST_BACKUP_DATE`"
list "Last backup on $last"

FULL_BACKUP_FLAG=$VAULT/full_backup_needed
FULL_BACKUP_LAST=$VAULT/full_backup_date

if [ `echo $FULL_BACKUP_DAYS | grep -c "\`date +'%a'\`"` -ne 0 -a -r $FULL_BACKUP_FLAG ]; then
   find_options="-follow"
   TOUCHME=$FULL_BACKUP_LAST
   kind=FULL
else
   reference="`date -r $FULL_BACKUP_LAST`"
   find_options="-follow -newer $LAST_BACKUP_DATE"
   TOUCHME=$FULL_BACKUP_FLAG # indicate that another full backup is needed when the right day rolls around
   kind=INCREMENTAL
fi

#  find_options="-follow"


#### PNFS Database Backup ##################################################
# copy the files that have not been copied to tape

PNFS_FILES=$VAULT/pnfs.files
rm -f $PNFS_FILES
cmd="find $PNFS -type f $find_options -print > $PNFS_FILES"
list "$cmd"
eval $cmd
lines=`wc -l $PNFS_FILES | awk '{print $1}'`
list ""
list "PNFS databases backup: $lines files to backup to tape"
doit "cat $PNFS_FILES"
list ""
counter=0
cat $PNFS_FILES| while read file; do
  counter=`expr $counter + 1`;
  list "$counter of $lines PNFS database files: $file"
  saveit $file
done
if [ -f $QUIT ]; then exit 1; fi
rm -f $PNFS_FILES
cmd="find $PNFS -type f -follow -daystart -mtime +$TIMEONDISK -exec rm -fr {} \;"
list "$cmd"
eval $cmd

#### Enstore Database Backup ###############################################
# copy the files that have not been copied to tape

ENSTORE_FILES=$VAULT/enstore.files
rm -f $ENSTORE_FILES
cmd="find $ENSTORE -type f $find_options -print > $ENSTORE_FILES"
list "$cmd"
eval $cmd
lines=`wc -l $ENSTORE_FILES | awk '{print $1}'`
list ""
list "ENSTORE databases backup: $lines files to backup to tape"
doit "cat $ENSTORE_FILES"
list ""
counter=0
cat $ENSTORE_FILES| while read file; do
  counter=`expr $counter + 1`;
  list "$counter of $lines ENSTORE database files: $file"
  saveit $file
done
if [ -f $QUIT ]; then exit 1; fi
rm -f $ENSTORE_FILES
cmd="find $ENSTORE -follow -daystart -mtime +$TIMEONDISK -exec rm -fr {} \;"
list "$cmd"
eval $cmd




#### Enstore Log Backup ####################################################
# bzip2/copy the files that have not been copied, excluding today's, to tape

ENSTORELOG_FILES=$VAULT/enstorelog.files
rm -f $ENSTORELOG_FILES
NF="last" #avoid echo error, awk inserts its own value
echo find $ENSTORELOG -type f $find_options  -exec ls -l {} \; | grep -v "$today" | awk '{print $NF }'
     find $ENSTORELOG -type f $find_options  -exec ls -l {} \; | grep -v "$today" | awk '{print $NF }' > $ENSTORELOG_FILES
lines=`wc -l $ENSTORELOG_FILES | awk '{print $1}'`
list ""
list "ENSTORE log backup: $lines files to backup to tape"
doit "cat $ENSTORELOG_FILES"
list ""
counter=0
cat $ENSTORELOG_FILES| while read file; do
  counter=`expr $counter + 1`;
  list "$counter of $lines ENSTORE log files: $file"
  output=$VAULT/`basename $file`.$now.tbz2
  doit "bzip2 < $file > $output"
  saveit $output
  rm -f $output
done
if [ -f $QUIT ]; then exit 1; fi
rm -f $ENSTORELOG_FILES
cmd="find $ENSTORELOG -follow -daystart -mtime +30 -exec rm -fr {} \;"
list "$cmd"
eval $cmd




############################################################################

#next time, get only new files since we started the backup.
mv $START_BACKUP_DATE $LAST_BACKUP_DATE

touch $TOUCHME            # indicate that the backup was successful
if [ $kind = "FULL" ]; then
  rm -f $FULL_BACKUP_FLAG # indicate we've done the full backup on selected day (not twice per day)
fi



#  send mail to let people know what was backed up
cat $BACKUP_LOG | /usr/bin/Mail -s "Metadata tape backup log from $node on `uname -n`" $ENSTORE_MAIL

list "`date`: Finished backup on $node"

exit 0
