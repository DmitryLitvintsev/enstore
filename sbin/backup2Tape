#!/bin/sh
set -u  # force better programming and ability to use check for not set
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

# bin/$RCSfile$  $Revision$



# function to return date so it can be used in filename
date_string() { date +"%Y-%m-%d.%H.%M" ; }

# function to return date so it can be used in directory path
date_string_d() { date +"%Y/%m/%d/%H" ; }

list() { echo "$1"
         if [ "${BACKUP_LOG:-}" != "" ]; then echo "$1" >>$BACKUP_LOG; fi
       }

#function to list command, execute it and list status
doit() { list "$1"
         doutput=/tmp/doit_output
         rm -f $doutput
         eval "nice -n 20 $1" >>$doutput 2>&1
         status=$?
         if [ `echo $1 | grep -c encp` -ne 0 -a `grep -c STATUS=ok $doutput` -eq 0 ]; then status=1; fi
         cat $doutput
         if [ "${BACKUP_LOG:-}" != "" ]; then cat $doutput >>$BACKUP_LOG; fi
         list "Status= $status"
         list ""
         if [ $status -ne 0 ]; then touch $QUIT; exit $status ;fi
       }

saveit() { #  Tapes have to be declared to the volume server and in the correct storage family
           pnfsname=`echo $1 | tr '/' '-' | sed s/-//`
           ls -l $1
           doit "encp --data $verbose $1 $pnfspath/$pnfsname"
           status=$?
           ls -l $pnfspath/$pnfsname
           if [ $status -ne 0 ]; then touch $QUIT; exit $status; fi
         }

# $1: The directory that the pnfs metadata data is written.
make_pnfs_dir()
{
    # try to make a unique directory, but give up after 10 tries
    x=0;
    while [ $x -le 10 -a -d $pnfspath ]; do
	x=`expr $x + 1`
	pnfspath=${pnfspath}.next
    done
    if [ -d $pnfspath ]; then 
	list "$pnfspath exists, quitting" 
    fi
    mkdir -p $pnfspath
}

############################################################################
############################################################################

#### PNFS Database Backup ##################################################
# copy the files that have not been copied to tape
pnfs_database_backup()
{

    PNFS_FILES=$1
    PNFS=$2
    find_options=$3

    rm -f $PNFS_FILES
    # Only backup latest copy on disk, not all of them since we are running 
    # out of tape!
    find $PNFS $find_options -type f  -print | sort -r | while read f; do 
	basename $f | cut -f1 -d.
    done | uniq | while read g; do 
	ls -lt $PNFS/${g}.*.Z | head -n1 |awk '{print $NF}'
    done > $PNFS_FILES

    lines=`wc -l $PNFS_FILES | awk '{print $1}'`
    list ""
    list "PNFS databases backup: $lines files to backup to tape"
    doit "cat $PNFS_FILES"
    cat $PNFS_FILES | while read f ; do ls -l $f; done
    list ""
    counter=0
    cat $PNFS_FILES| while read file; do
	counter=`expr $counter + 1`;
	list "$counter of $lines PNFS database files: $file"
	saveit $file
    done
    if [ -f $QUIT ]; then exit 1; fi
    rm -f $PNFS_FILES
    find $PNFS -type f -follow -daystart -mtime +$TIMEONDISK -exec rm -fr {} \;

}

#### Enstore Database Backup ###############################################
# copy the files that have not been copied to tape
enstore_database_backup()
{

    ENSTORE_FILES=$1
    ENSTORE=$2
    find_options=$3
    
    rm -f $ENSTORE_FILES
    #only backup the latest directory copy.
    ELAST=`ls -ltd  $ENSTORE/dbase.* | head -n1 | awk '{print $NF}'`
    find $ELAST -type f $find_options -print > $ENSTORE_FILES
    find $ENSTORE/JOURNALS -type f $find_options -print > /tmp/journals
    cat /tmp/journals >> $ENSTORE_FILES

    lines=`wc -l $ENSTORE_FILES | awk '{print $1}'`
    list ""
    list "ENSTORE databases backup: $lines files to backup to tape"
    doit "cat $ENSTORE_FILES"
    list ""
    counter=0
    cat $ENSTORE_FILES| while read file; do
	counter=`expr $counter + 1`;
	list "$counter of $lines ENSTORE database files: $file"
	saveit $file
    done
    if [ -f $QUIT ]; then exit 1; fi
    rm -f $ENSTORE_FILES
    # rm backup journals
    for i in `cat /tmp/journals`
    do
	rm -f $i
    done
    rm -f /tmp/journals
    find $ENSTORE -follow -daystart -mtime +$TIMEONDISK -exec rm -fr {} \;

}


#### Enstore Log Backup ####################################################
# bzip2/copy the files that have not been copied, excluding today's, to tape
enstore_log_backup()
{

    ENSTORELOG_FILES=$1
    ENSTORELOG=$2
    find_options=$3

    rm -f $ENSTORELOG_FILES
    find $ENSTORELOG -type f $find_options  -name "LOG*"  -exec ls -l {} \; | grep -v "$today" | awk '{print $NF }' > $ENSTORELOG_FILES
    lines=`wc -l $ENSTORELOG_FILES | awk '{print $1}'`
    list ""
    list "ENSTORE log backup: $lines files to backup to tape"
    doit "cat $ENSTORELOG_FILES"
    list ""
    counter=0
    cat $ENSTORELOG_FILES| while read file; do
	counter=`expr $counter + 1`;
	list "$counter of $lines ENSTORE log files: $file"
	output=$VAULT/`basename $file`.$now.tbz2
	doit "bzip2 < $file > $output"
	saveit $output
	rm -f $output
    done
    if [ -f $QUIT ]; then exit 1; fi
    rm -f $ENSTORELOG_FILES
    find $ENSTORELOG -follow -daystart -mtime +30 -exec rm -fr {} \;
    find $ENSTORELOG -follow -daystart -name "DEBUGLOG*" -mtime +10 -exec rm -fr {} \;

}

############################################################################
############################################################################

init_backup()
{

    VAULT=$1
    QUIT=${VAULT}/QUIT

    rm -f ${BACKUP_LOG}

    make_pnfs_dir $pnfspath
    
    rm -f ${VAULT}/*.tbz2  #old junk
    rm -f ${QUIT}

    START_BACKUP_DATE=$VAULT/start_backup_date
    rm -f $START_BACKUP_DATE
    touch $START_BACKUP_DATE  #Make this now, mv'ing it later will NOT
                              # change the access time.

    LAST_BACKUP_DATE=$VAULT/last_backup_date
    list "Last backup on `ls -l $LAST_BACKUP_DATE`"

}

# Backup the three types of files.
full_backup()
{
    
    PNFS=$1
    PNFS_FILES=$2
    ENSTORE=$3
    ENSTORE_FILES=$4
    ENSTORELOG=$5
    ENSTORELOG_FILES=$6
    find_options=$7

    pnfs_database_backup $PNFS_FILES $PNFS "$find_options"
    enstore_database_backup $ENSTORE_FILES $ENSTORE "$find_options"
    enstore_log_backup $ENSTORELOG_FILES $ENSTORELOG "$find_options"

}

cleanup_backup()
{
    VAULT=$1

    START_BACKUP_DATE=$VAULT/start_backup_date
    LAST_BACKUP_DATE=$VAULT/last_backup_date

    #next time, get only new files since we started the backup.
    mv $START_BACKUP_DATE $LAST_BACKUP_DATE

    #  send mail to let people know what was backed up
    cat $BACKUP_LOG | /usr/bin/Mail -s "Metadata tape backup OK. Log from $node on `uname -n`" $ENSTORE_MAIL
    
    list "`date`: Finished backup on $node"
    
    #exit 0
    return 0

}

############################################################################
############################################################################

node=`uname -n| sed -e 's/\([^\.]\)\..*/\1/'`
today=`date +"%b %d"`;              export today
now=`date +"%s"`;                   export now
verbose="--verbose=1";              export verbose
TIMEONDISK=1  #days


# Fermi specific stuff
if [ $node = d0ensrv3 ]; then
  filePath='/diska'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  PNFS_FILES=${VAULT}/pnfs.files
  ENSTORE=${filePath}/enstore-backup
  ENSTORE_FILES=${VAULT}/enstore.files
  ENSTORELOG=${filePath}/enstore-log-backup
  ENSTORELOG_FILES=${VAULT}/enstorelog.files
  #QUIT=${VAULT}/QUIT
  pnfspath="/pnfs/eagle/d0en-backups/`date_string_d`"; export pnfspath
  ENSTORE_CONFIG_HOST=stkensrv2.fnal.gov
  # decided if we need to do a full backup or incremetal since last full backup
  if [ -n "${1:-}" ]; then
    find_options="-follow"
    #kind=FULL
  else
    LAST_BACKUP_DATE=$VAULT/last_backup_date
    find_options="-follow -newer $LAST_BACKUP_DATE"
    #kind=INCREMENTAL
  fi

  #Perform the backup.
  init_backup $VAULT  
  full_backup $PNFS $PNFS_FILES $ENSTORE $ENSTORE_FILES $ENSTORELOG $ENSTORELOG_FILES "$find_options"
  cleanup_backup $VAULT

elif [ $node = stkensrv3 ]; then
  filePath='/diska'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  PNFS_FILES=${VAULT}/pnfs.files
  ENSTORE=${filePath}/enstore-backup
  ENSTORE_FILES=${VAULT}/enstore.files
  ENSTORELOG=${filePath}/enstore-log-backup
  ENSTORELOG_FILES=${VAULT}/enstorelog.files
  #QUIT=${VAULT}/QUIT
  pnfspath="/pnfs/eagle/backups/`date_string_d`"; export pnfspath
  ENSTORE_CONFIG_HOST=stkensrv2.fnal.gov
  # decided if we need to do a full backup or incremetal since last full backup
  if [ -n "${1:-}" ]; then
    find_options="-follow"
    #kind=FULL
  else
    LAST_BACKUP_DATE=$VAULT/last_backup_date
    find_options="-follow -newer $LAST_BACKUP_DATE"
    #kind=INCREMENTAL
  fi

  #Perform the backup.
  init_backup $VAULT  
  full_backup $PNFS $PNFS_FILES $ENSTORE $ENSTORE_FILES $ENSTORELOG $ENSTORELOG_FILES "$find_options"
  
  #For the CMS PNFS database, we need to also get it backed up.
  PNFS=${filePath}/pnfs-backup-cms
  PNFS_FILES=${VAULT}/pnfs_cms.files
  pnfspath="/pnfs/eagle/cms-backups/`date_string_d`"; export pnfspath
  pnfs_database_backup $PNFS_FILES $PNFS "$find_options"

  cleanup_backup $VAULT

elif [ $node = cdfensrv3 ]; then
  filePath='/diska'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  PNFS_FILES=${VAULT}/pnfs.files
  ENSTORE=${filePath}/enstore-backup
  ENSTORE_FILES=${VAULT}/enstore.files
  ENSTORELOG=${filePath}/enstore-log-backup
  ENSTORELOG_FILES=${VAULT}/enstorelog.files
  #QUIT=${VAULT}/QUIT
  pnfspath="/pnfs/eagle/cdfen-backups/`date_string_d`"; export pnfspath
  ENSTORE_CONFIG_HOST=stkensrv2.fnal.gov
  # decided if we need to do a full backup or incremetal since last full backup
  if [ -n "${1:-}" ]; then
    find_options="-follow"
    #kind=FULL
  else
    LAST_BACKUP_DATE=$VAULT/last_backup_date
    find_options="-follow -newer $LAST_BACKUP_DATE"
    #kind=INCREMENTAL
  fi

  #Perform the backup.
  init_backup $VAULT  
  full_backup $PNFS $PNFS_FILES $ENSTORE $ENSTORE_FILES $ENSTORELOG $ENSTORELOG_FILES "$find_options"
  cleanup_backup $VAULT

elif [ $node = water ]; then
  filePath='/home/zalokar/enstore-backup'
  VAULT=${filePath}/BackupToTape
  BACKUP_LOG=${VAULT}/backup_log;     export BACKUP_LOG
  PNFS=${filePath}/pnfs-backup
  PNFS_FILES=${VAULT}/pnfs.files
  ENSTORE=${filePath}/enstore-backup
  ENSTORE_FILES=${VAULT}/enstore.files
  ENSTORELOG=${filePath}/enstore-log-backup
  ENSTORELOG_FILES=${VAULT}/enstorelog.files
  #QUIT=${VAULT}/QUIT
  pnfspath="/pnfs/mist/encp_test/h2oen-backups/`date_string_d`"; export pnfspath
  ENSTORE_CONFIG_HOST=131.225.84.1
  # decided if we need to do a full backup or incremetal since last full backup
  if [ -n "${1:-}" ]; then
    find_options="-follow"
    #kind=FULL
  else
    LAST_BACKUP_DATE=$VAULT/last_backup_date
    find_options="-follow -newer $LAST_BACKUP_DATE"
    #kind=INCREMENTAL
  fi

  #Perform the backup.
  init_backup $VAULT  
  full_backup $PNFS $PNFS_FILES $ENSTORE $ENSTORE_FILES $ENSTORELOG $ENSTORELOG_FILES "$find_options"
  cleanup_backup $VAULT

else
  doit "Do not know about node $node... fix $ENSTORE/sbin/backup2Tape script"
  exit 1
fi

