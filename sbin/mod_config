#!/bin/bash

# Modify enstore configuration or policy file

#========================================================
# Functions

PROGNAME=$(basename $0)

usage() {
cat << 'EOF' 1>&2
Usage: ${PROGNAME} [options] [--] [config_file.conf]
   where config_file.conf is stk.conf or stken_policy.py; cdf.conf, sam.conf

Change enstore configuration or SFA policy file. The file name is specified with
    option --policy or --config or file name as last argument (config). If config name is
    not specified it is taken from $ENSTORE_CONFIG_FILE. Exactly one file name must be specified.
The command shall be run on configuration server host.
Check if file content can be interpreted by enstore python.
Store configuration file in local git repository (commit) and push changes to remote repository.
See wiki for more details.
Load configuration/policy file to enstore configuration server if  Use --load, --noload to change this.

Options:
  -h | --help | -?      print this help message
       --config FILE    full name of configuration file [$ENSTORE_CONFIG_FILE]
                        File name must be full file name, no .conf is added.
       --policy FILE    full name of SFA policy file [$ENSTORE_CONFIG_FILE]
  -f | --file FILE      file name
       --gang           gang (system) name (stken, cdfen, d0en, ...)
       --editor EDITOR  use EDITOR to edit the file [env. $EDITOR or vi] and
                          also export it to be used by git to edit commit message
  -v | --verbose        be verobose. Increase verbosity level if used multiple times (-vv)
       --load           load configuration/policy file to configuration server
                          [loads if running on config server]
       --noload         do not load configuration/policy file
  -x                    sets -xv option when executing this script
       --               end of options, the rest is considered as arguments (file name)

Arguments:
   file                 file name to be modified. This is full file name like stken.conf
                        If file name ends on .conf , it is configuration file.
                        If file name ends on _policy.py, it is policy file.
                        If file is not *.conf or *_policy.py, we try to add suffix .conf to
                          file name <file>.conf to simulate old behavior.
EOF
}

#-------------------------------------------------------------
abort_usg ()        { echo ${1:-} >&2 ; usage ; exit -2 ; }
abort ()            { echo ${1:-} >&2 ; exit -1 ; }
finish_OK ()        { echo ${1:-}     ; exit  0 ; }

success ()          { printf "... ${1:-success}\n\n"; }
end_of_compare ()   { printf "... end of compare\n\n"; }

confirm_or_exit () {
    echo -n "${1:-'Confirm: press Y to continue'}" ' [Y/n] '
    read ans || abort "read answer failed"
    answer=`echo ${ans:-Y}|cut -c1 | tr [a-z] [A-Z]`
    if [ "$answer" != "Y" ]; then
        echo ${2:-"ok, exiting"}
        exit 1
    fi
}

#-------------------------------------------------------------
# Parse arguments
set +u

# Reset all variables that might be set
debug=false
test=false
file=""
config_file=""
policy_file=""
nfiles=0
verbose=0
gang=""
editor=""
load=true

errors=0
while :
do
    case ${1-} in
    -h | --help | -\?)
        usage
        exit 0;;
    -f | --file)
        file=$2
        shift 2
        ;;
    --gang)
        gang=$2
        shift 2
        ;;
    --editor)
        editor=$2
        shift 2
        ;;
    --config)
        config=$2
        shift 2
        ;;
    --load)
        load=true
        shift
        ;;
    --noload)
        load=false
        shift
        ;;
    --policy)
        policy=$2
        shift 2
        ;;
    -v | --verbose)
        # Each instance of -v adds 1 to verbosity                                                                                                   
        verbose=$((verbose+1))
        shift
        ;;
    --test)
        echo "TEST:  this script uses test setings"
        test=true
        shift
        ;;
    -x)
        set -xv
        shift
        ;;
    --) # End of all options
        shift
        break
        ;;
    -*)
        echo "Unknown option: $1" >&2
        errors=$((errors+1))
        shift
        ;;
    *)  # no more options. Stop while loop                                                                                                          
        break
        ;;
    esac
done

echo "Args left @" $@
echo "Args left *" $*
echo "Args left #" $#

echo errors: $errors

if [ $errors -ne 0 ]
then
    usage
    exit 1
fi

set -u
# end parse arguments
#-------------------------------------------------------------
# Check we got all required options

echo gang: $gang
echo config: $config
echo policy: $policy

if [ ! "$file" ]; then
    echo "Final check: ERROR: option '--file FILE' not given. See --help" >&2
    exit 1
fi

#========================================================


#-------------------------------------------------------------
[[ $verbose > 1 ]] && echo "DEBUG: this script uses debug settings"

#-------------------------------------------------------------
[[ $(whoami) == "enstore" ]] || abort "You must be user enstore to modify the enstore config file"

#-------------------------------------------------------------
# set system name
gang=`gang`

if $test
then
    gang=dms-test
    echo "TEST:  gang reset to $gang"
fi
echo gang=$gang
echo
#-------------------------------------------------------------
# set 'loadit' to mark if we're going to load the configuration file at the end

cfg_host=`echo $ENSTORE_CONFIG_HOST | cut -f1 -d\.`
node=`$ENSTORE_DIR/sbin/hostname.py | cut -f1 -d\.`
# my node is ...
case $node in
# I do not think we need this clause, and it was broken as written
#    # known configuration host
#    stkensrv2n|d0ensrv2n|cdfensrv2n)
#        loadit=1
#        ;;
    # current configuration host as set in environment
    #   usually FQDN like dmsen02.fnal.gov
    ${ENSTORE_CONFIG_HOST})
        loadit=1
        ;;
    # current configuration host set in environment, short
    ${cfg_host})
        loadit=1
        ;;
    *)
        loadit=0
        ;;
esac

#-------------------------------------------------------------
# We need enstore to be setup
if [ -z "${ENSTORE_DIR-}"  ]; then
   . /usr/local/etc/setups.sh
   setup enstore
fi
if [ -z "${ENSTORE_DIR-}"  ]
then
    abort "ENSTORE_DIR not set and 'setup enstore' can not set it"
fi

# We need a config file to change
if [ -n "${ENSTORE_CONFIG_FILE-}" ]
then
    config=`basename $ENSTORE_CONFIG_FILE`
    dir=`dirname $ENSTORE_CONFIG_FILE`
elif [ -z "${1-}" ]
    then
        abort_usg  "you need to specify a config file"
    else
        # Use default location which is usually ~enstore/site_specific/config :
        dir=${ENSTORE_CONFIG_DIR}
        config=$1.conf
fi

#@todo: specify stken_policy.py
# [[ ${ENSTORE_SFA_POLICY:-x} = "x" ]] || export ENSTORE_SFA_POLICY
# we have: ENSTORE_GANG=dmsen
#@todo: we can edit file other than ENSTORE_CONFIG_FILE and distribute it?

file=$(basename $config)
gitdir=$(dirname $dir)/config
# Note:
#   config refers to file name
#   TEMPconfig refers to ansolute path of temp file for edit

# - Leave it as in original script
#-x TEMPconfig=$gitdir/$file
TEMPconfig=`mktemp /tmp/${config}.XXXXXX` ||
    abort "can not mktemp for temporary file /tmp/${config}.XXXXXX"

echo "The following configuration file will be modified: $dir/$config";

#-------------------------------------------------------------
if [[ $verbose > 1 ]]
then
    echo "  dir=$dir"
    echo "  gitdir=$gitdir"
    echo "  config=$config"
    echo "  TEMPconfig=$TEMPconfig"
    echo
fi
#-------------------------------------------------------------
# Asserts:

[ ! -d $dir ]         || abort "configuration directory $dir does not exist"
[ ! -d $gitdir ]      || abort "git configuration directory $gitdir does not exist"
[ ! -r $dir/$config ] || abort "can not read $config"

#-------------------------------------------------------------
# if the user wants a specific editor, use it
# otherwise use vi since it is always there
if [ -z "${2-}"  ]; then
    edcmd=${EDITOR:-vi}
else
    edcmd=$2
fi

export EDITOR=$edcmd # probably not needed, just did it so it is set
export VISUAL=$edcmd # needed for cvs check in

#-------------------------------------------------------------
# do all changes in git configuration directory first
cd $gitdir || abort "can not  cd $gitdir"

# make sure we are using the latest config from remote repository
echo "updating local git repository from remote"
# fetch data from remote preconfigured repository 'enconfig'
git fetch enconfig && success || abort "Something wrong with 'git fetch enconfig'. Investigate"

echo "git status (all files):"
git status -uno
echo "... end of git status"

[ ! -r $file ] || abort "file $gitdir/$file is unreadable in configuration directory"

echo "compare configuration file fetched from remote repo and local condifuration file"
diff -q $dir/$file $gitdir/$file ||
    abort "Files differ. diff $dir/$file $gitdir/$file . Investigate"
end_of_compare

# Edit file
#   the configuration file is in e.g. /opt/enstore/etc, or equvivalent.
#   we will edit configuration file in e.g. /opt/enstore/config, or equvivalent.

# edit temporary file allowing the user to make changes
echo "DISPLAY=${DISPLAY:-<notset>}, about to edit with command $edcmd $TEMPconfig"

# make a copy and edit it
rm -f $TEMPconfig
cp -p $config $TEMPconfig || abort "can not copy file to edit"

$edcmd $TEMPconfig && success || abort "Something wrong with editing. Investigate"

#-------------------------------------------------------------
# Check if updated file can be interpreted by python

#echo "Checking $TEMPconfig is python file:"
sed -n '1p' $TEMPconfig | grep python 
if [ $? -ne 0 ]; then
    abort "edited file $TEMPconfig is not python script (no 'python' on first line)"
fi

echo "Checking $TEMPconfig by running python $TEMPconfig"
python $TEMPconfig && success || abort "Running python on $TEMPconfig found errors."

#-------------------------------------------------------------
# ok, time to commit - confirm
confirm_or_exit "About to commit changes, is this what you want [Y/n] " \
    "ok, aborting"

#-------------------------------------------------------------
# Configuration modification complete.
# now:
# - copy temp file to the real configuration file;
# - commit to remote repository
# - copy to other nodes on cluster (where it is not used) 

# copy temporary file $TEMPconfig to $config before committing
cp -p $TEMPconfig $config
rm -f $TEMPconfig

# commit changes locally to git repository
echo "committing:"
git commit -- $file && success || abort "Something wrong with git commit. Investigate"

echo "push changes to remote git configuration repository"
git push enconfig   && success || abort "Something wrong with 'git push enconfig.' Investigate"

echo "get changes back from remote git configuration repository"
git fetch enconfig  && succes "OK"

echo "compare files with local repository:"
git diff --stat HEAD -- $file
end_of_compare

echo "compare files with remote repository:"
git diff --stat HEAD~ -- $file
end_of_compare

#---------------------------------------------------
# Distribute configuration file
#
echo "Copy $config to configuration directory:"

echo "  on configuration host (locally)"
# I think rgang will rewrite this file as enstore rgang does not have -C option
# - Leave it as is in original script

# @todo:
cp -p $TEMPconfig $dir/$config || abort "cp -p $TEMPconfig $dir/$config failed"

# update config file on all machines

# Note, in the original script file location on remote node is based on
#   $ENSTORE_DIR setting on the node where the file was edited
#   but not the setting on remote node.
#   Leave it as in original script.

echo "  synchronizing $config to gang $gang (remotely)"
rgang -c $gang $TEMPconfig $dir/$config

#---------------------------------------------------
cmd_load_conf="enstore config --load --config_file=$ENSTORE_CONFIG_DIR/$config"
# check for situations where loading in the config file will not work.
if [ $loadit -ne 1 ]; then
#@todo: do not tell "Not on ..." when user set the option
    msg="Not on stkensrv2, cdfensrv2 or d0ensrv2.
Do not know how to load config file.
Try: ${cmd_load_conf}"

    finish_OK $msg
fi

#---------------------------------------------------
# all is good, load the config file.
if [ $loadit -eq 1 ]; then
    confirm_or_exit 'About to load new config file into server, is this what you want' \
        'ok, done'

    # Note:
    #  if the file name is specified on command line, it is not what we load here
    #  but we leave it as in original script

    echo "Loading configuration file $ENSTORE_CONFIG_DIR/$config
    echo "DEBUG: ${cmd_load_conf}"
### ${cmd_load_conf}
fi
