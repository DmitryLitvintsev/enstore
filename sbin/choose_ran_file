#!/bin/sh
set -u
if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

if [ "${1:-}" = "-C" ] ; then copyit=1; shift; else copyit=0; fi

# script to return a random file name(s) for tapes in the current inventory

node=`uname -n| sed -e 's/\([^\.]\)\..*/\1/'`
gang=`gang`

HTTP=http://${gang}srv2.fnal.gov
USE_WGET=1 #or 0 to do things with database values

COUNT=${1:-1}
FORGET=${2:-CLN}
MUSTHAVE=${3:-""}
EXTRA=${5:-""}
WHICH_FILE=${4:-"onlyran"} # valid values are "onlylast" or "alsolast" or "onlyfirst" or "alsofirst" or "onlyfirstlast" or "alsofirstlast" or "onlyran"
here=`pwd`
override_ro=""
echo $EXTRA | egrep "full|readonly|migrated"
if [ $? -eq 0 ] ; then
    override_ro="--override-ro-mount"
fi
# Get the volumes that are defined in the inventory
if [ $USE_WGET -eq 1 ] ; then
   echo `date` wget $HTTP/enstore/tape_inventory/VOLUMES_DEFINED
   rm -f VOLUMES_DEFINED; wget $HTTP/enstore/tape_inventory/VOLUMES_DEFINED 2>/dev/null
   rc=$?; if [ $rc -ne 0 ]; then echo "wget VOLUMES_DEFINED FAILED"l exit $rc;else echo `date` got it; fi
else
   echo "`date` enstore info --vols > VOLUMES_DEFINED"
   rm -f VOLUMES_DEFINED; enstore info --vols > VOLUMES_DEFINED 2>/dev/null
   rc=$?; if [ $rc -ne 0 ]; then echo "enstore info --vols > VOLUMES_DEFINED FAILED"l exit $rc;else echo `date` got it; fi
fi

# get rid of all the entries that won't work (deleted, noaccess, notallowed, headers, trailers, null...)
# get rid of all the entries that the user explicitly told us to forget ($FORGET)
# look for all the entries that the user explicitly told us we must have
egrep -v "$FORGET|CLN|NUL|^Date|^label|DELETED|NOTALLOWED|NOACCESS|\.none\$" VOLUMES_DEFINED | egrep "$MUSTHAVE" | egrep "$EXTRA" >V_D

N=`wc V_D| awk '{print $1}'`
if [ $N -eq 0 ]; then
   echo "NO files found after excluding \"$FORGET\"  and then searching for \"$MUSTHAVE\""
   rm V_D
   exit 1
fi

done=$COUNT
loops=0
RC=0

while [ $done -gt 0 ]; do

  cd $here
  loops=`expr $loops + 1`
  if [ $loops -ge 1000 ]; then echo "TOO MANY LOOPS = $loops, EXIT"; rm -f V_D;exit 1; fi

  # choose a random volume from the list
  ran=`python -c "import whrandom;print whrandom.randint(1,"$N")"`
  tape=`head -n $ran V_D|tail -n 1| awk '{print $1}'`

  # get up to date information on the tape to make sure we have a chance to read a file
  echo `date` enstore info --vol $tape
  tinfo=`enstore info --vol $tape`
  echo "$tinfo"
  if [ `echo $tinfo | egrep -c 'DELETED|NOTALLOWED|NOACCESS'` -ne 0 ]; then
    echo REJECTED $tape is DELETED/NOTALLOWED/NOACCESS
    continue
  fi

  # get the files list for that volume
  if [ $USE_WGET -eq 1 ] ; then
     echo `date` wget $HTTP/enstore/tape_inventory/$tape
     rm -f $tape; wget $HTTP/enstore/tape_inventory/$tape  2>/dev/null
     rc=$?; if [ $rc -ne 0 ]; then echo "wget $tape FAILED "; exit $rc;else echo `date` got it; fi
  else
     echo `date` "enstore file --list $tape > $tape"
     rm -f $tape; enstore file --list > $tape  2>/dev/null
     rc=$?; if [ $rc -ne 0 ]; then echo "enstore file --list $tape FAILED "; exit $rc;else echo `date` got it; fi
     echo `date` "enstore info --vol $tape >> $tape"
     enstore info --vol $tape >> $tape  2>/dev/null
     rc=$?; if [ $rc -ne 0 ]; then echo "enstore info --vol $tape FAILED "; exit $rc;else echo `date` got it; fi
  fi

  # make sure this volume is still on the readable list.
  if [ `egrep -c 'DELETED|NOACCESS|NOTALLOWED' $tape` -ne 0 ]; then echo `date` REJECTED $tape is DELETED/NOACCESS/NOTALLOED; rm -f $tape; continue; fi

  # get rid of volume information - we already processed that and don't need it anymore.
  # get rid of all files the user already deleted. We don't want to read these files.
  # if there aren't any files left, start over with a new tape.
  grep /pnfs $tape | egrep -v 'deleted|  yes /' > ${tape}_
  rm -f $tape
  NF=`wc ${tape}_| awk '{print $1}'`
  if [ $NF -le 0 ]; then echo `date` REJECTED NO SUITABLE FILES on $tape; rm  ${tape}_; continue; fi

  # ignore hidden files and sort the filelist according to location on the tape
  grep -v '\/\.' ${tape}_ | sort -k4 > ${tape}__
  mv  ${tape}__  ${tape}_

  # choose a random file and  1st and last non-deleted files on the random volume
  ran=`python -c "import whrandom;print whrandom.randint(1,"$NF")"`
  file=`head -n $ran ${tape}_|tail -n 1| awk '{print $NF,$1,$3,$4,$2}'`
  file1=`head -n 1 ${tape}_ | awk '{print $NF,$1,$3,$4,$2}'`
  filel=`tail -n 1 ${tape}_ | awk '{print $NF,$1,$3,$4,$2}'`
  rm -f ${tape}_

  # user could have renamed it - find current name using pnfsid
  files=""
  for thefile in "$file" "$file1" "$filel"; do
      F=`echo $thefile | awk '{print $1}'`
      R=`echo $thefile | awk '{print $2,$3,$4,$5}'`
      if [ ! -r $F ]; then
        bfid=`echo $file | awk '{print $NF}'`
        info=`enstore file --bfid $bfid 2>/dev/null`
        if [ $? -ne 0 ]; then echo `date` REJECTED CAN NOT FIND BFID $bfid on $tape; continue 2; fi
        pnfsid=`echo $info | sed -e "s/.*pnfsid': '//" -e "s/'.*//"`
        D=`dirname $F`
        cd $D 2>/dev/null
        if [ $? -ne 0 ]; then echo `date` REJECTED CAN NOT FIND DIRECTORY $D from $tape; continue 2; fi
        FN=`cat ".(nameof)($pnfsid)" 2>/dev/null`
        if [ $? -ne 0 ]; then echo `date` REJECTED CAN NOT FIND FILENAME from pnfsid $pnfsid  from $tape;  continue 2; fi
        if [ ! -r $FN ]; then echo `date` REJECTED CAN NOT READ FILE $FN from $tape;  continue 2; fi
        file="$FN $R"
        F=$FN
      fi
      files="$files $F"
  done
  ran_file=`echo $files |awk '{print $1}'`
  first_file=`echo $files |awk '{print $2}'`
  last_file=`echo $files |awk '{print $3}'`


  # make a list of what the user wants:
  # valid values are "onlylast" or "alsolast" or "onlyfirst" or "alsofirst" or "onlyfirstlast" or "alsofirstlast" or "onlyran"
  case $WHICH_FILE in
    onlyran)       thefiles=$ran_file ;;
    onlyfirst)     thefiles=$first_file ;;
    onlylast)      thefiles=$last_file ;;
    onlyfirstlast) thefiles="$first_file $last_file" ;;
    alsofirst)     thefiles="$ran_file $first_file" ;;
    alsolast)      thefiles="$ran_file $last_file" ;;
    alsofirstlast) thefiles="$ran_file $first_file $last_file" ;;
    *)             thefiles=$ranfile ;;
  esac

  # ok, just tell the user the name of the file and do another if needed
  # or copy the file to /dev/null if user requested this
  if [ $copyit -eq 0 ]; then
    echo $thefiles
  else
    echo
    echo Random volume = $tape 
    echo Random file = $file
    echo First  file = $file1 
    echo Last   file = $filel
    echo 

    #List the number of active volumes.  This will give more meaningful
    # output for the administrators.
    library=`enstore info  --vol $tape | grep library | cut -d' ' -f3`
    library=`echo $library | tr ",'" "  " | sed "s/ //"`
    cmd="enstore lib --vols $library"
    echo $cmd
    vols_at_movers=`eval $cmd`
    echo "$vols_at_movers"
    #If the system is busy, don't start encp.
    busy_movers=`echo "$vols_at_movers" | wc -l`
    #Subract the title line of output.
    busy_movers=`expr $busy_movers - 1`
    #This test should compare this number to the number of drives in the
    # library.  I don't know of a good way from bash to get the number of
    # drives in a library, so for now using the value 6.
    if [ $busy_movers -gt 6 ]; then
      echo
      echo "Aborting early from high mover usage."
      echo
      #5 seems like a good number. Its greater than 3 indicating 3 failures.
      #  It is not -1, -2, 0, 10 or 7 which have special meaning in the plots.
      #9-10-2002: Edited to return 0 instead of 5.  Emails were being 
      # generated that make this the simpliest solution.
      exit 0
    fi

    for f in $thefiles; do
      cmd="encp --verbose 10 --bypass-filesystem-max-filesize-check --max-resubmit 7 --delayed-dismount 1 $override_ro $f /dev/null"
      echo $cmd
      eval $cmd
      rc=$?
      RC=`expr $RC + $rc`
    done
  fi
  done=`expr $done - 1`
done

rm -f V_D
cd $here

exit $RC
