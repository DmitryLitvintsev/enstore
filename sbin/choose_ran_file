#!/bin/sh

#
# Script to return a random file name(s) for tapes in the current inventory.
#  Optionaly, attempt to copy the files from tape using encp (see
#  copy_ran_file).
#

set -u

if [ "${1:-}" = "-x" ] ; then set -xv; shift; fi

if [ "${1:-}" = "-V" ] ; then verbose=1; shift; else verbose=0; fi

if [ "${1:-}" = "-C" ] ; then copyit=1; shift; else copyit=0; fi

if [ "${1:-}" = "-F" ] ; then force_try=1; shift; else force_try=0; fi

#  $1 should be the number of tapes to list/copy.
#  $2 should be one of: "onlylast" or "alsolast" or "onlyfirst" or "alsofirst" 
#                       or "onlyfirstlast" or "alsofirstlast" or "onlyran"

if [ "$ENSTORE_CONFIG_HOST"x == x ]; then
   source /usr/local/etc/setups.sh
   if [ -f $HOME/enstore ]; then
      setup -r `cd $HOME/enstore;pwd` enstore
   else
      setup enstore
   fi
fi

#node=`uname -n| sed -e 's/\([^\.]\)\..*/\1/'`
#gang=`gang`
#HTTP=http://${gang}srv2.fnal.gov
#USE_WGET=1 #or 0 to do things with database values
#FORGET=${2:-CLN}  #Not used anymore.
#MUSTHAVE=${3:-""} #Not used anymore.
#EXTRA=${5:-""}    #Not used anymore.
#echo $EXTRA | egrep "full|readonly|migrated"
#if [ $? -eq 0 ] ; then
#    override_ro="--override-ro-mount"
#fi

COUNT=${1:-1}
# valid values are "onlylast" or "alsolast" or "onlyfirst" or "alsofirst" 
#  or "onlyfirstlast" or "alsofirstlast" or "onlyran"
WHICH_FILE=${2:-"onlyran"}

here=`pwd`
override_ro=""
tmp_dir=/tmp

#Get the list of suitable tapes for testing.
enstore info --query "select label,library,media_type,wrapper,write_protected
from volume where 
    label not like '%.deleted' and 
    label not like 'CLN%' and 
    label not like '%:%' and
    system_inhibit_0 = 'none' and
    user_inhibit_0 = 'none' and
    last_access <> -1 and
    media_type <> 'null' and
    library not like '%shelf%'
order by label;" \
    | sed '1,2d' > $tmp_dir/V_D

N=`wc /$tmp_dir/V_D| awk '{print $1}'`

if [ $verbose -eq 1 ]; then
    echo "Found $N suitable tapes."
    cat /$tmp_dir/V_D
fi
   
if [ $N -eq 0 ]; then
   rm /$tmp_dir/V_D
   exit 1
fi

done=$COUNT
loops=0
RC=0

while [ $done -gt 0 ]; do

  cd $here
  loops=`expr $loops + 1`
  if [ $loops -ge 1000 ]; then echo "TOO MANY LOOPS = $loops, EXIT"; 
    rm -f $tmp_dir/V_D;
    exit 1; 
  fi

  # choose a random volume from the list
  ran=`python -c "import random;print random.randint(1,"$N")"`
  tape=`head -n $ran /$tmp_dir/V_D|tail -n 1| awk '{print $1}'`

  # Get up to date information on the tape to make sure we have a chance 
  # to read a file.
  if [ $verbose -eq 1 ]; then
    echo `date` enstore info --vol $tape
  fi
  tinfo=`enstore info --vol $tape`
  if [ $verbose -eq 1 ]; then
    echo "$tinfo"
  fi
  if [ `echo $tinfo | egrep -c 'DELETED|NOTALLOWED|NOACCESS'` -ne 0 ]; then
    echo REJECTED $tape is DELETED/NOTALLOWED/NOACCESS
    continue
  fi
  #MWZ: I'm not sure way choose_ran_file/copy_ran_file would need to test
  # the write tab status of the tape?  Sasha agreed that it should not
  # care.  (5-15-2007)
  #if [ `echo $tinfo | egrep -c "full|readonly|migrated"` -ne 0 ]; then
  #   override_ro="--override-ro-mount"
  #   echo "override $override"
  #fi

  enstore info --list $tape | sed '1,2d' > $tmp_dir/$tape

  # make sure this volume is still on the readable list.
  if [ `egrep -c 'DELETED|NOACCESS|NOTALLOWED' /$tmp_dir/$tape` -ne 0 ]; then 
	echo `date` REJECTED $tape is DELETED/NOACCESS/NOTALLOED
	rm -f /$tmp_dir/$tape
	continue
  fi

  # Get rid of volume information - we already processed that and don't 
  # need it anymore. #Get rid of all files the user already deleted. 
  # We don't want to read these files.  If there aren't any files left, 
  # start over with a new tape.  gnore hidden files and sort the filelist 
  # according to location on the tape.
  grep /pnfs $tmp_dir/$tape | egrep -v 'deleted|  yes /' | grep -v '\/\.' | sort -k4 > $tmp_dir/${tape}_
  rm -f $tmp_dir/$tape
  NF=`wc $tmp_dir/${tape}_| awk '{print $1}'`
  if [ $NF -gt 0 ]; then 
    if [ $verbose -eq 1 ]; then echo `date`: $NF SUITABLE FILES on $tape; fi
  else
    if [ $verbose -eq 1 ]; then echo `date`: NO SUITABLE FILES on $tape; fi
    rm -f $tmp_dir/${tape}_
    continue
  fi

  # Choose a random file and  1st and last non-deleted files on the 
  # random volume
  ran=`python -c "import random;print random.randint(1,"$NF")"`
  file_r=`head -n $ran $tmp_dir/${tape}_ | tail -n 1 | awk '{print $NF,$1,$3,$4,$2}'`
  file_f=`head -n 1 $tmp_dir/${tape}_ | awk '{print $NF,$1,$3,$4,$2}'`
  file_l=`tail -n 1 $tmp_dir/${tape}_ | awk '{print $NF,$1,$3,$4,$2}'`
  rm -f $tmp_dir/${tape}_

  #We are going to need these...
  ran_bfid=`echo $file_r | awk '{print $5}'`
  first_bfid=`echo $file_f | awk '{print $5}'`
  last_bfid=`echo $file_l |awk '{print $5}'`
   
  #...and these...
  ran_pnfsid=`enstore info --bfid $ran_bfid | grep pnfsid | cut -c 13-36`
  first_pnfsid=`enstore info --bfid $first_bfid | grep pnfsid | cut -c 13-36`
  last_pnfsid=`enstore info --bfid $last_bfid | grep pnfsid | cut -c 13-36`

  #...to get these.
  ran_file=`enstore pnfs --path $ran_pnfsid`
  rc_r=$?
  first_file=`enstore pnfs --path $first_pnfsid`
  rc_f=$?
  last_file=`enstore pnfs --path $last_pnfsid`
  rc_l=$?

  if [ $rc_r -ne 0 -o $rc_f -ne 0 -o $rc_l -ne 0 ]; then
    #One likely reason that this step would fail, is that we have a pnfsid
    # that exists in two different PNFSes.  (i.e. stkensrv1 and cmspnfs1)
    #Another is that we don't have sufficient permissions to access the
    # file in PNFS.
    echo "Failed finding suitable files."
    #  echo $ran_bfid $ran_pnfsid $ran_file 
    #  echo $first_bfid $first_pnfsid $first_file
    #  echo $last_bfid $last_pnfsid $last_file
    continue
  fi

  # Make a list of what the user wants.  Valid values are:
  #  "onlylast" or "alsolast" or "onlyfirst" or "alsofirst" 
  #  or "onlyfirstlast" or "alsofirstlast" or "onlyran"
  case $WHICH_FILE in
    onlyran)       thefiles=$ran_file; thebfids=$ran_bfid;;
    onlyfirst)     thefiles=$first_file; thebfids=$first_bfid;;
    onlylast)      thefiles=$last_file; thebfids=$last_bfid;;
    onlyfirstlast) thefiles="$first_file $last_file"; thebfids="$first_bfid $last_bfid";;
    alsofirst)     thefiles="$ran_file $first_file"; thebfids="$ran_bfid $first_bfid";;
    alsolast)      thefiles="$ran_file $last_file"; thebfids="$ran_bfid $last_bfid";;
    alsofirstlast) thefiles="$ran_file $first_file $last_file"; thebfids="$ran_bfid $first_bfid $last_bfid";;
    *)             thefiles=$ran_file; thebfids=$ran_bfid;;
  esac

  # ok, just tell the user the name of the file and do another if needed
  # or copy the file to /dev/null if user requested this
  if [ $copyit -eq 0 ]; then
    echo $thefiles
  else
    echo
    echo Random volume = $tape 
    echo Random file = $file_r
    echo First  file = $file_f
    echo Last   file = $file_l
    echo 

    #List the number of active volumes.  This will give more meaningful
    # output for the administrators.
    library=`enstore info  --vol $tape | grep library | cut -d' ' -f3`
    library=`echo $library | tr ",'" "  " | sed "s/ //"`
    cmd="enstore lib --vols $library"
    echo $cmd
    vols_at_movers=`eval $cmd`
    echo "$vols_at_movers"
    #If the system is busy, don't start encp.
    busy_movers=`echo "$vols_at_movers" | wc -l`
    #Subract the title line of output.
    busy_movers=`expr $busy_movers - 1`
    #This test should compare this number to the number of drives in the
    # library.  I don't know of a good way from bash to get the number of
    # drives in a library, so for now using the value 6.  If -F was specified
    # on the command line (force_try = 1), we will force choose_ran_file to 
    # skip this test and force it to run the encp(s).
    if [ $busy_movers -gt 6 -a $force_try -eq 0 ]; then
      echo
      echo "Aborting early from high mover usage."
      echo
      #5 seems like a good number. Its greater than 3 indicating 3 failures.
      #  It is not -1, -2, 0, 10 or 7 which have special meaning in the plots.
      #9-10-2002: Edited to return 0 instead of 5.  Emails were being 
      # generated that make this the simpliest solution.
      exit 0
    fi

    #for f in $thefiles; do
    #  cmd="encp --verbose 10 --bypass-filesystem-max-filesize-check --max-resubmit 7 --delayed-dismount 1 $override_ro $f /dev/null"
    #  echo $cmd
    #  eval $cmd
    #  rc=$?
    #  RC=`expr $RC + $rc`
    #done
    for b in $thebfids; do
      cmd="encp --verbose 10 --bypass-filesystem-max-filesize-check --max-resubmit 7 --delayed-dismount 1 $override_ro --get-bfid $b /dev/null"
      echo $cmd
      eval $cmd
      rc=$?
      RC=`expr $RC + $rc`
    done
  fi
  done=`expr $done - 1`
done

rm -f $tmp_dir/V_D
cd $here

exit $RC
